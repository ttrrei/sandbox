--
-- PostgreSQL database dump
--

-- Dumped from database version 13.7
-- Dumped by pg_dump version 14.2

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: cal; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA cal;


--
-- Name: mnp; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA mnp;


--
-- Name: mtd; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA mtd;


--
-- Name: ods; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA ods;


--
-- Name: rpt; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA rpt;


--
-- Name: rtc; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA rtc;


--
-- Name: vlt; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA vlt;


--
-- Name: xpt; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA xpt;


--
-- Name: backup_snapshot(); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.backup_snapshot() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN
insert into vlt.backup_cal_ema_on_ha_long_snapshot  
select *, current_timestamp from cal.v_ema_on_ha_long_current;

insert into vlt.backup_cal_ema_on_ha_short_snapshot  
select *, current_timestamp from cal.v_ema_on_ha_short_current;

insert into vlt.backup_cal_ema_on_sar_long_snapshot 
select *, current_timestamp from cal.v_ema_on_sar_long_current;

insert into vlt.backup_cal_ema_on_sar_short_snapshot  
select *, current_timestamp from cal.v_ema_on_sar_short_current;




insert into vlt.backup_cal_stb_on_ha_long_snapshot  
select *, current_timestamp from cal.v_stb_on_ha_long_current;

insert into vlt.backup_cal_stb_on_ha_short_snapshot  
select *, current_timestamp from cal.v_stb_on_ha_short_current;

insert into vlt.backup_cal_stb_on_sar_long_snapshot 
select *, current_timestamp from cal.v_stb_on_sar_long_current;

insert into vlt.backup_cal_stb_on_sar_short_snapshot  
select *, current_timestamp from cal.v_stb_on_sar_short_current;




insert into vlt.backup_cal_full_long_snapshot  
select *, current_timestamp from cal.v_full_long_current;

insert into vlt.backup_cal_full_short_snapshot  
select *, current_timestamp from cal.v_full_short_current;

END;
';


--
-- Name: master_pipeline(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.master_pipeline(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

PERFORM  cal.subpipe_actionable_list(c_date);
PERFORM  cal.subpipe_volume_range(c_date);
PERFORM  cal.subpipe_trading_days (c_date);
PERFORM  cal.subpipe_heikin_ashi(c_date);
PERFORM  cal.subpipe_moving_range(c_date);
PERFORM  cal.subpipe_ema(c_date);
PERFORM  cal.subpipe_volume_range(c_date);
PERFORM  cal.subpipe_ema_trend(c_date);
PERFORM  cal.subpipe_sar(c_date);
PERFORM  cal.subpipe_index_direction(c_date);
PERFORM  cal.subpipe_ema_on_ha(c_date);
PERFORM  cal.subpipe_ema_on_sar(c_date);
PERFORM  cal.subpipe_stb_on_ha(c_date);
PERFORM  cal.subpipe_stb_on_sar(c_date);
PERFORM  cal.subpipe_ha_ema(c_date);
PERFORM  cal.subpipe_ha_macd(c_date);
PERFORM  cal.subpipe_rpt(c_date);

END;
';


--
-- Name: rush_1230_ha(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.rush_1230_ha(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists rtc;
create temp table rtc as 
select * from vlt.rush_1230 
where load_date = c_date;

drop table if exists temp ;
create temp table temp as 
select *
	, row_number() over (partition by code order by load_date desc) as rnum
	from cal.heikin_ashi 
	where load_date < c_date;

drop table if exists output;
create temp table output as 
select r.code, r.load_date, r.open as s_open, r.close as s_close
, r.low as s_low, r.high as s_high
, case when t.open is null and t.close is null then (r.open + r.close)/2 
	else (t.open + t.close)/2
end as h_open
, (r.open + r.high + r.low + r.close)/4 as h_close
from rtc r
left outer join temp t
on r.code = t.code 
where rnum = 1;

insert into rtc.ha_1230 select code, load_date, h_open::numeric(10,4)
	, greatest( s_high, h_open, h_close)::numeric(10,4) as h_high
	, least( s_low, h_open, h_close)::numeric(10,4) as h_low
	, h_close::numeric(10,4)
	, current_timestamp as sys_load_time
from output;

END;
';


--
-- Name: rush_1230_index(); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.rush_1230_index() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists temp_records;
create temp table temp_records as 
with temp as (
select * from vlt.rush_1230 r 
where r.load_date = (select max(load_date) from vlt.rush_1230 )
)select t.code, current_date as load_date
, (coalesce (r.open/t.match_price , t.close))::numeric(10,3) as open
, (coalesce (r.low/t.match_price , t.close))::numeric(10,3) as low
, (coalesce (r.high/t.match_price , t.close))::numeric(10,3) as high
, (coalesce (r.close/t.match_price , t.close))::numeric(10,3) as close
, t.match_price
, t.weight_ratio
from cal.index_component_snapshot t
left outer join temp r 
on t.code = r.code 
where t.load_date = (select max(load_date) from  cal.index_component_snapshot )
union 
select code, load_date, open, low, high, close, match_price, weight_ratio
from  cal.index_component_snapshot
where load_date <> (select min(load_date) from  cal.index_component_snapshot );

drop table if exists temp_index;
create temp table temp_index as 
select c.category as category
	, load_date
	, count(*) as codes_count
	, row_number() over (partition by category order by load_date) - 1 as rnum
	, (sum( open *weight_ratio))::numeric(8,3) as open
	, (sum( low *weight_ratio))::numeric(8,3) as low
	, (sum( high *weight_ratio))::numeric(8,3) as high
	, (sum( close *weight_ratio))::numeric(8,3) as close
from temp_records  r
 inner join mtd.code_category c
 on r.code = c.code 
group by category, load_date order by load_date;

drop table if exists temp_ha;
create temp table temp_ha as 
with recursive seed as (
	select rnum, category, load_date,  open as s_open, close as s_close, high as s_high, low as s_low
		, ((open + close)/2)::numeric(16,3) as h_open
		, ((open + close + high + low)/4)::numeric(16,3) as h_close
		, (greatest(high, (open + close)/2, (open + close + high + low)/4 ))::numeric(16,3) as h_high
		, (least(low, (open + close)/2, (open + close + high + low)/4 ))::numeric(16,3) as h_low
	from temp_index where rnum = 0
), cte as (
	select rnum, category, load_date
		, s_open, s_close, s_high, s_low
		, h_open, h_close, h_high, h_low
	from seed s
	union all
	select s.rnum+1, s.category, t.load_date
		, t.open as s_open, t.close as s_close, t.high as s_high, t.low as s_low
		, ((s.h_open + s.h_close)/2)::numeric(16,3) as h_open
		, ((t.open + t.close + t.high + t.low)/4)::numeric(16,3) as h_open
		, ( greatest( t.high, (s.h_open + s.h_close)/2, (t.open + t.close + t.high + t.low)/4))::numeric(16,3) as h_high
		, ( least ( t.low, (s.h_open + s.h_close)/2, (t.open + t.close + t.high + t.low)/4))::numeric(16,3) as h_low
	from cte s
	inner join temp_index t
	on s.rnum+1 = t.rnum
	and s.category = t.category
)  select * from cte;

insert into rtc.index_1230 
with temp_ema25 as (
 select category, sum(close * weight) as ema25 
	from temp_index cross join mtd.weight_maps
 where rnum + orders = 39 and categories = ''ema40''
 group by category
), temp_ema10 as (
 select category, sum(close * weight) as ema10 
	from temp_index cross join mtd.weight_maps
 where rnum + orders = 39 and categories = ''ema15''
 group by category
), combine as ( 
 select h.category, h.load_date
	, h0.s_close as s_close_p, h0.h_close as h_close_p
	, h.s_open, h.s_close, h.s_high, h.s_low
	, h.h_open, h.h_close, h.h_high, h.h_low
	, e2.ema25, e1.ema10 from temp_ha h
	inner join temp_ema25 e2
		on h.category = e2.category
	inner join temp_ema10 e1
		on h.category = e1.category	
	inner join temp_ha h0
		on h.category = h0.category
	where h.rnum = 39 and h0.rnum = 38
), output as ( 
	select * from combine union
	select ''ASX300'' as category, max(load_date) as load_date
		, sum(s_close_p), sum(h_close_p)
		, sum(s_open), sum(s_close), sum(s_high), sum(s_low)
		, sum(h_open), sum(h_close), sum(h_high), sum(h_low)
		, sum(ema25), sum(ema10)
	from combine
) select category, load_date
, (s_open/s_close_p)::numeric(10,3) as s_open
, (s_close/s_close_p)::numeric(10,3) as s_close
, (s_high/s_close_p)::numeric(10,3) as s_high
, (s_low/s_close_p)::numeric(10,3) as s_low
, (h_open/h_close_p)::numeric(10,3) as h_open
, (h_close/h_close_p)::numeric(10,3) as h_close
, (h_high/h_close_p)::numeric(10,3) as h_high
, (h_low/h_close_p)::numeric(10,3) as h_low
, (ema25/s_close_p)::numeric(10,3) as ema25
, (ema10/s_close_p)::numeric(10,3) as ema10
from output
ON CONFLICT (category, load_date) do nothing;

END;
';


--
-- Name: rush_1345_ha(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.rush_1345_ha(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists rtc;
create temp table rtc as 
select * from vlt.rush_1345 
where load_date = c_date;

drop table if exists temp ;
create temp table temp as 
select *
	, row_number() over (partition by code order by load_date desc) as rnum
	from cal.heikin_ashi 
	where load_date < c_date;

drop table if exists output;
create temp table output as 
select r.code, r.load_date, r.open as s_open, r.close as s_close
, r.low as s_low, r.high as s_high
, case when t.open is null and t.close is null then (r.open + r.close)/2 
	else (t.open + t.close)/2
end as h_open
, (r.open + r.high + r.low + r.close)/4 as h_close
from rtc r
left outer join temp t
on r.code = t.code 
where rnum = 1;

insert into rtc.ha_1345 select code, load_date, h_open::numeric(10,4)
	, greatest( s_high, h_open, h_close)::numeric(10,4) as h_high
	, least( s_low, h_open, h_close)::numeric(10,4) as h_low
	, h_close::numeric(10,4)
	, current_timestamp as sys_load_time
from output;

END;
';


--
-- Name: rush_1345_index(); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.rush_1345_index() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists temp_records;
create temp table temp_records as 
with temp as (
select * from vlt.rush_1345 r 
where r.load_date = (select max(load_date) from vlt.rush_1345 )
)select t.code, current_date as load_date
, (coalesce (r.open/t.match_price , t.close))::numeric(10,3) as open
, (coalesce (r.low/t.match_price , t.close))::numeric(10,3) as low
, (coalesce (r.high/t.match_price , t.close))::numeric(10,3) as high
, (coalesce (r.close/t.match_price , t.close))::numeric(10,3) as close
, t.match_price
, t.weight_ratio
from cal.index_component_snapshot t
left outer join temp r 
on t.code = r.code 
where t.load_date = (select max(load_date) from  cal.index_component_snapshot )
union 
select code, load_date, open, low, high, close, match_price, weight_ratio
from  cal.index_component_snapshot
where load_date <> (select min(load_date) from  cal.index_component_snapshot );

drop table if exists temp_index;
create temp table temp_index as 
select c.category as category
	, load_date
	, count(*) as codes_count
	, row_number() over (partition by category order by load_date) - 1 as rnum
	, (sum( open *weight_ratio))::numeric(8,3) as open
	, (sum( low *weight_ratio))::numeric(8,3) as low
	, (sum( high *weight_ratio))::numeric(8,3) as high
	, (sum( close *weight_ratio))::numeric(8,3) as close
from temp_records  r
 inner join mtd.code_category c
 on r.code = c.code 
group by category, load_date order by load_date;

drop table if exists temp_ha;
create temp table temp_ha as 
with recursive seed as (
	select rnum, category, load_date,  open as s_open, close as s_close, high as s_high, low as s_low
		, ((open + close)/2)::numeric(16,3) as h_open
		, ((open + close + high + low)/4)::numeric(16,3) as h_close
		, (greatest(high, (open + close)/2, (open + close + high + low)/4 ))::numeric(16,3) as h_high
		, (least(low, (open + close)/2, (open + close + high + low)/4 ))::numeric(16,3) as h_low
	from temp_index where rnum = 0
), cte as (
	select rnum, category, load_date
		, s_open, s_close, s_high, s_low
		, h_open, h_close, h_high, h_low
	from seed s
	union all
	select s.rnum+1, s.category, t.load_date
		, t.open as s_open, t.close as s_close, t.high as s_high, t.low as s_low
		, ((s.h_open + s.h_close)/2)::numeric(16,3) as h_open
		, ((t.open + t.close + t.high + t.low)/4)::numeric(16,3) as h_open
		, ( greatest( t.high, (s.h_open + s.h_close)/2, (t.open + t.close + t.high + t.low)/4))::numeric(16,3) as h_high
		, ( least ( t.low, (s.h_open + s.h_close)/2, (t.open + t.close + t.high + t.low)/4))::numeric(16,3) as h_low
	from cte s
	inner join temp_index t
	on s.rnum+1 = t.rnum
	and s.category = t.category
)  select * from cte;

insert into rtc.index_1345
with temp_ema25 as (
 select category, sum(close * weight) as ema25 
	from temp_index cross join mtd.weight_maps
 where rnum + orders = 39 and categories = ''ema40''
 group by category
), temp_ema10 as (
 select category, sum(close * weight) as ema10 
	from temp_index cross join mtd.weight_maps
 where rnum + orders = 39 and categories = ''ema15''
 group by category
), combine as ( 
 select h.category, h.load_date
	, h0.s_close as s_close_p, h0.h_close as h_close_p
	, h.s_open, h.s_close, h.s_high, h.s_low
	, h.h_open, h.h_close, h.h_high, h.h_low
	, e2.ema25, e1.ema10 from temp_ha h
	inner join temp_ema25 e2
		on h.category = e2.category
	inner join temp_ema10 e1
		on h.category = e1.category	
	inner join temp_ha h0
		on h.category = h0.category
	where h.rnum = 39 and h0.rnum = 38
), output as ( 
	select * from combine union
	select ''ASX300'' as category, max(load_date) as load_date
		, sum(s_close_p), sum(h_close_p)
		, sum(s_open), sum(s_close), sum(s_high), sum(s_low)
		, sum(h_open), sum(h_close), sum(h_high), sum(h_low)
		, sum(ema25), sum(ema10)
	from combine
) select category, load_date
, (s_open/s_close_p)::numeric(10,3) as s_open
, (s_close/s_close_p)::numeric(10,3) as s_close
, (s_high/s_close_p)::numeric(10,3) as s_high
, (s_low/s_close_p)::numeric(10,3) as s_low
, (h_open/h_close_p)::numeric(10,3) as h_open
, (h_close/h_close_p)::numeric(10,3) as h_close
, (h_high/h_close_p)::numeric(10,3) as h_high
, (h_low/h_close_p)::numeric(10,3) as h_low
, (ema25/s_close_p)::numeric(10,3) as ema25
, (ema10/s_close_p)::numeric(10,3) as ema10
from output
ON CONFLICT (category, load_date) do nothing;

END;
';


--
-- Name: rush_1500_ha(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.rush_1500_ha(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists rtc;
create temp table rtc as 
select * from vlt.rush_1500 
where load_date = c_date;

drop table if exists temp ;
create temp table temp as 
select *
	, row_number() over (partition by code order by load_date desc) as rnum
	from cal.heikin_ashi 
	where load_date < c_date;

drop table if exists output;
create temp table output as 
select r.code, r.load_date, r.open as s_open, r.close as s_close
, r.low as s_low, r.high as s_high
, case when t.open is null and t.close is null then (r.open + r.close)/2 
	else (t.open + t.close)/2
end as h_open
, (r.open + r.high + r.low + r.close)/4 as h_close
from rtc r
left outer join temp t
on r.code = t.code 
where rnum = 1;

insert into rtc.ha_1500 select code, load_date, h_open::numeric(10,4)
	, greatest( s_high, h_open, h_close)::numeric(10,4) as h_high
	, least( s_low, h_open, h_close)::numeric(10,4) as h_low
	, h_close::numeric(10,4)
	, current_timestamp as sys_load_time
from output;

END;
';


--
-- Name: rush_1500_index(); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.rush_1500_index() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists temp_records;
create temp table temp_records as 
with temp as (
select * from vlt.rush_1500 r 
where r.load_date = (select max(load_date) from vlt.rush_1500 )
)select t.code, current_date as load_date
, (coalesce (r.open/t.match_price , t.close))::numeric(10,3) as open
, (coalesce (r.low/t.match_price , t.close))::numeric(10,3) as low
, (coalesce (r.high/t.match_price , t.close))::numeric(10,3) as high
, (coalesce (r.close/t.match_price , t.close))::numeric(10,3) as close
, t.match_price
, t.weight_ratio
from cal.index_component_snapshot t
left outer join temp r 
on t.code = r.code 
where t.load_date = (select max(load_date) from  cal.index_component_snapshot )
union 
select code, load_date, open, low, high, close, match_price, weight_ratio
from  cal.index_component_snapshot
where load_date <> (select min(load_date) from  cal.index_component_snapshot );

drop table if exists temp_index;
create temp table temp_index as 
select c.category as category
	, load_date
	, count(*) as codes_count
	, row_number() over (partition by category order by load_date) - 1 as rnum
	, (sum( open *weight_ratio))::numeric(8,3) as open
	, (sum( low *weight_ratio))::numeric(8,3) as low
	, (sum( high *weight_ratio))::numeric(8,3) as high
	, (sum( close *weight_ratio))::numeric(8,3) as close
from temp_records  r
 inner join mtd.code_category c
 on r.code = c.code 
group by category, load_date order by load_date;

drop table if exists temp_ha;
create temp table temp_ha as 
with recursive seed as (
	select rnum, category, load_date,  open as s_open, close as s_close, high as s_high, low as s_low
		, ((open + close)/2)::numeric(16,3) as h_open
		, ((open + close + high + low)/4)::numeric(16,3) as h_close
		, (greatest(high, (open + close)/2, (open + close + high + low)/4 ))::numeric(16,3) as h_high
		, (least(low, (open + close)/2, (open + close + high + low)/4 ))::numeric(16,3) as h_low
	from temp_index where rnum = 0
), cte as (
	select rnum, category, load_date
		, s_open, s_close, s_high, s_low
		, h_open, h_close, h_high, h_low
	from seed s
	union all
	select s.rnum+1, s.category, t.load_date
		, t.open as s_open, t.close as s_close, t.high as s_high, t.low as s_low
		, ((s.h_open + s.h_close)/2)::numeric(16,3) as h_open
		, ((t.open + t.close + t.high + t.low)/4)::numeric(16,3) as h_open
		, ( greatest( t.high, (s.h_open + s.h_close)/2, (t.open + t.close + t.high + t.low)/4))::numeric(16,3) as h_high
		, ( least ( t.low, (s.h_open + s.h_close)/2, (t.open + t.close + t.high + t.low)/4))::numeric(16,3) as h_low
	from cte s
	inner join temp_index t
	on s.rnum+1 = t.rnum
	and s.category = t.category
)  select * from cte;

insert into rtc.index_1500
with temp_ema25 as (
 select category, sum(close * weight) as ema25 
	from temp_index cross join mtd.weight_maps
 where rnum + orders = 39 and categories = ''ema40''
 group by category
), temp_ema10 as (
 select category, sum(close * weight) as ema10 
	from temp_index cross join mtd.weight_maps
 where rnum + orders = 39 and categories = ''ema15''
 group by category
), combine as ( 
 select h.category, h.load_date
	, h0.s_close as s_close_p, h0.h_close as h_close_p
	, h.s_open, h.s_close, h.s_high, h.s_low
	, h.h_open, h.h_close, h.h_high, h.h_low
	, e2.ema25, e1.ema10 from temp_ha h
	inner join temp_ema25 e2
		on h.category = e2.category
	inner join temp_ema10 e1
		on h.category = e1.category	
	inner join temp_ha h0
		on h.category = h0.category
	where h.rnum = 39 and h0.rnum = 38
), output as ( 
	select * from combine union
	select ''ASX300'' as category, max(load_date) as load_date
		, sum(s_close_p), sum(h_close_p)
		, sum(s_open), sum(s_close), sum(s_high), sum(s_low)
		, sum(h_open), sum(h_close), sum(h_high), sum(h_low)
		, sum(ema25), sum(ema10)
	from combine
) select category, load_date
, (s_open/s_close_p)::numeric(10,3) as s_open
, (s_close/s_close_p)::numeric(10,3) as s_close
, (s_high/s_close_p)::numeric(10,3) as s_high
, (s_low/s_close_p)::numeric(10,3) as s_low
, (h_open/h_close_p)::numeric(10,3) as h_open
, (h_close/h_close_p)::numeric(10,3) as h_close
, (h_high/h_close_p)::numeric(10,3) as h_high
, (h_low/h_close_p)::numeric(10,3) as h_low
, (ema25/s_close_p)::numeric(10,3) as ema25
, (ema10/s_close_p)::numeric(10,3) as ema10
from output
ON CONFLICT (category, load_date) do nothing;

END;
';


--
-- Name: subpipe_actionable_list(); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.subpipe_actionable_list() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN
insert into  cal.actionable_list
 WITH idx AS (
         SELECT quotes.code,
            quotes.load_date,
            quotes.close,
            quotes.volume,
            row_number() OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS rnum
           FROM vlt.quotes
	 		where quotes.load_date > current_date - interval ''4 month''
        ), calculation AS (
         SELECT idx.code,
            idx.load_date,
            idx.close,
            idx.volume,
            min(idx.volume) OVER (PARTITION BY idx.code ORDER BY idx.rnum RANGE BETWEEN 13 PRECEDING AND CURRENT ROW) AS min_volume,
            min(idx.close) OVER (PARTITION BY idx.code ORDER BY idx.rnum RANGE BETWEEN 13 PRECEDING AND CURRENT ROW) AS min_close,
            row_number() OVER (PARTITION BY idx.code ORDER BY idx.load_date DESC) AS rorder
           FROM idx
        ), output AS (
         SELECT calculation.code,
            calculation.load_date,
            calculation.close,
            calculation.volume,
            calculation.min_volume,
            calculation.min_close,
            calculation.rorder,
            row_number() OVER (PARTITION BY calculation.load_date ORDER BY (calculation.min_volume::numeric * calculation.min_close) DESC) AS turnover_rank,
                CASE
                    WHEN calculation.min_volume > 2000000 AND calculation.min_close > 0.5 OR calculation.min_volume > 1000000 AND (calculation.min_volume::numeric * calculation.min_close) > 4000000::numeric THEN 1
                    WHEN calculation.min_volume > 1000000 AND calculation.min_close > 0.25 OR calculation.min_volume > 500000 AND (calculation.min_volume::numeric * calculation.min_close) > 1500000::numeric THEN 2
                    WHEN calculation.min_volume > 500000 AND calculation.min_close > 0.125 OR calculation.min_volume > 250000 AND (calculation.min_volume::numeric * calculation.min_close) > 500000::numeric THEN 3
                    ELSE 4
                END AS popularity
           FROM calculation
        )
 SELECT output.code,
    output.load_date,
        CASE
            WHEN output.turnover_rank <= 100 THEN 1
            WHEN output.turnover_rank <= 200 THEN 2
            WHEN output.turnover_rank <= 300 THEN 3
            ELSE 4
        END AS turnover,
    output.popularity
   FROM output
  where load_date = current_date
ON CONFLICT (code, load_date) do nothing;

END;
';


--
-- Name: subpipe_actionable_list(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.subpipe_actionable_list(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN
insert into  cal.actionable_list

 WITH idx AS (
         SELECT quotes.code,
            quotes.load_date,
            quotes.close,
            quotes.volume,
            row_number() OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS rnum
           FROM vlt.quotes
	 		where quotes.load_date > c_date - interval ''4 month''
	 			and quotes.load_date <= c_date 
        ), calculation AS (
         SELECT idx.code,
            idx.load_date,
            idx.close,
            idx.volume,
            min(idx.volume) OVER (PARTITION BY idx.code ORDER BY idx.rnum RANGE BETWEEN 13 PRECEDING AND CURRENT ROW) AS min_volume,
            min(idx.close) OVER (PARTITION BY idx.code ORDER BY idx.rnum RANGE BETWEEN 13 PRECEDING AND CURRENT ROW) AS min_close,
            row_number() OVER (PARTITION BY idx.code ORDER BY idx.load_date DESC) AS rorder
           FROM idx
        ), output AS (
         SELECT calculation.code,
            calculation.load_date,
            calculation.close,
            calculation.volume,
            calculation.min_volume,
            calculation.min_close,
            calculation.rorder,
            row_number() OVER (PARTITION BY calculation.load_date ORDER BY (calculation.min_volume::numeric * calculation.min_close) DESC) AS turnover_rank,
                CASE
                    WHEN calculation.min_volume > 2000000 AND calculation.min_close > 0.2 OR calculation.min_volume > 1000000 AND (calculation.min_volume::numeric * calculation.min_close) > 4000000::numeric THEN 1
                    WHEN calculation.min_volume > 1000000 AND calculation.min_close > 0.1 OR calculation.min_volume > 500000 AND (calculation.min_volume::numeric * calculation.min_close) > 1500000::numeric THEN 2
                    WHEN calculation.min_volume > 500000 AND calculation.min_close > 0.05 OR calculation.min_volume > 250000 AND (calculation.min_volume::numeric * calculation.min_close) > 500000::numeric THEN 3
                    ELSE 4
                END AS popularity
           FROM calculation
        )
 SELECT output.code,
    output.load_date,
        CASE
            WHEN output.turnover_rank <= 100 THEN 1
            WHEN output.turnover_rank <= 200 THEN 2
            WHEN output.turnover_rank <= 500 THEN 3
            ELSE 4
        END AS turnover,
    output.popularity
   FROM output
  where load_date = c_date
ON CONFLICT (code, load_date) do nothing;

END;
';


--
-- Name: subpipe_ema(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.subpipe_ema(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists temp_daily_ema15;
create temp table temp_daily_ema15 as 
with quote as (
select q.* 
	, row_number() over(partition by code order by load_date desc) as idx
	from vlt.quotes q where load_date <= c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 15-w.orders as new_order,  15-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema15''	
), temp as ( 
select code, c_date::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema, q.close as price
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =15
)select code, load_date, price, ema
from output ;



drop table if exists temp_daily_ema40;
create temp table temp_daily_ema40 as 
with quote as (
select q.* 
	, row_number() over(partition by code order by load_date desc) as idx
	from vlt.quotes q where load_date <= c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 40-w.orders as new_order,  40-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema40''	
), temp as ( 
select code, c_date::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema, q.close as price
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =40
)select code, load_date, price, ema
from output ;

insert into cal.ema
select coalesce (e1.code, e2.code) as code
, coalesce (e1.load_date, e2.load_date) as load_date
, coalesce (e1.price, e2.price) as price
, e1.ema as ema15 ,e2.ema as ema40
from temp_daily_ema15 e1 
inner join temp_daily_ema40 e2
on e1.code = e2.code and e1.load_date = e2.load_date
ON CONFLICT (code, load_date) do nothing;

/*
drop table if exists temp_ema40;
create temp table temp_ema40 as 
with quote as (
select q.* 
	, row_number() over(partition by code order by load_date desc) as idx
	from vlt.quotes q
), comb as (
select w.weight, 40-w.orders as new_order,  40-w.orders + q.idx as team , q.*
	from quote q cross join mtd.weight_maps w where w.categories = ''ema40'' and q.idx <= 50
), temp as ( 
select code, max(load_date) as load_date
  	, case when count(*) =40 then true else false end as is_completed 
  	, sum(weight * close)::numeric(8,4) as ema
 	from comb where team > 40
 	group by code, team 
), output as (
select t.code, t.load_date, t.is_completed, t.ema, q.close as price
 	, row_number() over (partition by t.code order by t.load_date) as rnum
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
)select code, load_date, is_completed, price, ema
from output where rnum >= 40;

drop table if exists temp_ema15;
create temp table temp_ema15 as 
with quote as (
select q.* 
	, row_number() over(partition by code order by load_date desc) as idx
	from vlt.quotes q
), comb as (
select w.weight, 15-w.orders as new_order,  15-w.orders + q.idx as team , q.*
	from quote q cross join mtd.weight_maps w where w.categories = ''ema15'' and q.idx <= 50
), temp as ( 
select code, max(load_date) as load_date
  	, case when count(*) =15 then true else false end as is_completed 
  	, sum(weight * close)::numeric(8,4) as ema
 	from comb where team > 15
 	group by code, team 
), output as (
select t.code, t.load_date, t.is_completed, t.ema, q.close as price
 	, row_number() over (partition by t.code order by t.load_date) as rnum
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
)select code, load_date, is_completed, price, ema
from output where rnum >= 15;

insert into mnp.ema
select coalesce (e1.code, e2.code) as code
, coalesce (e1.load_date, e2.load_date) as load_date
, coalesce (e1.price, e2.price) as price
, e1.ema as ema15 ,e2.ema as ema40
from temp_ema15 e1 
inner join temp_ema40 e2
on e1.code = e2.code and e1.load_date = e2.load_date
ON CONFLICT (code, load_date) do nothing;

insert into mnp.ema_trend  
with temp as (
select *
, lag(ema15 , 1) over (partition by code order by load_date) as last_ema15
, lag(ema40 , 1) over (partition by code order by load_date) as last_ema40
from mnp.ema 
), utrend as (
select *
, row_number() over (partition by code order by load_date desc) as rnum	
	from temp
where ema15> ema40
and last_ema15 <= last_ema40
), dtrend as (
select * 
, row_number() over (partition by code order by load_date desc) as rnum	
	from temp
where ema15 < ema40
and last_ema15 >= last_ema40
), output as(
	select u.code, c.load_date, i.rnum, 
	u.load_date as up_date, d.load_date as down_date 
	from utrend u
	inner join dtrend d
	on u.code = d.code
	and u.rnum =1 and d.rnum = 1
	inner join vlt.v_idx i
	on u.load_date = i.load_date
	cross join vlt.v_idx c
	where c.rnum = 1
)	select code, load_date
, case when up_date > down_date then rnum else 0 end as trend_period 
from output
ON CONFLICT (code, load_date) do nothing;


drop table if exists temp_match_point;
create temp table temp_match_point as 
with quote as (
select q.* 
	, row_number() over(partition by code order by load_date desc) as idx
	from view_quote q 
), comb as (
select w.weight, 40-w.orders as new_order,  40-w.orders + q.idx as team , q.*
	from quote q cross join weight_maps w 
	where w.categories = ''ema40'' and orders <>0 and q.idx <= 60
), temp as ( 
select code, max(load_date) as load_date, team
  	, case when count(*) =39 then true else false end as is_completed 
  	, ((sum(weight * close))/(0.930446739))::numeric(8,4) as match_point
 	from comb where team > 39 
 	group by code, team 
), output as (
select code, load_date, is_completed, match_point
	,row_number() over (partition by code order by load_date) rnum
	from temp
)select code, load_date, is_completed, match_point from output where rnum >= 39;

drop table if exists temp_area;
create temp table temp_area as 
with quote as (
select  e.code, e.load_date
	, row_number() over (partition by code order by load_date desc) as idx
	, case when ema = 0 then 1 else e.price/e.ema end as distance
	from temp_ema40 e 
), comb as (
select w.weight, 15-w.orders as new_order,  15-w.orders + q.idx as team , q.*
	from quote q cross join weight_maps w where w.categories = ''ema15'' 
), temp as ( select code, max(load_date) as load_date, team
  	, case when count(*) =15 then true else false end as is_completed 
  	, sum(weight * distance)::numeric(8,4) as area
 	from comb where team > 15 
 	group by code, team 
), output as (
	select code, load_date, area, is_completed
	, row_number() over( partition by code order by load_date) as rnum
	from temp
)	select * from output where rnum > 14;
*/


END;
';


--
-- Name: subpipe_ema_on_ha(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.subpipe_ema_on_ha(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

insert into cal.ema_on_ha_ranking 			   
with temp as (
	select code, load_date, open, high, low, close
	, lead(open, 1, null) over (partition by code order by load_date) as next_open
	, lead(close, 1, null) over (partition by code order by load_date) as next_close
	from cal.heikin_ashi
	where load_date <= c_date 
), update_list as (
	select code from temp	
	group by code 
	having max(load_date) = c_date 
), update_temp as (
	select t.* from temp t
	inner join update_list l
	on t.code = l.code
), cal_date as (
	select code, max(load_date) as cal_date 
	from update_temp 
	where close >= open and next_close < next_open 
	and next_close is not null and next_open is not null
	group by code 
), semester_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date - INTERVAL ''168'' DAY
	and load_date <= cal_date 
	and cal_date > c_date - INTERVAL ''28'' DAY
), quarter_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date - INTERVAL ''84'' DAY
	and load_date <= cal_date 
	and cal_date > c_date - INTERVAL ''28'' DAY
), s_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from semester_total group by code
), q_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from quarter_total group by code
), semester_list as (
	select c.code from s_count c
	inner join cal.trading_days m 
	on c.latest_date = m.load_date
	where c.cnt > m.semester_trading_days*0.95
), quarter_list as (
	select c.code from q_count c
	inner join cal.trading_days m
	on c.latest_date = m.load_date
	where c.cnt > m.quaterly_trading_days*0.95
), semester_subset as (
	select t.* from semester_total t
	inner join semester_list l
	on t.code = l.code 
), quarter_subset as (
	select t.* from quarter_total t
	inner join quarter_list l
	on t.code = l.code 
), semester_comb as (
	select t.* from semester_subset s
	inner join cal.ema_trend t
	on s.load_date = t.load_date
	and s.code = t.code
), quarter_comb as (
	select t.* from quarter_subset s
	inner join cal.ema_trend t
	on s.load_date = t.load_date
	and s.code = t.code
), semester_ratio as (
select code, count(*) as total
	, sum (case when prc_e10_direction = 1 then 1 else 0 end )  as prc_e10
	, sum (case when prc_e25_direction = 1 then 1 else 0 end )  as prc_e25
	, sum (case when e10_e25_direction = 1 then 1 else 0 end )  as e10_e25
from semester_comb
group by code
), quarter_ratio as (
select code, count(*) as total
	, sum (case when prc_e10_direction = 1 then 1 else 0 end )  as prc_e10
	, sum (case when prc_e25_direction = 1 then 1 else 0 end )  as prc_e25
	, sum (case when e10_e25_direction = 1 then 1 else 0 end )  as e10_e25
from quarter_comb
group by code
), output as (
select c.code, c.cal_date as load_date, ''long_end''::varchar as usage_direction
	, (s.e10_e25* 1.0 /s.total)::decimal(5,4) as semester_ratio
	, (q.e10_e25* 1.0 /q.total)::decimal(5,4) as quarter_ratio
from cal_date c	
	left outer join semester_ratio s on c.code = s.code
	left outer join quarter_ratio q on c.code = q.code
)
 select * from output
 where semester_ratio is not null 
 or quarter_ratio is not null
ON CONFLICT (code, load_date) do nothing;

insert into cal.ema_on_ha_ranking 			   
with temp as (
	select code, load_date, open, high, low, close
	, lead(open, 1, null) over (partition by code order by load_date) as next_open
	, lead(close, 1, null) over (partition by code order by load_date) as next_close
	from cal.heikin_ashi
	where load_date <= c_date 
), update_list as (
	select code from temp	
	group by code 
	having max(load_date) = c_date 
), update_temp as (
	select t.* from temp t
	inner join update_list l
	on t.code = l.code
), cal_date as (
	select code, max(load_date) as cal_date 
	from update_temp 
	where close < open and next_close >= next_open 
	and next_close is not null and next_open is not null
	group by code 
), semester_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date - INTERVAL ''168'' DAY
	and load_date <= cal_date 
	and cal_date > c_date - INTERVAL ''28'' DAY
), quarter_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date - INTERVAL ''84'' DAY
	and load_date <= cal_date 
	and cal_date > c_date - INTERVAL ''28'' DAY
), s_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from semester_total group by code
), q_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from quarter_total group by code
), semester_list as (
	select c.code from s_count c
	inner join cal.trading_days m 
	on c.latest_date = m.load_date
	where c.cnt > m.semester_trading_days*0.95
), quarter_list as (
	select c.code from q_count c
	inner join cal.trading_days m
	on c.latest_date = m.load_date
	where c.cnt > m.quaterly_trading_days*0.95
), semester_subset as (
	select t.* from semester_total t
	inner join semester_list l
	on t.code = l.code 
), quarter_subset as (
	select t.* from quarter_total t
	inner join quarter_list l
	on t.code = l.code 
), semester_comb as (
	select t.* from semester_subset s
	inner join cal.ema_trend t
	on s.load_date = t.load_date
	and s.code = t.code
), quarter_comb as (
	select t.* from quarter_subset s
	inner join cal.ema_trend t
	on s.load_date = t.load_date
	and s.code = t.code
), semester_ratio as (
select code, count(*) as total
	, sum (case when prc_e10_direction = 1 then 1 else 0 end )  as prc_e10
	, sum (case when prc_e25_direction = 1 then 1 else 0 end )  as prc_e25
	, sum (case when e10_e25_direction = 1 then 1 else 0 end )  as e10_e25
from semester_comb
group by code
), quarter_ratio as (
select code, count(*) as total
	, sum (case when prc_e10_direction = 1 then 1 else 0 end )  as prc_e10
	, sum (case when prc_e25_direction = 1 then 1 else 0 end )  as prc_e25
	, sum (case when e10_e25_direction = 1 then 1 else 0 end )  as e10_e25
from quarter_comb
group by code
), output as (
select c.code, c.cal_date as load_date, ''short_end''::varchar as usage_direction
	, (s.e10_e25* 1.0 /s.total)::decimal(5,4) as semester_ratio
	, (q.e10_e25* 1.0 /q.total)::decimal(5,4) as quarter_ratio
from cal_date c	
	left outer join semester_ratio s on c.code = s.code
	left outer join quarter_ratio q on c.code = q.code
)
 select * from output
 where semester_ratio is not null 
 or quarter_ratio is not null
ON CONFLICT (code, load_date) do nothing;

END;
';


--
-- Name: subpipe_ema_on_sar(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.subpipe_ema_on_sar(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists update_temp;
create temp table update_temp as 
with temp as (
	select code, load_date, ud_trend
	, lead(ud_trend, 1, null) over (partition by code order by load_date) as next_trend
	from cal.sar
	where load_date <= c_date
), update_list as (
	select code from temp	
	group by code 
	having max(load_date) =  c_date
), update_temp as (
	select t.* from temp t
	inner join update_list l
	on t.code = l.code
) select * from update_temp;
drop table if exists cal_date;
create temp table cal_date as 
	select code, max(load_date) as cal_date 
	from update_temp 
	where ud_trend = ''up'' and next_trend = ''down''
	and ud_trend is not null and next_trend is not null
	group by code ;
create index idx_temp on cal_date(code);


insert into cal.ema_on_sar_ranking 	
with semester_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date   - INTERVAL ''168'' DAY
	and load_date <= cal_date 
	and cal_date >  c_date - INTERVAL ''28'' DAY
), quarter_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date   - INTERVAL ''84'' DAY
	and load_date <= cal_date 
	and cal_date > c_date - INTERVAL ''28'' DAY
), s_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from semester_total group by code
), q_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from quarter_total group by code
), semester_list as (
	select c.code from s_count c
	inner join cal.trading_days m 
	on c.latest_date = m.load_date
	where c.cnt > m.semester_trading_days*0.95
), quarter_list as (
	select c.code, c.cnt, m.quaterly_trading_days from q_count c
	inner join cal.trading_days m
	on c.latest_date = m.load_date
	where c.cnt > m.quaterly_trading_days*0.95
), semester_subset as (
	select t.* from semester_total t
	inner join semester_list l
	on t.code = l.code 
), quarter_subset as (
	select t.* from quarter_total t
	inner join quarter_list l
	on t.code = l.code 
), semester_comb as (
	select t.* from semester_subset s
	inner join cal.ema_trend t
	on s.load_date = t.load_date
	and s.code = t.code
), quarter_comb as (
	select t.* from quarter_subset s
	inner join cal.ema_trend t
	on s.load_date = t.load_date
	and s.code = t.code
), semester_ratio as (
select code, count(*) as total
	, sum (case when prc_e10_direction = 1 then 1 else 0 end )  as prc_e10
	, sum (case when prc_e25_direction = 1 then 1 else 0 end )  as prc_e25
	, sum (case when e10_e25_direction = 1 then 1 else 0 end )  as e10_e25
from semester_comb
group by code
), quarter_ratio as (
select code, count(*) as total
	, sum (case when prc_e10_direction = 1 then 1 else 0 end )  as prc_e10
	, sum (case when prc_e25_direction = 1 then 1 else 0 end )  as prc_e25
	, sum (case when e10_e25_direction = 1 then 1 else 0 end )  as e10_e25
from quarter_comb
group by code
), output as (
select c.code, c.cal_date as load_date, ''long_end''::varchar as usage_direction
	, (s.e10_e25* 1.0 /s.total)::decimal(5,4) as semester_ratio
	, (q.e10_e25* 1.0 /q.total)::decimal(5,4) as quarter_ratio
from cal_date c	
	left outer join semester_ratio s on c.code = s.code
	left outer join quarter_ratio q on c.code = q.code
)
 select * from output
 where semester_ratio is not null 
 or quarter_ratio is not null
ON CONFLICT (code, load_date) do nothing;
 
 
drop table if exists cal_date;
create temp table cal_date as 
	select code, max(load_date) as cal_date 
	from update_temp 
	where ud_trend = ''down'' and next_trend = ''up''
	and ud_trend is not null and next_trend is not null
	group by code ;
create index idx_temp on cal_date(code); 
 
insert into cal.ema_on_sar_ranking 	
with semester_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date   - INTERVAL ''168'' DAY
	and load_date <= cal_date 
	and cal_date >  c_date - INTERVAL ''28'' DAY
), quarter_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date   - INTERVAL ''84'' DAY
	and load_date <= cal_date 
	and cal_date > c_date - INTERVAL ''28'' DAY
), s_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from semester_total group by code
), q_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from quarter_total group by code
), semester_list as (
	select c.code from s_count c
	inner join cal.trading_days m 
	on c.latest_date = m.load_date
	where c.cnt > m.semester_trading_days*0.95
), quarter_list as (
	select c.code, c.cnt, m.quaterly_trading_days from q_count c
	inner join cal.trading_days m
	on c.latest_date = m.load_date
	where c.cnt > m.quaterly_trading_days*0.95
), semester_subset as (
	select t.* from semester_total t
	inner join semester_list l
	on t.code = l.code 
), quarter_subset as (
	select t.* from quarter_total t
	inner join quarter_list l
	on t.code = l.code 
), semester_comb as (
	select t.* from semester_subset s
	inner join cal.ema_trend t
	on s.load_date = t.load_date
	and s.code = t.code
), quarter_comb as (
	select t.* from quarter_subset s
	inner join cal.ema_trend t
	on s.load_date = t.load_date
	and s.code = t.code
), semester_ratio as (
select code, count(*) as total
	, sum (case when prc_e10_direction = 1 then 1 else 0 end )  as prc_e10
	, sum (case when prc_e25_direction = 1 then 1 else 0 end )  as prc_e25
	, sum (case when e10_e25_direction = 1 then 1 else 0 end )  as e10_e25
from semester_comb
group by code
), quarter_ratio as (
select code, count(*) as total
	, sum (case when prc_e10_direction = 1 then 1 else 0 end )  as prc_e10
	, sum (case when prc_e25_direction = 1 then 1 else 0 end )  as prc_e25
	, sum (case when e10_e25_direction = 1 then 1 else 0 end )  as e10_e25
from quarter_comb
group by code
), output as (
select c.code, c.cal_date as load_date, ''short_end''::varchar as usage_direction
	, (s.e10_e25* 1.0 /s.total)::decimal(5,4) as semester_ratio
	, (q.e10_e25* 1.0 /q.total)::decimal(5,4) as quarter_ratio
from cal_date c	
	left outer join semester_ratio s on c.code = s.code
	left outer join quarter_ratio q on c.code = q.code
)
 select * from output
 where semester_ratio is not null 
 or quarter_ratio is not null
ON CONFLICT (code, load_date) do nothing;
  
END;
';


--
-- Name: subpipe_ema_trend(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.subpipe_ema_trend(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN
insert into cal.ema_trend
with current_set as (
	select * from cal.ema where load_date = c_date
), last_set as (
	select * 
		, row_number() over (partition by code order by load_date desc) as rnum
	from cal.ema_trend where load_date < c_date
), output as ( select c.code, c.load_date
, case	when price >= ema15 and prc_e10_direction = 1 then prc_e10_trend + 1
		when price >= ema15 and prc_e10_direction = -1 then 1 	
		when price >= ema15 and prc_e10_direction is null then 1
		when price < ema15 and prc_e10_direction = 1 then 1
		when price < ema15 and prc_e10_direction = -1 then prc_e10_trend + 1
		when price < ema15 and prc_e10_direction is null then -1
	else null end as prc_e10_trend
, case	when price >= ema15 then 1 
		when price < ema15 then -1 
	else null end as prc_e10_direction
, case	when price >= ema40 and prc_e25_direction = 1 then prc_e25_trend + 1
		when price >= ema40 and prc_e25_direction = -1 then 1 	
		when price >= ema40 and prc_e25_direction is null then 1
		when price < ema40 and prc_e25_direction = 1 then 1
		when price < ema40 and prc_e25_direction = -1 then prc_e25_trend + 1
		when price < ema40 and prc_e25_direction is null then -1
	else null end as prc_e25_trend
, case	when price >= ema40 then 1 
		when price < ema40 then -1 
	else null end as prc_e25_direction	
, case	when ema15 >= ema40 and e10_e25_direction = 1 then e10_e25_trend + 1
		when ema15 >= ema40 and e10_e25_direction = -1 then 1 	
		when ema15 >= ema40 and e10_e25_direction is null then 1
		when ema15 < ema40 and e10_e25_direction = 1 then 1
		when ema15 < ema40 and e10_e25_direction = -1 then e10_e25_trend + 1
		when ema15 < ema40 and e10_e25_direction is null then -1
	else null end as e10_e25_trend
, case	when ema15 >= ema40 then 1 
		when ema15 < ema40 then -1 
	else null end as e10_e25_direction		
from current_set c
left join last_set l
on c.code = l.code
and l.rnum =1 )
select code, load_date
	, prc_e10_trend, prc_e10_direction
	, prc_e25_trend, prc_e25_direction
	, e10_e25_trend, e10_e25_direction
from output
ON CONFLICT (code, load_date) do nothing
;


END;
';


--
-- Name: subpipe_ha_ema(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.subpipe_ha_ema(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists temp_daily_ema15;
create temp table temp_daily_ema15 as 
with quote as (
select q.* 
	, row_number() over(partition by code order by load_date desc) as idx
	from cal.heikin_ashi q where load_date <= c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 15-w.orders as new_order,  15-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema15''	
), temp as ( 
select code, c_date::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema, q.close as price
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =15
)select code, load_date, price, ema
from output ;

drop table if exists temp_daily_ema40;
create temp table temp_daily_ema40 as 
with quote as (
select q.* 
	, row_number() over(partition by code order by load_date desc) as idx
	from cal.heikin_ashi q where load_date <= c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 40-w.orders as new_order,  40-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema40''	
), temp as ( 
select code, c_date::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema, q.close as price
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =40
)select code, load_date, price, ema
from output ;

insert into cal.ha_ema
select coalesce (e1.code, e2.code) as code
, coalesce (e1.load_date, e2.load_date) as load_date
, coalesce (e1.price, e2.price) as price
, e1.ema as ema15 ,e2.ema as ema40
from temp_daily_ema15 e1 
inner join temp_daily_ema40 e2
on e1.code = e2.code and e1.load_date = e2.load_date
ON CONFLICT (code, load_date) do nothing;

END;
';


--
-- Name: subpipe_ha_macd(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.subpipe_ha_macd(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

insert into cal.macd
with quote as (
select q.code, (q.ema15- q.ema40) as close, load_date
	, row_number() over(partition by code order by load_date desc) as idx
	from cal.ha_ema q where load_date <= c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 15-w.orders as new_order,  15-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema15''	
), temp as ( 
select code, c_date::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema as dea, q.close as diff
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =15
)select code, load_date, diff, dea, ''ha''
from output 
ON CONFLICT (code, load_date) do nothing;

END;
';


--
-- Name: subpipe_ha_ranking(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.subpipe_ha_ranking(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

insert into cal.ha_ranking 
with temp as (
	select code, load_date, open, high, low, close
	, lead(open, 1, null) over (partition by code order by load_date) as next_open
	, lead(close, 1, null) over (partition by code order by load_date) as next_close
	from cal.heikin_ashi
	where load_date <= c_date 
), update_list as (
	select code from temp	
	group by code 
	having max(load_date) = c_date 
), update_temp as (
	select t.* from temp t
	inner join update_list l
	on t.code = l.code
), cal_date as (
	select code, max(load_date) as cal_date 
	from update_temp 
	where close >= open and next_close < next_open 
	and next_close is not null and next_open is not null
	group by code 
), semester_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date - INTERVAL ''168'' DAY
	and load_date <= cal_date 
	and cal_date > c_date - INTERVAL ''28'' DAY
), quarter_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date - INTERVAL ''84'' DAY
	and load_date <= cal_date 
	and cal_date > c_date - INTERVAL ''28'' DAY
), s_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from semester_total group by code
), q_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from quarter_total group by code
), semester_list as (
	select c.code from s_count c
	inner join cal.trading_days m 
	on c.latest_date = m.load_date
	where c.cnt > m.semester_trading_days*0.95
), quarter_list as (
	select c.code from q_count c
	inner join cal.trading_days m
	on c.latest_date = m.load_date
	where c.cnt > m.quaterly_trading_days*0.95
), semester_subset as (
	select t.* from semester_total t
	inner join semester_list l
	on t.code = l.code 
), quarter_subset as (
	select t.* from quarter_total t
	inner join quarter_list l
	on t.code = l.code 
), semeseter_ratio as (
	select code
	, sum(case when close >= open then 1 else 0 end ) as green
	, count(*) as total
	from semester_subset
	group by code
), quarter_ratio as (
	select code
	, sum(case when close >= open then 1 else 0 end ) as green
	, count(*) as total
	from quarter_subset
	group by code
), output as (
select c.code, c.cal_date as load_date, ''long_end''::varchar as usage_direction
	, (s.green* 1.0 /s.total)::decimal(5,4) as semester_ratio
	, (q.green* 1.0 /q.total)::decimal(5,4) as quarter_ratio
from cal_date c	
	left outer join semeseter_ratio s on c.code = s.code
	left outer join quarter_ratio q on c.code = q.code
) select * from output
where semester_ratio is not null 
or quarter_ratio is not null
ON CONFLICT (code, load_date) do nothing;

insert into cal.ha_ranking 
with temp as (
	select code, load_date, open, high, low, close
	, lead(open, 1, null) over (partition by code order by load_date) as next_open
	, lead(close, 1, null) over (partition by code order by load_date) as next_close
	from cal.heikin_ashi
	where load_date <= c_date 
), update_list as (
	select code from temp	
	group by code 
	having max(load_date) = c_date 
), update_temp as (
	select t.* from temp t
	inner join update_list l
	on t.code = l.code
), cal_date as (
	select code, max(load_date) as cal_date 
	from update_temp 
	where close < open and next_close >= next_open 
	and next_close is not null and next_open is not null
	group by code 
), semester_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date - INTERVAL ''168'' DAY
	and load_date <= cal_date 
	and cal_date > c_date - INTERVAL ''28'' DAY
), quarter_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date - INTERVAL ''84'' DAY
	and load_date <= cal_date 
	and cal_date > c_date - INTERVAL ''28'' DAY
), s_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from semester_total group by code
), q_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from quarter_total group by code
), semester_list as (
	select c.code from s_count c
	inner join cal.trading_days m 
	on c.latest_date = m.load_date
	where c.cnt > m.semester_trading_days*0.95
), quarter_list as (
	select c.code from q_count c
	inner join cal.trading_days m
	on c.latest_date = m.load_date
	where c.cnt > m.quaterly_trading_days*0.95
), semester_subset as (
	select t.* from semester_total t
	inner join semester_list l
	on t.code = l.code 
), quarter_subset as (
	select t.* from quarter_total t
	inner join quarter_list l
	on t.code = l.code 
), semeseter_ratio as (
	select code
	, sum(case when close >= open then 1 else 0 end ) as green
	, count(*) as total
	from semester_subset
	group by code
), quarter_ratio as (
	select code
	, sum(case when close >= open then 1 else 0 end ) as green
	, count(*) as total
	from quarter_subset
	group by code
), output as (
select c.code, c.cal_date as load_date, ''short_end''::varchar as usage_direction
	, (s.green* 1.0 /s.total)::decimal(5,4) as semester_ratio
	, (q.green* 1.0 /q.total)::decimal(5,4) as quarter_ratio
from cal_date c	
	left outer join semeseter_ratio s on c.code = s.code
	left outer join quarter_ratio q on c.code = q.code
) select * from output
where semester_ratio is not null 
or quarter_ratio is not null
ON CONFLICT (code, load_date) do nothing;

END;
';


--
-- Name: subpipe_heikin_ashi(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.subpipe_heikin_ashi(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

insert into cal.heikin_ashi

with current_set as (
	select * 
from vlt.quotes where load_date = c_date
), previous_temp as (
	select *
	, row_number() over (partition by code order by load_date desc) as rnum
from cal.heikin_ashi where load_date < c_date
), previous_set as (
	select * 
	from previous_temp
	where rnum = 1
), comb as (
 select c.code, c.load_date
	, coalesce (c.open, c.close ) as s_open
	, coalesce (c.high, c.close ) as s_high
	, coalesce (c.low, c.close ) as s_low
	, coalesce (c.close, c.close ) as s_close
	, p.open as p_open
	, p.close as p_close
	from current_set c
	left outer join previous_set p
	on c.code = p.code
), output as (
	select code, load_date
	, s_open, s_high, s_low, s_close
	, case when p_open is null and p_close is null then (s_open + s_close)/2
		else (p_open + p_close)/2 end as h_open
	, (s_open + s_high + s_low + s_close)/4 as h_close
	from comb
) select code, load_date
	, h_open
	,greatest( s_high, h_open, h_close) as h_high
	,least( s_low, h_open, h_close) as h_low
	, h_close
	from output


ON CONFLICT (code, load_date) do nothing;

END;
';


--
-- Name: subpipe_index_direction(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.subpipe_index_direction(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists  temp_records;
create temp table temp_records as 
with date_idx as (
select load_date
	, row_number() over (order by load_date desc) as rnum
from vlt.quotes where load_date <= c_date
	group by 1 
), temp as (
select q.*
from vlt.quotes q
inner join date_idx i 
	on q.load_date = i.load_date	
where i.rnum <=40
), aggregation as (
select code
	from temp group by code
	having count(*) >= 36
) , full_code_list as (
select q.code
	, row_number() over (order by market_cap desc) as rnum
from vlt.quotes q 
	inner join aggregation a
	on q.code = a.code
	where q.load_date = c_date
), subset as (
select t.*
	from temp t
	inner join full_code_list l
	on t.code = l.code 	where rnum <=300
), sub_code_list as (
select code from subset group by 1
), full_idx as (
select code, load_date from 
	sub_code_list c
	cross join date_idx i
	where i.rnum <=40
), temp_records as ( 
select i.code, i.load_date
	, s.open, s.low, s.high, s.close, s.volume
	, s.turnover, s.market_cap, s.typ3, s.typ4
from full_idx i
left outer join subset s
on i.code= s.code and i.load_date = s.load_date
), missing_records as (
select * from temp_records 
where open is null and close is null	
), comb as (
select m.code, m.load_date
	, t.load_date as next_date
	, t.open, t.low, t.high, t.close, t.volume
	, t.turnover, t.market_cap, t.typ3, t.typ4
	from missing_records m
 inner join temp_records t
	on m.code = t.code 
	where  m.load_date < t.load_date
	and t.open is not null and t.close is not null
), fix_in_dup as ( 
select *
	, row_number() over (partition by code, load_date order by next_date) as rnum
from comb 
), fix_records as ( 
select code, load_date
	, open, low, high, close, volume
	, turnover, market_cap, typ3, typ4
from fix_in_dup where rnum =1
), complete_records as (
select 	s.code, s.load_date
	, s.open, s.low, s.high, s.close, s.volume
	, s.turnover, s.market_cap, s.typ3, s.typ4
from subset s union
select code, load_date
	, open, low, high, close, volume
	, turnover, market_cap, typ3, typ4
	from fix_records
), total_cap as ( 
select sum(market_cap) as total_cap 
	from subset where load_date = c_date
), weight as (
select  code , close as match_price
	, (market_cap/total_cap*100)::numeric(5,4) as weight_ratio
	from subset s cross join total_cap t
where load_date = c_date
) select o.code, o.load_date
	, (o.open/ w.match_price)::numeric(10,3) as open
	, (o.low / w.match_price)::numeric(10,3) as low
	, (o.high/ w.match_price)::numeric(10,3) as high
	, (o.close/ w.match_price)::numeric(10,3) as close
	, (o.turnover/ w.match_price)::numeric(100,3) as turnover
	, o.volume, o.market_cap
	, (o.typ3/ w.match_price)::numeric(10,3) as typ3
	, (o.typ4/ w.match_price)::numeric(10,3) as typ4
	, w.match_price
	, w.weight_ratio 
from complete_records o inner join weight w
on o.code = w.code;

drop table if exists cal.index_component_snapshot;
create table cal.index_component_snapshot
as select * from temp_records;

insert into cal.index_component_history
select * from cal.index_component_snapshot;

insert into  cal.index_component
select code, load_date from temp_records 
where load_date = c_date
ON CONFLICT (code, load_date) do nothing;
 

drop table if exists temp_index;
create temp table temp_index as 
select c.category as category
	, load_date
	, count(*) as codes_count
	, row_number() over (partition by category order by load_date) - 1 as rnum
	, (sum( open *weight_ratio))::numeric(8,3) as open
	, (sum( low *weight_ratio))::numeric(8,3) as low
	, (sum( high *weight_ratio))::numeric(8,3) as high
	, (sum( close *weight_ratio))::numeric(8,3) as close
from temp_records  r
 inner join mtd.code_category c
 on r.code = c.code 
group by category, load_date order by load_date;

drop table if exists temp_ha;
create temp table temp_ha as 
with recursive seed as (
	select rnum, category, load_date,  open as s_open, close as s_close, high as s_high, low as s_low
		, ((open + close)/2)::numeric(16,3) as h_open
		, ((open + close + high + low)/4)::numeric(16,3) as h_close
		, (greatest(high, (open + close)/2, (open + close + high + low)/4 ))::numeric(16,3) as h_high
		, (least(low, (open + close)/2, (open + close + high + low)/4 ))::numeric(16,3) as h_low
	from temp_index where rnum = 0
), cte as (
	select rnum, category, load_date
		, s_open, s_close, s_high, s_low
		, h_open, h_close, h_high, h_low
	from seed s
	union all
	select s.rnum+1, s.category, t.load_date
		, t.open as s_open, t.close as s_close, t.high as s_high, t.low as s_low
		, ((s.h_open + s.h_close)/2)::numeric(16,3) as h_open
		, ((t.open + t.close + t.high + t.low)/4)::numeric(16,3) as h_open
		, ( greatest( t.high, (s.h_open + s.h_close)/2, (t.open + t.close + t.high + t.low)/4))::numeric(16,3) as h_high
		, ( least ( t.low, (s.h_open + s.h_close)/2, (t.open + t.close + t.high + t.low)/4))::numeric(16,3) as h_low
	from cte s
	inner join temp_index t
	on s.rnum+1 = t.rnum
	and s.category = t.category
)  select * from cte;

insert into cal.index_direction
with temp_ema25 as (
 select category, sum(close * weight) as ema25 
	from temp_index cross join mtd.weight_maps
 where rnum + orders = 39 and categories = ''ema40''
 group by category
), temp_ema10 as (
 select category, sum(close * weight) as ema10 
	from temp_index cross join mtd.weight_maps
 where rnum + orders = 39 and categories = ''ema15''
 group by category
), combine as ( 
 select h.category, h.load_date
	, h0.s_close as s_close_p, h0.h_close as h_close_p
	, h.s_open, h.s_close, h.s_high, h.s_low
	, h.h_open, h.h_close, h.h_high, h.h_low
	, e2.ema25, e1.ema10 from temp_ha h
	inner join temp_ema25 e2
		on h.category = e2.category
	inner join temp_ema10 e1
		on h.category = e1.category	
	inner join temp_ha h0
		on h.category = h0.category
	where h.rnum = 39 and h0.rnum = 38
), output as ( 
	select * from combine union
	select ''ASX300'' as category, max(load_date) as load_date
		, sum(s_close_p), sum(h_close_p)
		, sum(s_open), sum(s_close), sum(s_high), sum(s_low)
		, sum(h_open), sum(h_close), sum(h_high), sum(h_low)
		, sum(ema25), sum(ema10)
	from combine
) select category, load_date
, (s_open/s_close_p)::numeric(10,3) as s_open
, (s_close/s_close_p)::numeric(10,3) as s_close
, (s_high/s_close_p)::numeric(10,3) as s_high
, (s_low/s_close_p)::numeric(10,3) as s_low
, (h_open/h_close_p)::numeric(10,3) as h_open
, (h_close/h_close_p)::numeric(10,3) as h_close
, (h_high/h_close_p)::numeric(10,3) as h_high
, (h_low/h_close_p)::numeric(10,3) as h_low
, (ema25/s_close_p)::numeric(10,3) as ema25
, (ema10/s_close_p)::numeric(10,3) as ema10
from output

ON CONFLICT (category, load_date) do nothing;

drop table if exists  temp_records;
drop table if exists temp_ha;

END;
';


--
-- Name: subpipe_moving_range(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.subpipe_moving_range(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN


insert into cal.simple_moving_range
with temp as (
select code, load_date, open, low, high, close 
	, coalesce (pclose, lag(close, 1) over (partition by code order by load_date)) as pclose
	, row_number () over (partition by code order by load_date desc) as rnum
from vlt.quotes  where load_date  <= c_date
), subset as (
select code, load_date, rnum
	,(greatest( abs(1-high/pclose) , abs(1-low/pclose), abs(1-high/close), abs(1-low/close))*100)::numeric(9,3) as max_range
	,(abs(1 - close/ pclose)*100 )::numeric(9,3) as daily_diff
	from temp where rnum <= 60
), idx as (
select code, max(load_date) as load_date
	from subset group by code having max(load_date) = c_date
), range_filter as (
select code, load_date, max_range
	, row_number() over (partition by code order by max_range) as rnum
from subset
), diff_filter as (
select code, load_date, daily_diff
	, row_number() over (partition by code order by daily_diff) as rnum
from subset
), range_agg as (
select code, count(*) as rcount
	, avg(max_range) as avg_range
	, stddev(max_range) as std_range
	from range_filter where rnum > 6 and rnum < 55
	group by code 
), diff_agg as (
select code, count(*) as dcount
	, avg(daily_diff) as avg_diff
	, stddev(daily_diff) as std_diff
	from diff_filter where rnum > 6 and rnum < 55
	group by code 
), output as (
	select i.code, i.load_date
	, r.avg_range, r.std_range, r.rcount AS rcount
	, d.avg_diff, d.std_diff, d.dcount as dcount
	from idx i
	inner join range_agg r 
	on i.code = r.code
	inner join diff_agg d
	on i.code = d.code
) select code, load_date
	, avg_range, std_range
	, avg_diff, std_diff
from output 
where rcount = 48 and dcount = 48
ON CONFLICT (code, load_date) do nothing;

END;
';


--
-- Name: subpipe_rpt(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.subpipe_rpt(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

insert into rpt.short_list_snapshot
select category, code, current_date
, total_ranking, category_ranking
from cal. v_full_short_current;

insert into rpt.long_list_snapshot
select category, code, current_date
, total_ranking, category_ranking
from cal. v_full_long_current;

insert into rpt.index_summary_report  
 WITH cset AS (
         SELECT category,
            load_date,
            s_open,
            s_close,
            s_high,
            s_low,
            h_open,
            h_close,
            h_high,
            h_low,
            ema25,
            ema10
           FROM cal.index_direction
          WHERE load_date = (( SELECT max(load_date) AS max
                   FROM cal.index_direction))
        ), pset AS (
         SELECT index_direction.category,
            index_direction.load_date,
            index_direction.s_open,
            index_direction.s_close,
            index_direction.s_high,
            index_direction.s_low,
            index_direction.h_open,
            index_direction.h_close,
            index_direction.h_high,
            index_direction.h_low,
            index_direction.ema25,
            index_direction.ema10
           FROM cal.index_direction
          WHERE index_direction.load_date = (( SELECT max(index_direction_1.load_date) AS max
                   FROM cal.index_direction index_direction_1
                  WHERE index_direction_1.load_date < (( SELECT max(index_1230.load_date) AS max
                           FROM rtc.index_1230))))
        ), features AS (
         SELECT c.category,
            c.load_date,
                CASE
                    WHEN p.h_close >= p.h_open THEN ''+''::text
                    ELSE ''-''::text
                END AS last_ha,
                CASE
                    WHEN c.h_close >= c.h_open THEN ''+''::text
                    ELSE ''-''::text
                END AS current_ha,
                CASE
                    WHEN c.s_close >= p.s_close THEN ''+''::text
                    ELSE ''-''::text
                END AS daily_perf,
                CASE
                    WHEN p.ema10 >= p.ema25 THEN ''+''::text
                    ELSE ''-''::text
                END AS last_ema,
                CASE
                    WHEN c.ema10 >= c.ema25 THEN ''+''::text
                    ELSE ''-''::text
                END AS current_ema
           FROM cset c
             LEFT JOIN pset p ON c.category::text = p.category::text
        )
 SELECT features.category,
    features.load_date,
    features.daily_perf,
    concat(features.last_ha, features.current_ha) AS ha,
    concat(features.last_ema, features.current_ema) AS ema
   FROM features
  WHERE features.category::text <> ''Unclassified''::text
  ORDER BY features.category
  on conflict do nothing
  ;

drop table if exists category;
create temp table category as 
select category
, case when s_open <= s_close then ''-'' else ''+'' end as c_direction
, case when h_open <= h_close then ''+'' else ''-'' end as c_status
, case when ema25 <= ema10 then ''+'' else ''-'' end as c_option
from cal.index_direction
where load_date = current_date
and category <> ''Unclassified'';

drop table if exists long_list ;
create temp table long_list as 
with l0 as (
select * from rpt.long_list_snapshot l0
where load_date = (select max(load_date) from rpt.long_list_snapshot )
) , l1 as (
select * from rpt.long_list_snapshot
where load_date = (select max(load_date) from rpt.long_list_snapshot 
				   where load_date < (select max(load_date) from rpt.long_list_snapshot ))
)
select coalesce (l0.category, l1.category) as category
, coalesce (l0.code, l1.code) as code
, l0.total_ranking as total_ranking
, l1.total_ranking as last_ranking
, l0.category_ranking as category_ranking
, l1.category_ranking as last_category
, l0.load_date as load_date
from l0 full join l1 on l0.code = l1.code;

drop table if exists short_list ;
create temp table short_list as 
with s0 as (
select * from rpt.short_list_snapshot s0
where load_date = (select max(load_date) from rpt.short_list_snapshot )
) , s1 as (
select * from rpt.short_list_snapshot
where load_date = (select max(load_date) from rpt.short_list_snapshot 
				   where load_date < (select max(load_date) from rpt.short_list_snapshot ))
)
select coalesce (s0.category, s1.category) as category
, coalesce (s0.code, s1.code) as code
, s0.total_ranking as total_ranking
, s1.total_ranking as last_ranking
, s0.category_ranking as category_ranking
, s1.category_ranking as last_category
, s0.load_date as load_date
from s0 full join s1 on s0.code = s1.code;

drop table if exists ema ;
create temp table ema as 
select * from cal.v_ema_current
where load_date = current_date;
drop table if exists ha ;
create temp table ha as 
select * from cal.v_ha_sequence_current;
--where load_date = current_date;
drop table if exists volume ;
create temp table volume as 
select * from cal.v_volume_current
where load_date = current_date;
drop table if exists short;
create temp table short as 
select code
, concat(t.nearest_break::character varying, ''('', t.nearest_distance, '')/'', 
		 t.previous_break::character varying, ''('', t.previous_distance, '')'') AS short_indicator
from vlt.v_short_current t;

drop table if exists moving ;
create temp table moving as 
select * 
, (m.avg_range + 1.28 * m.std_range)::numeric(6,2)  as daily_range
, (m.avg_diff + 1.28 * m.std_diff)::numeric(6,2)  as daily_diff
from cal.simple_moving_range m
where load_date = current_date;

drop table if exists sar;
create temp table sar as 
select code
, case when ud_trend = ''up'' then ''+'' when ud_trend = ''down'' then ''-'' else '''' end sar
,  n_sar 
from cal.v_sar_current;

drop table if exists temp_long;
create temp table temp_long as 
select  concat(l.category , ''('', c.c_option, '', '', c.c_status , '','', c_direction, '')'') 
	as "category (EMA,HA,DIRC)"
, l.code
, e.price
, concat(l.total_ranking, ''('', category_ranking, '')/'',
		 l.last_ranking , ''('', last_category, '')''
		) as ranking
, e.indicator as option 
, h.status as status
, h.sequence as trend
, concat(v.range, ''('', v.ratio , '')'') as volume
, concat(m.daily_diff, ''('', m.daily_range, '')'' ) as daily_range 
, s.short_indicator
, a.last_anc
, concat(r.sar, ''('', 
 case when r.sar = ''-'' then ((1-r.n_sar/e.price)*100)::numeric(5,3) 
	   when r.sar = ''+''	then ((r.n_sar/e.price-1)*100)::numeric(5,3) 
		 end , ''%)'' ) as sar
, l.total_ranking as rnum
, l.category_ranking as cnum
, l.load_date

from long_list l
left join category c
on l.category = c.category
left join ema e
on l.code = e.code
left join ha h
on l.code = h.code
left join volume v
on l.code = v.code
left join short s
on l.code = s.code
left join moving m
on l.code = m.code
left join vlt.v_announcements a
on l.code = a.code
left join sar r
on l.code = r.code
order by l.total_ranking;

drop table if exists temp_short;
create temp table temp_short as 
select  concat(l.category , ''('', c.c_option, '', '', c.c_status , '','', c_direction, '')'') 
	as "category (EMA,HA,DIRC)"
, l.code
, e.price
, concat(l.total_ranking, ''('', category_ranking, '')/'',
		 l.last_ranking , ''('', last_category, '')''
		) as ranking
, e.indicator as option 
, h.status as status
, h.sequence as trend
, concat(v.range, ''('', v.ratio , '')'') as volume
, concat(m.daily_diff, ''('', m.daily_range, '')'' ) as daily_range 
, s.short_indicator
, a.last_anc
, concat(r.sar, ''('', 
 case when r.sar = ''-'' then ((r.n_sar/e.price-1)*100)::numeric(5,3) 
	   when r.sar = ''+''	then ((r.n_sar/e.price-1)*100)::numeric(5,3) 
		 end , ''%)'' ) as sar
, l.total_ranking as rnum
, l.category_ranking as cnum
, l.load_date
from short_list l
left join category c
on l.category = c.category
left join ema e
on l.code = e.code
left join ha h
on l.code = h.code
left join volume v
on l.code = v.code
left join short s
on l.code = s.code
left join moving m
on l.code = m.code
left join vlt.v_announcements a
on l.code = a.code
left join sar r
on l.code = r.code
order by l.total_ranking;

-- create table rpt.short_summary_report as  
insert into rpt.short_summary_report
select "category (EMA,HA,DIRC)", code, price, ranking
, option, status, trend, volume, daily_range
, short_indicator, sar, last_anc,  rnum, cnum, load_date
from temp_short 
-- where rnum <= 60
-- and cnum <=5
;

-- create table rpt.long_summary_report as  
insert into rpt.long_summary_report 
select "category (EMA,HA,DIRC)", code, price, ranking
, option, status, trend, volume, daily_range
, short_indicator, sar, last_anc, rnum, cnum, load_date
from temp_long 
-- where rnum <= 60
-- and cnum <=5
;

END;
';


--
-- Name: subpipe_sar(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.subpipe_sar(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

insert into cal.sar
with temp as (
	select *
	, row_number() over (partition by code order by load_date desc) as rnum
	from cal.sar
), last_record as (
	select * from temp where rnum = 1	
), subset as (
select q.code, q.load_date, q.open, q.low, q.high, q.close
	, t.extreme, t.ud_trend, t.af, t.sar, t.n_sar
from vlt.quotes q left join last_record t on q.code = t.code
where q.load_date = c_date
), initial as (
select code, load_date, open, low, high, close
	, high as extreme, ''up'' as ud_trend
	, 0.05 as af, low as sar
	, (low + 0.05 * (high- low)) as n_sar
from subset where ud_trend is null and n_sar is null
), up_and_keep_org as (
select code, load_date, open, low, high, close
	, greatest(extreme, high) as extreme
	, ''up'' as ud_trend
	, case when extreme < high then least(0.5, af + 0.05) else af end as af
	, n_sar as sar
from subset where ud_trend = ''up'' and n_sar <= low
), up_and_stop_org as (
select code, load_date, open, low, high, close
	, greatest(extreme, high) as extreme
	, ''down'' as ud_trend
	, 0.05 as af
	, greatest(extreme, high) as sar
from subset where ud_trend = ''up'' and n_sar > low
), down_and_keep_org as (
select code, load_date, open, low, high, close
	, least( extreme, low) as extreme
	, ''down'' as ud_trend
	, case when extreme > low then least(0.5, af + 0.05) else af end as af
	, n_sar as sar
from subset where ud_trend = ''down'' and n_sar >= high	
), down_and_stop_org as (
select code, load_date, open, low, high, close
	, least( extreme, low) as extreme
	, ''up'' as ud_trend
	, 0.05 as af
	, least(extreme, high) as sar
from subset where ud_trend = ''down'' and n_sar < high	
), output as (
	select * from initial
	union  select *
		, sar + af * (high - sar) as n_sar
	from up_and_keep_org
	union  select *
		, sar + af * (low - sar) as n_sar
	from up_and_stop_org
	union  select *
		, sar + af * (low - sar) as n_sar
	from down_and_keep_org
	union  select *
		, sar + af * (low - sar) as n_sar
	from down_and_stop_org
) select code , load_date, extreme, ud_trend, af, sar, n_sar
	from output

ON CONFLICT (code, load_date) do nothing;


END;
';


--
-- Name: subpipe_sar_ranking(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.subpipe_sar_ranking(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

insert into cal.sar_ranking 
with temp as (
	select code, load_date, ud_trend
	, lead(ud_trend, 1, null) over (partition by code order by load_date) as next_trend
	from cal.sar
	where load_date <= c_date
), update_list as (
	select code from temp	
	group by code 
	having max(load_date) = c_date   
), update_temp as (
	select t.* from temp t
	inner join update_list l
	on t.code = l.code
), cal_date as (
	select code, max(load_date) as cal_date 
	from update_temp 
	where ud_trend = ''up'' and next_trend = ''down''
	and ud_trend is not null and next_trend is not null
	group by code 
), semester_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date   - INTERVAL ''168'' DAY
	and load_date <= cal_date 
	and cal_date >  c_date - INTERVAL ''28'' DAY
), quarter_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date   - INTERVAL ''84'' DAY
	and load_date <= cal_date 
	and cal_date > c_date - INTERVAL ''28'' DAY
), s_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from semester_total group by code
), q_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from quarter_total group by code
), semester_list as (
	select c.code from s_count c
	inner join cal.trading_days m 
	on c.latest_date = m.load_date
	where c.cnt > m.semester_trading_days*0.95
), quarter_list as (
	select c.code, c.cnt, m.quaterly_trading_days from q_count c
	inner join cal.trading_days m
	on c.latest_date = m.load_date
	where c.cnt > m.quaterly_trading_days*0.95
), semester_subset as (
	select t.* from semester_total t
	inner join semester_list l
	on t.code = l.code 
), quarter_subset as (
	select t.* from quarter_total t
	inner join quarter_list l
	on t.code = l.code 
), semeseter_ratio as (
	select code
	, sum(case when ud_trend = ''up'' then 1 else 0 end ) as green
	, count(*) as total
	from semester_subset
	group by code
), quarter_ratio as (
	select code
	, sum(case when ud_trend = ''up'' then 1 else 0 end ) as green
	, count(*) as total
	from quarter_subset
	group by code
), output as (
select c.code, c.cal_date as load_date, ''long_end''::varchar as usage_direction
	, (s.green* 1.0 /s.total)::decimal(5,4) as semester_ratio
	, (q.green* 1.0 /q.total)::decimal(5,4) as quarter_ratio
from cal_date c	
	left outer join semeseter_ratio s on c.code = s.code
	left outer join quarter_ratio q on c.code = q.code
) select * from output
where semester_ratio is not null 
or quarter_ratio is not null
ON CONFLICT (code, load_date) do nothing;

insert into cal.sar_ranking 
with temp as (
	select code, load_date, ud_trend
	, lead(ud_trend, 1, null) over (partition by code order by load_date) as next_trend
	from cal.sar
	where load_date <= c_date
), update_list as (
	select code from temp	
	group by code 
	having max(load_date) = c_date  
), update_temp as (
	select t.* from temp t
	inner join update_list l
	on t.code = l.code
), cal_date as (
	select code, max(load_date) as cal_date 
	from update_temp 
	where ud_trend = ''down'' and next_trend = ''up''
	and ud_trend is not null and next_trend is not null
	group by code 
), semester_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date - INTERVAL ''168'' DAY
	and load_date <= cal_date 
	and cal_date >  c_date - INTERVAL ''28'' DAY
), quarter_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date - INTERVAL ''84'' DAY
	and load_date <= cal_date 
	and cal_date > c_date - INTERVAL ''28'' DAY
), s_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from semester_total group by code
), q_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from quarter_total group by code
), semester_list as (
	select c.code from s_count c
	inner join cal.trading_days m 
	on c.latest_date = m.load_date
	where c.cnt > m.semester_trading_days*0.95
), quarter_list as (
	select c.code, c.cnt, m.quaterly_trading_days from q_count c
	inner join cal.trading_days m
	on c.latest_date = m.load_date
	where c.cnt > m.quaterly_trading_days*0.95
), semester_subset as (
	select t.* from semester_total t
	inner join semester_list l
	on t.code = l.code 
), quarter_subset as (
	select t.* from quarter_total t
	inner join quarter_list l
	on t.code = l.code 
), semeseter_ratio as (
	select code
	, sum(case when ud_trend = ''up'' then 1 else 0 end ) as green
	, count(*) as total
	from semester_subset
	group by code
), quarter_ratio as (
	select code
	, sum(case when ud_trend = ''up'' then 1 else 0 end ) as green
	, count(*) as total
	from quarter_subset
	group by code
), output as (
select c.code, c.cal_date as load_date, ''short_end''::varchar as usage_direction
	, (s.green* 1.0 /s.total)::decimal(5,4) as semester_ratio
	, (q.green* 1.0 /q.total)::decimal(5,4) as quarter_ratio
from cal_date c	
	left outer join semeseter_ratio s on c.code = s.code
	left outer join quarter_ratio q on c.code = q.code
) select * from output
where semester_ratio is not null 
or quarter_ratio is not null
ON CONFLICT (code, load_date) do nothing;


END;
';


--
-- Name: subpipe_stb_on_ha(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.subpipe_stb_on_ha(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

insert into cal.stb_on_ha_ranking 
with temp as (
	select code, load_date, open, high, low, close
	, lead(open, 1, null) over (partition by code order by load_date) as next_open
	, lead(close, 1, null) over (partition by code order by load_date) as next_close
	from cal.heikin_ashi
	where load_date <= c_date 
), update_list as (
	select code from temp	
	group by code 
	having max(load_date) = c_date  
), update_temp as (
	select t.* from temp t
	inner join update_list l
	on t.code = l.code
), cal_date as (
	select code, max(load_date) as cal_date 
	from update_temp 
	where close >= open and next_close < next_open 
	and next_close is not null and next_open is not null
	group by code 
), semester_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date   - INTERVAL ''168'' DAY
	and load_date <= cal_date 
	and cal_date > c_date - INTERVAL ''28'' DAY
), quarter_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date   - INTERVAL ''84'' DAY
	and load_date <= cal_date 
	and cal_date > c_date - INTERVAL ''28'' DAY
), s_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from semester_total group by code
), q_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from quarter_total group by code
), semester_list as (
	select c.code from s_count c
	inner join cal.trading_days m 
	on c.latest_date = m.load_date
	where c.cnt > m.semester_trading_days*0.95
), quarter_list as (
	select c.code, c.cnt, m.quaterly_trading_days from q_count c
	inner join cal.trading_days m
	on c.latest_date = m.load_date
	where c.cnt > m.quaterly_trading_days*0.95
), semester_subset as (
	select t.* from semester_total t
	inner join semester_list l
	on t.code = l.code 
), quarter_subset as (
	select t.* from quarter_total t
	inner join quarter_list l
	on t.code = l.code 
), semester_comb as (
	select t.code, t.load_date, t.close as price 
	from semester_subset s
	inner join vlt.quotes t
	on s.load_date = t.load_date
	and s.code = t.code
), quarter_comb as (
	select t.code, t.load_date, t.close as price 
	from quarter_subset s
	inner join vlt.quotes t
	on s.load_date = t.load_date
	and s.code = t.code
), semester_order as  (
	select *
	, row_number() over (partition by code order by price, load_date) as rclose
	, row_number() over (partition by code order by load_date) as rdate
	from semester_comb 
), quarter_order as  (
	select *
	, row_number() over (partition by code order by price, load_date) as rclose
	, row_number() over (partition by code order by load_date) as rdate
	from quarter_comb 
), semester_ratio as (
select code, max(load_date) as load_date, count(*) as records
, (sum(abs(rclose - rdate))/ count(*)::numeric(4,0))::numeric(12,3) as ratio
from semester_order group by 1
), quarter_ratio as (
select code, max(load_date) as load_date, count(*) as records
, (sum(abs(rclose - rdate))/ count(*)::numeric(4,0))::numeric(12,3) as ratio
from quarter_order group by 1
), output as (
select c.code, c.cal_date as load_date, ''long_end''::varchar as usage_direction
	, s.ratio as semester_ratio
	, q.ratio as quarter_ratio
from cal_date c	
	left outer join semester_ratio s on c.code = s.code
	left outer join quarter_ratio q on c.code = q.code
)
 select * from output
 where semester_ratio is not null 
 or quarter_ratio is not null
ON CONFLICT (code, load_date) do nothing;


insert into cal.stb_on_ha_ranking 
with temp as (
	select code, load_date, open, high, low, close
	, lead(open, 1, null) over (partition by code order by load_date) as next_open
	, lead(close, 1, null) over (partition by code order by load_date) as next_close
	from cal.heikin_ashi
	where load_date <= c_date 
), update_list as (
	select code from temp	
	group by code 
	having max(load_date) = c_date  
), update_temp as (
	select t.* from temp t
	inner join update_list l
	on t.code = l.code
), cal_date as (
	select code, max(load_date) as cal_date 
	from update_temp 
	where close < open and next_close >= next_open 
	and next_close is not null and next_open is not null
	group by code 
), semester_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date   - INTERVAL ''168'' DAY
	and load_date <= cal_date 
	and cal_date > c_date - INTERVAL ''28'' DAY
), quarter_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date   - INTERVAL ''84'' DAY
	and load_date <= cal_date 
	and cal_date > c_date - INTERVAL ''28'' DAY
), s_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from semester_total group by code
), q_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from quarter_total group by code
), semester_list as (
	select c.code from s_count c
	inner join cal.trading_days m 
	on c.latest_date = m.load_date
	where c.cnt > m.semester_trading_days*0.95
), quarter_list as (
	select c.code, c.cnt, m.quaterly_trading_days from q_count c
	inner join cal.trading_days m
	on c.latest_date = m.load_date
	where c.cnt > m.quaterly_trading_days*0.95
), semester_subset as (
	select t.* from semester_total t
	inner join semester_list l
	on t.code = l.code 
), quarter_subset as (
	select t.* from quarter_total t
	inner join quarter_list l
	on t.code = l.code 
), semester_comb as (
	select t.code, t.load_date, t.close as price 
	from semester_subset s
	inner join vlt.quotes t
	on s.load_date = t.load_date
	and s.code = t.code
), quarter_comb as (
	select t.code, t.load_date, t.close as price 
	from quarter_subset s
	inner join vlt.quotes t
	on s.load_date = t.load_date
	and s.code = t.code
), semester_order as  (
	select *
	, row_number() over (partition by code order by price, load_date) as rclose
	, row_number() over (partition by code order by load_date) as rdate
	from semester_comb 
), quarter_order as  (
	select *
	, row_number() over (partition by code order by price, load_date) as rclose
	, row_number() over (partition by code order by load_date) as rdate
	from quarter_comb 
), semester_ratio as (
select code, max(load_date) as load_date, count(*) as records
, (sum(abs(rclose - rdate))/ count(*)::numeric(4,0))::numeric(12,3) as ratio
from semester_order group by 1
), quarter_ratio as (
select code, max(load_date) as load_date, count(*) as records
, (sum(abs(rclose - rdate))/ count(*)::numeric(4,0))::numeric(12,3) as ratio
from quarter_order group by 1
), output as (
select c.code, c.cal_date as load_date, ''short_end''::varchar as usage_direction
	, s.ratio as semester_ratio
	, q.ratio as quarter_ratio
from cal_date c	
	left outer join semester_ratio s on c.code = s.code
	left outer join quarter_ratio q on c.code = q.code
)
 select * from output
 where semester_ratio is not null 
 or quarter_ratio is not null
ON CONFLICT (code, load_date) do nothing;
END;
';


--
-- Name: subpipe_stb_on_sar(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.subpipe_stb_on_sar(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists update_temp;
create temp table update_temp as 
with temp as (
	select code, load_date, ud_trend
	, lead(ud_trend, 1, null) over (partition by code order by load_date) as next_trend
	from cal.sar
	where load_date <= c_date
), update_list as (
	select code from temp	
	group by code 
	having max(load_date) =  c_date
), update_temp as (
	select t.* from temp t
	inner join update_list l
	on t.code = l.code
) select * from update_temp;
drop table if exists cal_date;
create temp table cal_date as 
	select code, max(load_date) as cal_date 
	from update_temp 
	where ud_trend = ''up'' and next_trend = ''down''
	and ud_trend is not null and next_trend is not null
	group by code ;
create index idx_temp on cal_date(code);

insert into cal.stb_on_sar_ranking 	
with semester_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date   - INTERVAL ''168'' DAY
	and load_date <= cal_date 
	and cal_date >  c_date - INTERVAL ''28'' DAY
), quarter_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date   - INTERVAL ''84'' DAY
	and load_date <= cal_date 
	and cal_date > c_date - INTERVAL ''28'' DAY
), s_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from semester_total group by code
), q_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from quarter_total group by code
), semester_list as (
	select c.code from s_count c
	inner join cal.trading_days m 
	on c.latest_date = m.load_date
	where c.cnt > m.semester_trading_days*0.95
), quarter_list as (
	select c.code, c.cnt, m.quaterly_trading_days from q_count c
	inner join cal.trading_days m
	on c.latest_date = m.load_date
	where c.cnt > m.quaterly_trading_days*0.95
), semester_subset as (
	select t.* from semester_total t
	inner join semester_list l
	on t.code = l.code 
), quarter_subset as (
	select t.* from quarter_total t
	inner join quarter_list l
	on t.code = l.code 
), semester_comb as (
	select t.code, t.load_date, t.close as price 
	from semester_subset s
	inner join vlt.quotes t
	on s.load_date = t.load_date
	and s.code = t.code
), quarter_comb as (
	select t.code, t.load_date, t.close as price 
	from quarter_subset s
	inner join vlt.quotes t
	on s.load_date = t.load_date
	and s.code = t.code
), semester_order as  (
	select *
	, row_number() over (partition by code order by price, load_date) as rclose
	, row_number() over (partition by code order by load_date) as rdate
	from semester_comb 
), quarter_order as  (
	select *
	, row_number() over (partition by code order by price, load_date) as rclose
	, row_number() over (partition by code order by load_date) as rdate
	from quarter_comb 
), semester_ratio as (
select code, max(load_date) as load_date, count(*) as records
, (sum(abs(rclose - rdate))/ count(*)::numeric(4,0))::numeric(12,3) as ratio
from semester_order group by 1
), quarter_ratio as (
select code, max(load_date) as load_date, count(*) as records
, (sum(abs(rclose - rdate))/ count(*)::numeric(4,0))::numeric(12,3) as ratio
from quarter_order group by 1
), output as (
select c.code, c.cal_date as load_date, ''long_end''::varchar as usage_direction
	, s.ratio as semester_ratio
	, q.ratio as quarter_ratio
from cal_date c	
	left outer join semester_ratio s on c.code = s.code
	left outer join quarter_ratio q on c.code = q.code
)
 select * from output
 where semester_ratio is not null 
 or quarter_ratio is not null
ON CONFLICT (code, load_date) do nothing;
 
drop table if exists cal_date;
create temp table cal_date as 
	select code, max(load_date) as cal_date 
	from update_temp 
	where ud_trend = ''down'' and next_trend = ''up''
	and ud_trend is not null and next_trend is not null
	group by code ;
create index idx_temp on cal_date(code); 
 
insert into cal.stb_on_sar_ranking 	
with semester_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date   - INTERVAL ''168'' DAY
	and load_date <= cal_date 
	and cal_date >  c_date - INTERVAL ''28'' DAY
), quarter_total as (
	select t.* from update_temp t
	inner join cal_date c
	on t.code = c.code
	where load_date > cal_date   - INTERVAL ''84'' DAY
	and load_date <= cal_date 
	and cal_date > c_date - INTERVAL ''28'' DAY
), s_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from semester_total group by code
), q_count as (
	select code, max(load_date) as latest_date, count(*) as cnt
	from quarter_total group by code
), semester_list as (
	select c.code from s_count c
	inner join cal.trading_days m 
	on c.latest_date = m.load_date
	where c.cnt > m.semester_trading_days*0.95
), quarter_list as (
	select c.code, c.cnt, m.quaterly_trading_days from q_count c
	inner join cal.trading_days m
	on c.latest_date = m.load_date
	where c.cnt > m.quaterly_trading_days*0.95
), semester_subset as (
	select t.* from semester_total t
	inner join semester_list l
	on t.code = l.code 
), quarter_subset as (
	select t.* from quarter_total t
	inner join quarter_list l
	on t.code = l.code 
), semester_comb as (
	select t.code, t.load_date, t.close as price 
	from semester_subset s
	inner join vlt.quotes t
	on s.load_date = t.load_date
	and s.code = t.code
), quarter_comb as (
	select t.code, t.load_date, t.close as price 
	from quarter_subset s
	inner join vlt.quotes t
	on s.load_date = t.load_date
	and s.code = t.code
), semester_order as  (
	select *
	, row_number() over (partition by code order by price, load_date) as rclose
	, row_number() over (partition by code order by load_date) as rdate
	from semester_comb 
), quarter_order as  (
	select *
	, row_number() over (partition by code order by price, load_date) as rclose
	, row_number() over (partition by code order by load_date) as rdate
	from quarter_comb 
), semester_ratio as (
select code, max(load_date) as load_date, count(*) as records
, (sum(abs(rclose - rdate))/ count(*)::numeric(4,0))::numeric(12,3) as ratio
from semester_order group by 1
), quarter_ratio as (
select code, max(load_date) as load_date, count(*) as records
, (sum(abs(rclose - rdate))/ count(*)::numeric(4,0))::numeric(12,3) as ratio
from quarter_order group by 1
), output as (
select c.code, c.cal_date as load_date, ''short_end''::varchar as usage_direction
	, s.ratio as semester_ratio
	, q.ratio as quarter_ratio
from cal_date c	
	left outer join semester_ratio s on c.code = s.code
	left outer join quarter_ratio q on c.code = q.code
)
 select * from output
 where semester_ratio is not null 
 or quarter_ratio is not null
ON CONFLICT (code, load_date) do nothing;
  
END;
';


--
-- Name: subpipe_trading_days(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.subpipe_trading_days(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

insert into cal.trading_days
with semester_temp as (
	select code, count(*) as cnt, max(load_date) as cal_date
	from vlt.quotes  
	where load_date <= c_date and
		load_date > c_date - INTERVAL ''168'' DAY
	group by 1 order by count(*) desc
), quaterly_temp as (
		select code, count(*) as cnt, max(load_date) as cal_date
	from vlt.quotes  
	where load_date <= c_date::date and
		load_date > c_date::date - INTERVAL ''84'' DAY
	group by 1 order by count(*) desc
), monthly_temp as (
	select code, count(*) as cnt, max(load_date) as cal_date
	from vlt.quotes  
	where load_date <= c_date::date and
		load_date > c_date::date - INTERVAL ''28'' DAY
	group by 1 order by count(*) desc
), semester_sum as ( 
	select max(cal_date) as cal_date
	, max(cnt) as semester_trading_days
	from semester_temp 
), quaterly_sum as (
	select max(cal_date) as cal_date
	, max(cnt) as quaterly_trading_days
	from quaterly_temp 
), monthly_sum as (
	select max(cal_date) as cal_date
	, max(cnt) as monthly_trading_days
	from monthly_temp 
), output as (
	select coalesce( s.cal_date, q.cal_date, m.cal_date) as cal_date
	, semester_trading_days
	, quaterly_trading_days
	, monthly_trading_days
	from semester_sum s 
	cross join quaterly_sum q
	cross join monthly_sum m
) select * from output
ON CONFLICT ( load_date) do nothing;

END;
';


--
-- Name: subpipe_volume_range(date); Type: FUNCTION; Schema: cal; Owner: -
--

CREATE FUNCTION cal.subpipe_volume_range(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

insert into cal.volume_bands 
with temp as (
select code, load_date, volume
	, row_number () over (partition by code order by load_date desc) as rnum
from vlt.quotes  where load_date  <= c_date
), idx as (
select code from temp 
	group by code
	having max(load_date) = c_date
), subset as (
select t.code, t.load_date, t.volume
	from temp t inner join idx i on t.code = i.code 
	where rnum <= 60
), ratio as (
select code, volume
	, row_number () over (partition by code order by volume) as rnum
	from subset
), filter as (
	select code, volume
	from ratio
	where rnum > 6 and rnum <55
), aggregation as (
select code, c_date as load_date
	, avg(volume)::int as avg_volume
	, stddev(volume)::int as std_volume
from filter group by code
), output as (
select q.code, q.load_date, q.volume, v.avg_volume, v.std_volume
, (v.avg_volume + v.std_volume*3) as benchmark
, case when q.volume > (v.avg_volume + v.std_volume*3) then 1 else 0 end as flag
from aggregation v inner join subset q
on v.code = q.code and v.load_date = q.load_date
)select * from output
ON CONFLICT (code, load_date) do nothing;

END;
';


--
-- Name: master_pipeline(); Type: FUNCTION; Schema: mnp; Owner: -
--

CREATE FUNCTION mnp.master_pipeline() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN
PERFORM  mnp.subpipe_calculation();
PERFORM  mnp.subpipe_ema();
PERFORM  mnp.subpipe_sar(current_date);
PERFORM  mnp.subpipe_trend_stability(current_date);
PERFORM  mnp.subpipe_trend_direction();
PERFORM  mnp.subpipe_xpt();
END;
';


--
-- Name: subpipe_calculation(); Type: FUNCTION; Schema: mnp; Owner: -
--

CREATE FUNCTION mnp.subpipe_calculation() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN
insert into  mnp.actionable_list
 WITH idx AS (
         SELECT quotes.code,
            quotes.load_date,
            quotes.close,
            quotes.volume,
            row_number() OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS rnum
           FROM vlt.quotes
	 		where quotes.load_date > current_date - interval ''6 month''
        ), calculation AS (
         SELECT idx.code,
            idx.load_date,
            idx.close,
            idx.volume,
            min(idx.volume) OVER (PARTITION BY idx.code ORDER BY idx.rnum RANGE BETWEEN 13 PRECEDING AND CURRENT ROW) AS min_volume,
            min(idx.close) OVER (PARTITION BY idx.code ORDER BY idx.rnum RANGE BETWEEN 13 PRECEDING AND CURRENT ROW) AS min_close,
            row_number() OVER (PARTITION BY idx.code ORDER BY idx.load_date DESC) AS rorder
           FROM idx
        ), output AS (
         SELECT calculation.code,
            calculation.load_date,
            calculation.close,
            calculation.volume,
            calculation.min_volume,
            calculation.min_close,
            calculation.rorder,
            row_number() OVER (PARTITION BY calculation.load_date ORDER BY (calculation.min_volume::numeric * calculation.min_close) DESC) AS turnover_rank,
                CASE
                    WHEN calculation.min_volume > 2000000 AND calculation.min_close > 0.5 OR calculation.min_volume > 1000000 AND (calculation.min_volume::numeric * calculation.min_close) > 4000000::numeric THEN 1
                    WHEN calculation.min_volume > 1000000 AND calculation.min_close > 0.25 OR calculation.min_volume > 500000 AND (calculation.min_volume::numeric * calculation.min_close) > 1500000::numeric THEN 2
                    WHEN calculation.min_volume > 500000 AND calculation.min_close > 0.125 OR calculation.min_volume > 250000 AND (calculation.min_volume::numeric * calculation.min_close) > 500000::numeric THEN 3
                    ELSE 4
                END AS popularity
           FROM calculation
        )
 SELECT output.code,
    output.load_date,
        CASE
            WHEN output.turnover_rank <= 100 THEN 1
            WHEN output.turnover_rank <= 200 THEN 2
            WHEN output.turnover_rank <= 300 THEN 3
            ELSE 4
        END AS turnover,
    output.popularity
   FROM output
ON CONFLICT (code, load_date) do nothing;

insert into mnp.simple_moving_range 
with temp as (
select *
, lag(close, 1) over (partition by code order by load_date) as last_close
, row_number () over (partition by code order by load_date desc) as rnum
from vlt.quotes
), subset as (
select code, load_date
	,greatest( abs(1-high/pclose) , abs(1-low/pclose), abs(1-high/close), abs(1-high/close))*100 as max_range
	,coalesce (abs(1 - close/ pclose)*100 , (abs(1 - close/ last_close)*100)) as daily_diff
	from temp where rnum < 40
), max_filter as (
select code	, max_range
	, row_number() over (partition by code order by max_range) as rnum
	from subset s
), diff_filter as (
select code	, daily_diff
	, row_number() over (partition by code order by daily_diff) as rnum
	from subset s
), max_agg as (
select code	
	, avg(max_range)::numeric(6,3) as avg_range
	, stddev(max_range)::numeric(6,3) as std_range
	from max_filter	where rnum >5 and rnum < 36
	group by code
), diff_agg as (
select code	
	, avg(daily_diff)::numeric(6,3) as avg_diff
	, stddev(daily_diff)::numeric(6,3) as std_diff
	from diff_filter where rnum >5 and rnum < 36
	group by code
), sub_agg as (
select code, max(load_date) as latest_date
	from subset group by code
), output as (
select s.code, s.latest_date
	, m.avg_range, m.std_range
	, d.avg_diff, d.std_diff
	from sub_agg s
	inner join mnp.actionable_list l
	on s.code = l.code 
	and l.load_date = s.latest_date
	left outer join max_agg m
	on s.code = m.code
	left outer join diff_agg d
	on s.code = d.code
	where l.turnover <> 4 or l.popularity <> 4
) select * from output
ON CONFLICT (code, latest_date) do nothing ;

END;
';


--
-- Name: subpipe_ema(); Type: FUNCTION; Schema: mnp; Owner: -
--

CREATE FUNCTION mnp.subpipe_ema() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists temp_ema40;
create temp table temp_ema40 as 
with quote as (
select q.* 
	, row_number() over(partition by code order by load_date desc) as idx
	from vlt.quotes q
), comb as (
select w.weight, 40-w.orders as new_order,  40-w.orders + q.idx as team , q.*
	from quote q cross join mtd.weight_maps w where w.categories = ''ema40'' and q.idx <= 50
), temp as ( 
select code, max(load_date) as load_date
  	, case when count(*) =40 then true else false end as is_completed 
  	, sum(weight * close)::numeric(8,4) as ema
 	from comb where team > 40
 	group by code, team 
), output as (
select t.code, t.load_date, t.is_completed, t.ema, q.close as price
 	, row_number() over (partition by t.code order by t.load_date) as rnum
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
)select code, load_date, is_completed, price, ema
from output where rnum >= 40;

drop table if exists temp_ema15;
create temp table temp_ema15 as 
with quote as (
select q.* 
	, row_number() over(partition by code order by load_date desc) as idx
	from vlt.quotes q
), comb as (
select w.weight, 15-w.orders as new_order,  15-w.orders + q.idx as team , q.*
	from quote q cross join mtd.weight_maps w where w.categories = ''ema15'' and q.idx <= 50
), temp as ( 
select code, max(load_date) as load_date
  	, case when count(*) =15 then true else false end as is_completed 
  	, sum(weight * close)::numeric(8,4) as ema
 	from comb where team > 15
 	group by code, team 
), output as (
select t.code, t.load_date, t.is_completed, t.ema, q.close as price
 	, row_number() over (partition by t.code order by t.load_date) as rnum
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
)select code, load_date, is_completed, price, ema
from output where rnum >= 15;

insert into mnp.ema
select coalesce (e1.code, e2.code) as code
, coalesce (e1.load_date, e2.load_date) as load_date
, coalesce (e1.price, e2.price) as price
, e1.ema as ema15 ,e2.ema as ema40
from temp_ema15 e1 
inner join temp_ema40 e2
on e1.code = e2.code and e1.load_date = e2.load_date
ON CONFLICT (code, load_date) do nothing;

insert into mnp.ema_trend  
with temp as (
select *
, lag(ema15 , 1) over (partition by code order by load_date) as last_ema15
, lag(ema40 , 1) over (partition by code order by load_date) as last_ema40
from mnp.ema 
), utrend as (
select *
, row_number() over (partition by code order by load_date desc) as rnum	
	from temp
where ema15> ema40
and last_ema15 <= last_ema40
), dtrend as (
select * 
, row_number() over (partition by code order by load_date desc) as rnum	
	from temp
where ema15 < ema40
and last_ema15 >= last_ema40
), output as(
	select u.code, c.load_date, i.rnum, 
	u.load_date as up_date, d.load_date as down_date 
	from utrend u
	inner join dtrend d
	on u.code = d.code
	and u.rnum =1 and d.rnum = 1
	inner join vlt.v_idx i
	on u.load_date = i.load_date
	cross join vlt.v_idx c
	where c.rnum = 1
)	select code, load_date
, case when up_date > down_date then rnum else 0 end as trend_period 
from output
ON CONFLICT (code, load_date) do nothing;
/*

drop table if exists temp_match_point;
create temp table temp_match_point as 
with quote as (
select q.* 
	, row_number() over(partition by code order by load_date desc) as idx
	from view_quote q 
), comb as (
select w.weight, 40-w.orders as new_order,  40-w.orders + q.idx as team , q.*
	from quote q cross join weight_maps w 
	where w.categories = ''ema40'' and orders <>0 and q.idx <= 60
), temp as ( 
select code, max(load_date) as load_date, team
  	, case when count(*) =39 then true else false end as is_completed 
  	, ((sum(weight * close))/(0.930446739))::numeric(8,4) as match_point
 	from comb where team > 39 
 	group by code, team 
), output as (
select code, load_date, is_completed, match_point
	,row_number() over (partition by code order by load_date) rnum
	from temp
)select code, load_date, is_completed, match_point from output where rnum >= 39;

drop table if exists temp_area;
create temp table temp_area as 
with quote as (
select  e.code, e.load_date
	, row_number() over (partition by code order by load_date desc) as idx
	, case when ema = 0 then 1 else e.price/e.ema end as distance
	from temp_ema40 e 
), comb as (
select w.weight, 15-w.orders as new_order,  15-w.orders + q.idx as team , q.*
	from quote q cross join weight_maps w where w.categories = ''ema15'' 
), temp as ( select code, max(load_date) as load_date, team
  	, case when count(*) =15 then true else false end as is_completed 
  	, sum(weight * distance)::numeric(8,4) as area
 	from comb where team > 15 
 	group by code, team 
), output as (
	select code, load_date, area, is_completed
	, row_number() over( partition by code order by load_date) as rnum
	from temp
)	select * from output where rnum > 14;
*/

END;
';


--
-- Name: subpipe_sar(date); Type: FUNCTION; Schema: mnp; Owner: -
--

CREATE FUNCTION mnp.subpipe_sar(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists temp_sar2;
create temp table temp_sar2 as 
with temp as (
	select *
	, row_number() over (partition by code order by load_date desc) as rnum
	from mnp.sar
), subset as (
select q.code, q.load_date, q.open, q.low, q.high, q.close
	, t.extreme2 as extreme, t.ud_trend2 as ud_trend
	, t.af2 as af, t.sar2 as sar, t.n_sar2 as n_sar
from vlt.quotes q 
inner join temp t	on q.code = t.code
where q.load_date = c_date and t.rnum = 1 --and q.code = ''NAB''
), up_and_keep_org as (
select code, load_date, open, low, high, close
	, greatest(extreme, high) as extreme
	, ''up'' as ud_trend
	, case when extreme < high then least(0.2, af + 0.02) else af end as af
	, n_sar as sar
from subset 
where ud_trend = ''up'' and n_sar <= low
), up_and_stop_org as (
select code, load_date, open, low, high, close
	, greatest(extreme, high) as extreme
	, ''down'' as ud_trend
	, 0.02 as af
	, greatest(extreme, high) as sar
from subset 
where ud_trend = ''up'' and n_sar > low
), down_and_keep_org as (
select code, load_date, open, low, high, close
	, least( extreme, low) as extreme
	, ''down'' as ud_trend
	, case when extreme > low then least(0.2, af + 0.02) else af end as af
	, n_sar as sar
from subset 
where ud_trend = ''down'' and n_sar >= high	
), down_and_stop_org as (
select code, load_date, open, low, high, close
	, least( extreme, low) as extreme
	, ''up'' as ud_trend
	, 0.02 as af
	, least(extreme, high) as sar
from subset 
where ud_trend = ''down'' and n_sar < high	
) select *
, sar + af * (high - sar) as n_sar
from up_and_keep_org
union  select *
, sar + af * (low - sar) as n_sar
from up_and_stop_org
union  select *
, sar + af * (low - sar) as n_sar
from down_and_keep_org
union  select *
, sar + af * (low - sar) as n_sar
from down_and_stop_org
;

drop table if exists temp_sar3;
create temp table temp_sar3 as 
with temp as (
	select *
	, row_number() over (partition by code order by load_date desc) as rnum
	from mnp.sar
), subset as (
select q.code, q.load_date, q.open, q.low, q.high, q.close
	, t.extreme3 as extreme, t.ud_trend3 as ud_trend
	, t.af3 as af, t.sar3 as sar, t.n_sar3 as n_sar
from vlt.quotes q 
inner join temp t	on q.code = t.code
where q.load_date = c_date and t.rnum = 1 --and q.code = ''NAB''
), up_and_keep_org as (
select code, load_date, open, low, high, close
	, greatest(extreme, high) as extreme
	, ''up'' as ud_trend
	, case when extreme < high then least(0.3, af + 0.03) else af end as af
	, n_sar as sar
from subset 
where ud_trend = ''up'' and n_sar <= low
), up_and_stop_org as (
select code, load_date, open, low, high, close
	, greatest(extreme, high) as extreme
	, ''down'' as ud_trend
	, 0.03 as af
	, greatest(extreme, high) as sar
from subset 
where ud_trend = ''up'' and n_sar > low
), down_and_keep_org as (
select code, load_date, open, low, high, close
	, least( extreme, low) as extreme
	, ''down'' as ud_trend
	, case when extreme > low then least(0.3, af + 0.03) else af end as af
	, n_sar as sar
from subset 
where ud_trend = ''down'' and n_sar >= high	
), down_and_stop_org as (
select code, load_date, open, low, high, close
	, least( extreme, low) as extreme
	, ''up'' as ud_trend
	, 0.03 as af
	, least(extreme, high) as sar
from subset 
where ud_trend = ''down'' and n_sar < high	
) select *
, sar + af * (high - sar) as n_sar
from up_and_keep_org
union  select *
, sar + af * (low - sar) as n_sar
from up_and_stop_org
union  select *
, sar + af * (low - sar) as n_sar
from down_and_keep_org
union  select *
, sar + af * (low - sar) as n_sar
from down_and_stop_org
;

insert into mnp.sar select 
	coalesce (s2.code, s3.code) as code
,	coalesce (s2.load_date, s3.load_date) as load_date
,	s2.extreme, s2.ud_trend, s2.af, s2.sar, s2.n_sar
,	s3.extreme, s3.ud_trend, s3.af, s3.sar, s3.n_sar
from temp_sar2 s2 full outer join temp_sar3 s3
on s2.code = s3.code and s2.load_date = s3.load_date;




END;
';


--
-- Name: subpipe_trend_direction(); Type: FUNCTION; Schema: mnp; Owner: -
--

CREATE FUNCTION mnp.subpipe_trend_direction() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

insert into mnp.semester_trend_direction_source 
with temp as (select *
, lag(ud_trend2, 1) over (partition by code order by load_date) as last_trend2
, lag(ud_trend3, 1) over (partition by code order by load_date) as last_trend3
from mnp.sar 
), filter as (
select code, load_date from temp
where load_date > current_date - interval ''1 month''
and ((ud_trend2 = ''down'' and last_trend2 = ''up'' )
  or (ud_trend3 = ''down'' and last_trend3 = ''up'' ))
), combine as (
select f.code, f.load_date, e.load_date as list_date, e.price, e.ema15, e.ema40 from filter f
	inner join mnp.ema e
on f.code = e.code and f.load_date >= e.load_date
	and f.load_date - interval ''6 month'' < e.load_date 
), aggregation as (
select code, load_date, count(*) as rec
	, (sum(case when price > ema15 then 1 else 0 end )/count(*)::numeric)::numeric(5,3) as pe2
	, (sum(case when price > ema40 then 1 else 0 end )/count(*)::numeric)::numeric(5,3) as pe5
	, (sum(case when ema15 > ema40 then 1 else 0 end )/count(*)::numeric)::numeric(5,3) as e2e5
	from combine
	group by 1,2 having count(*) > 115
), output as (
select c.category,a.code, a.load_date, a.rec, a.pe2, a.pe5, a.e2e5
	, l.turnover, l.popularity 
	from aggregation a
	inner join mnp.actionable_list l	
on a.code = l.code and a.load_date = l.load_date
	inner join mtd.code_category c
on a.code = c.code
where (pe2 > 0.65 or pe5 > 0.65 or e2e5 > 0.65)
)
select * from output
ON CONFLICT (code, load_date) do nothing;

insert into mnp.quarterly_trend_direction_source 
with temp as (select *
, lag(ud_trend2, 1) over (partition by code order by load_date) as last_trend2
, lag(ud_trend3, 1) over (partition by code order by load_date) as last_trend3
from mnp.sar 
), filter as (
select code, load_date from temp
where load_date > current_date - interval ''1 month''
and ((ud_trend2 = ''down'' and last_trend2 = ''up'' )
  or (ud_trend3 = ''down'' and last_trend3 = ''up'' ))
), combine as (
select f.code, f.load_date, e.load_date as list_date, e.price, e.ema15, e.ema40 from filter f
	inner join mnp.ema e
on f.code = e.code and f.load_date >= e.load_date
	and f.load_date - interval ''3 month'' < e.load_date 
), aggregation as (
select code, load_date, count(*) as rec
	, (sum(case when price > ema15 then 1 else 0 end )/count(*)::numeric)::numeric(5,3) as pe2
	, (sum(case when price > ema40 then 1 else 0 end )/count(*)::numeric)::numeric(5,3) as pe5
	, (sum(case when ema15 > ema40 then 1 else 0 end )/count(*)::numeric)::numeric(5,3) as e2e5
	from combine
	group by 1,2 having count(*) > 60
), output as (
select c.category,a.code, a.load_date, a.rec, a.pe2, a.pe5, a.e2e5
	, l.turnover, l.popularity 
	from aggregation a
	inner join mnp.actionable_list l	
on a.code = l.code and a.load_date = l.load_date
	inner join mtd.code_category c
on a.code = c.code
where (pe2 > 0.65 or pe5 > 0.65 or e2e5 > 0.65)
)
select * from output 
ON CONFLICT (code, load_date) do nothing;

/*
create view mnp.v_quarterly_trend_direction_list as 
select category, code, max(load_date) as recent_calculation_date
,avg((pe2 + pe5 + e2e5)/3.0)::numeric(5,4) as  trend
, avg((popularity + turnover)/2)::numeric(2,1) as popularity
from mnp.quarterly_trend_direction_source
where load_date > current_date - interval ''2 month''
group by category, code 
having count(*) > 1 and avg((popularity + turnover)/2) < 3
order by category, count(*) desc ,avg((pe2 + pe5 + e2e5)/3.0) desc;


create view mnp.v_semester_trend_direction_list as 
select category, code, max(load_date) as recent_calculation_date
,avg((pe2 + pe5 + e2e5)/3.0)::numeric(5,4) as  trend
, avg((popularity + turnover)/2)::numeric(2,1) as popularity
from mnp.semester_trend_direction_source
where load_date > current_date - interval ''2 month''
group by category, code 
having count(*) > 1 and avg((popularity + turnover)/2) < 3
order by category, count(*) desc ,avg((pe2 + pe5 + e2e5)/3.0) desc;
*/


END;
';


--
-- Name: subpipe_trend_stability(date); Type: FUNCTION; Schema: mnp; Owner: -
--

CREATE FUNCTION mnp.subpipe_trend_stability(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

insert into mnp.semester_trend_stability_list 
with temp as (
select *
, row_number () over (partition by code order by load_date) as rdate
, row_number () over (partition by code order by close) as rclose

from vlt.quotes 
where load_date > c_date - interval ''6 month''
), aggregation as ( 
select code, max(load_date) as load_date, count(*) as records
, (sum(abs(rclose - rdate))/ count(*)::numeric(4,0))::numeric(12,3) as ratio
from temp group by 1 having count(*) > 100
), output as (
select c.category, a.* from aggregation a
	inner join mnp.v_current_actionable_list l
	on a.code = l.code -- and l.load_date = ''2022-04-22''
	inner join mtd.code_category c
	on a.code = c.code
where l.turnover <> 4 and l.popularity <> 4
) select category, code, load_date, ratio from output 
where ratio < 25
ON CONFLICT (code, load_date) do nothing;

insert into mnp.quarterly_trend_stability_list 
with temp as (
select *
, row_number () over (partition by code order by load_date) as rdate
, row_number () over (partition by code order by close) as rclose

from vlt.quotes 
where load_date > c_date - interval ''3 month''
), aggregation as ( 
select code, max(load_date) as load_date, count(*) as records
, (sum(abs(rclose - rdate))/ count(*)::numeric(4,0))::numeric(12,3) as ratio
from temp group by 1 having count(*) > 50
), output as (
select c.category, a.* from aggregation a
	inner join mnp.v_current_actionable_list l
	on a.code = l.code -- and l.load_date = ''2022-04-22''
	inner join mtd.code_category c
	on a.code = c.code
where l.turnover <> 4 and l.popularity <> 4
) select category, code, load_date, ratio from output 
where ratio < 10
ON CONFLICT (code, load_date) do nothing;

END;
';


--
-- Name: subpipe_xpt(); Type: FUNCTION; Schema: mnp; Owner: -
--

CREATE FUNCTION mnp.subpipe_xpt() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN
drop table if exists temp_filter_list;
create temp table temp_filter_list as 
with date as (
	select greatest (smdate,qmdate) as max_date
	from (select max(load_date) as smdate from mnp.semester_trend_stability_list)  t1
	cross join (select max(load_date) as qmdate from mnp.quarterly_trend_stability_list)   t2
), idx as (
select code from mnp.quarterly_trend_stability_list qs union
select code from mnp.semester_trend_stability_list ss union
select code from mnp.v_semester_trend_direction_list sd union
select code from mnp.v_quarterly_trend_direction_list qd
), list as (
	select c.category, c.code, max_date as load_date from idx i cross join date d
	inner join mtd.code_category c on i.code= c.code 
), combination as (
select i.*
	, greatest(qd.recent_calculation_date 
	, sd.recent_calculation_date) as calculation_date
	, qd.trend as qd_trend, sd.trend as sd_trend
	, qs.ratio as qs_ratio, ss.ratio as ss_ratio
from list i
left outer join mnp.v_quarterly_trend_direction_list qd
on i.code = qd.code 
left outer join mnp.v_semester_trend_direction_list sd
on i.code = sd.code 
left outer join mnp.quarterly_trend_stability_list qs
on i.code = qs.code and i.load_date = qs.load_date
left outer join mnp.semester_trend_stability_list ss
on i.code = ss.code and i.load_date = ss.load_date
) select * from combination
where (qs_ratio is not null or ss_ratio is not null)
and (qd_trend is not null or sd_trend is not null);

drop table if exists temp_lc_date;
create temp table temp_lc_date as 
with temp as (
select *
, lag(ud_trend2, 1) over (partition by code order by load_date) as last_trend2
, lag(ud_trend3, 1) over (partition by code order by load_date) as last_trend3
from mnp.sar 
), diff2 as (
	select *
	, row_number() over (partition by code order by load_date desc) as rnum
	from temp where ud_trend2 <> last_trend2 and ud_trend2 = ''down''
), diff3 as (
	select * 
	, row_number() over (partition by code order by load_date desc) as rnum
	from temp where ud_trend3 <> last_trend3 and ud_trend3 = ''down''
), output as (
	select coalesce(d2.code, d3.code) as code
	,least(d2.load_date, d3.load_date) as recent_date
	from diff2 d2 inner join diff3 d3 on d2.code = d3.code 
	and d2.rnum = 1 and d3.rnum =1
)select * from output;

insert into  xpt.daily_long_list 
select f.category, f.code, f.load_date--, qd_trend, sd_trend, qs_ratio, ss_ratio
, case when qd_trend is null or qd_trend < 0.65 then 0 else ((qd_trend- 0.65)/0.35*100)::numeric(3,0) end as quarterly_direction
, case when sd_trend is null or sd_trend < 0.65 then 0 else ((sd_trend- 0.65)/0.35*100)::numeric(3,0) end as semester_direction
, case when qs_ratio is null or qs_ratio > 10 then 0 else ((10-qs_ratio)/10.0*100)::numeric(3,0) end as quarterly_stability
, case when ss_ratio is null or ss_ratio > 25 then 0 else ((25-ss_ratio)/25.0*100)::numeric(3,0) end as semester_stability
from temp_filter_list f
inner join temp_lc_date l
on f.code = l.code 
where l.recent_date <= f.calculation_date;

insert into xpt.daily_summary 
with temp as (
select l.category,l.code, l.load_date
, l.quarterly_direction, l.semester_direction
, l.quarterly_stability, l.semester_stability
, row_number() over (partition by code order by l.load_date desc) as rnum
from xpt.daily_long_list l
inner join vlt.v_idx i on l.load_date = i.load_date
where rnum < 6
), filter as ( 
select category, code, load_date
	, quarterly_direction, semester_direction
	, quarterly_stability, semester_stability 
from temp where rnum = 1 
and (quarterly_direction <> 0 or semester_direction <> 0)
), combination as (
select f.category, f.code, f.load_date as report_date
	, quarterly_direction, semester_direction
	, quarterly_stability, semester_stability 
 	, concat(quarterly_direction, ''~'', semester_direction)::varchar as direction
 	, concat(quarterly_stability, ''~'', semester_stability)::varchar as stability
	, v.rec, v.financial_healthy, pe_ranking from filter  f
left outer join vlt.v_analysis v
on f.code = v.code
),output as ( 
select c.category, c.code, report_date, direction, stability
, rec, financial_healthy, pe_ranking
, price, ema15, ema40, ud_trend2, ud_trend3, n_sar2, n_sar3
	, quarterly_direction, semester_direction
	, quarterly_stability, semester_stability 
from combination c
left outer join mnp.ema e
on c.code = e.code 
left outer join mnp.sar s
on c.code = s.code
where e.load_date = (select max(load_date) from mnp.ema)
and s.load_date = (select max(load_date) from mnp.sar)
) select category, code, report_date, price
--, concat(((price/ema15 -1.0)*100)::numeric(5,2), ''%'')::varchar as ema10
, concat(((price/ema40 -1.0)*100)::numeric(5,2), ''%'')::varchar as ema25
, case when ud_trend2 = ''down'' and ud_trend3 = ''down'' 
	then concat(least(((n_sar2/price -1.0)*100)::numeric(5,2)
			,((n_sar3/price -1.0)*100)::numeric(5,2)), ''%'')
		when ud_trend2 = ''down'' then concat(((n_sar2/price -1.0)*100)::numeric(5,2), ''%'')
		when ud_trend3 = ''down'' then concat(((n_sar3/price -1.0)*100)::numeric(5,2), ''%'')
	else null end as sar_buff

--, concat(ud_trend2 ,''~'', ud_trend3) as "sar(.2.3)"
, concat(''('', direction,''),('', stability ,'')''  ) as trend
, rec, financial_healthy, pe_ranking
from output		 
order by category
, quarterly_stability*2 + semester_stability desc
, quarterly_direction*2 + semester_direction desc
ON CONFLICT (code, load_date) do nothing;

END;
';


--
-- Name: analysis_update(); Type: FUNCTION; Schema: ods; Owner: -
--

CREATE FUNCTION ods.analysis_update() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN
insert into vlt.analysis 
select a.code as code
, case 		when revenue = ''0'' then 0::numeric
			when length(revenue) = 1 then null::numeric
			when substring(revenue, length(revenue),1) = ''m'' then 
				substring(revenue, 1,length(revenue)-1)::numeric * 1000000
			when substring(revenue, length(revenue),1) = ''k'' then 
				substring(revenue, 1,length(revenue)-1)::numeric * 1000
			when substring(revenue, length(revenue)-1,2) = ''bn'' then 
				substring(revenue, 1,length(revenue)-2)::numeric * 1000000000
			when substring(revenue, length(revenue)-1,2) = ''tr'' then 
				substring(revenue, 1,length(revenue)-2)::numeric * 1000000000000
			else revenue::numeric
			end as revenue
, case when length(net_income) = 1 then null::numeric
			when substring(net_income, length(net_income),1) = ''m'' then 
				substring(net_income, 1,length(net_income)-1)::numeric * 1000000
			when substring(net_income, length(net_income),1) = ''k'' then 
				substring(net_income, 1,length(net_income)-1)::numeric * 1000
			when substring(net_income, length(net_income)-1,2) = ''bn'' then 
				substring(net_income, 1,length(net_income)-2)::numeric * 1000000000
			when substring(net_income, length(net_income)-1,2) = ''tr'' then 
				substring(net_income, 1,length(net_income)-2)::numeric * 1000000000000
			else net_income::numeric
			end as net_income
, case when net_profit_margin = ''-'' then null::numeric
		else replace(net_profit_margin, '','', '''')::numeric 
		end as net_profit_margin
, case when length(ebitda) = 1 then null::numeric
			when substring(ebitda, length(ebitda),1) = ''m'' then 
				substring(ebitda, 1,length(ebitda)-1)::numeric * 1000000
			when substring(ebitda, length(ebitda),1) = ''k'' then 
				substring(ebitda, 1,length(ebitda)-1)::numeric * 1000
			when substring(ebitda, length(ebitda)-1,2) = ''bn'' then 
				substring(ebitda, 1,length(ebitda)-2)::numeric * 1000000000
			when substring(ebitda, length(ebitda)-1,2) = ''tr'' then 
				substring(ebitda, 1,length(ebitda)-2)::numeric * 1000000000000				
			else ebitda::numeric
			end as ebitda	
, case when forward_pe != ''-'' and forward_pe != '''' and forward_pe is not null 
	then replace(forward_pe, '','' , '''')::numeric else null end as fpe 
, case when reco_price_target != ''-'' and reco_price_target != '''' and reco_price_target is not null 
	then replace(reco_price_target, '','' , '''')::numeric else null end as reco_price 
, average_recommendation
, sys_load_time::date as load_date
from ods.web_analysis a
where sys_load_time::date = (select max(sys_load_time::date) from ods.web_analysis)
ON CONFLICT (code, load_date) do nothing;

/*

create view vlt.v_analysis as 
with temp as (
select c.category, a.code, load_date, average_recommendation as rec
, case when fpe is null then -999 else fpe end  as fpe	
, row_number() over (partition by a.code order by load_date desc) rnum
, case when revenue is null then 0 
		when revenue >0 then 1 
	else -1 end as revenue
, case when net_income is null then 0 
		when net_income >0 then 1 
	else -1 end as net_income
, case when net_profit_margin is null then 0 
		when net_profit_margin >0 then 1 
	else -1 end as net_profit_margin	
, case when ebitda is null then 0 
		when ebitda >0 then 1 
	else -1 end as ebitda
from vlt.analysis a
inner join mtd.code_category c
	on a.code = c.code 
), output as (
select category, code, load_date, rec, fpe
, ((revenue + net_income +net_profit_margin + ebitda + 4)/8.0)::numeric(3,2) as financial_healthly
, row_number() over (partition by category order by fpe desc) as forward_pe
from temp
where rnum = 1 and load_date > current_date - interval ''14 day''
), agg as (
select category, count(*) as cnt from output group by category
)
select o.category, code, load_date, rec, financial_healthly
, (1- ((forward_pe-1)*1.0/(a.cnt-1.0)))::numeric(4,3) as pe_ranking
from output o inner join agg a
on o.category = a.category
*/

END;
';


--
-- Name: announcements_update(); Type: FUNCTION; Schema: ods; Owner: -
--

CREATE FUNCTION ods.announcements_update() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

insert into vlt.announcements 
with temp as (
	SELECT code
    	,to_timestamp(
			pub_time::text
			, ''DD/MM/YYYY HH12:MI AM''::text
		)::timestamp without time zone AS pub_datetime
	FROM ods.web_announcement
	WHERE is_price_sens::text = ''true''::text 
	and sys_load_time::date = (select max(sys_load_time::date) from ods.web_announcement)
	GROUP BY code
		,to_timestamp(pub_time::text, ''DD/MM/YYYY HH12:MI AM''::text)::timestamp without time zone
) select * from temp
ON CONFLICT (code, pub_datetime) do nothing;
END;
';


--
-- Name: code_list_generator(); Type: FUNCTION; Schema: ods; Owner: -
--

CREATE FUNCTION ods.code_list_generator() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN
drop table if exists temp_code_list;                          
create temp table temp_code_list as 
with lists as (
select code, max(record_dts::date) as record_date
	from mtd.full_code_list group by code
), max_date as (
select max(record_dts::date) as max_date
	from mtd.full_code_list
), output as (
select l.code from lists l
	inner join max_date d
	on l.record_date = d.max_date
) select code from output;

drop table if exists ods.code_list_finance;
create table ods.code_list_finance as select * from temp_code_list;

drop table if exists ods.code_list_consensus;
create table ods.code_list_consensus as select * from temp_code_list;

drop table if exists ods.code_list_quote;
create table ods.code_list_quote as select * from temp_code_list;

drop table if exists ods.code_list_rush_1230;
create table ods.code_list_rush_1230 as select * from temp_code_list;

drop table if exists ods.code_list_rush_1345;
create table ods.code_list_rush_1345 as select * from temp_code_list;

drop table if exists ods.code_list_rush_1500;
create table ods.code_list_rush_1500 as select * from temp_code_list;

drop table if exists ods.code_list_analysis;
create table ods.code_list_analysis as select * from temp_code_list ;

drop table if exists temp_code_list;
END;
';


--
-- Name: consensus_update(); Type: FUNCTION; Schema: ods; Owner: -
--

CREATE FUNCTION ods.consensus_update() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN
insert into vlt.consensus
 WITH temp_consensus AS (
		 SELECT trim(code) as code,
			buy::numeric(3,1) AS sb,
            overweight::numeric(3,1) AS nb,
            hold::numeric(3,1) AS hd,
            underweight::numeric(3,1) AS ns,
            sell::numeric(3,1) AS ss,
			substring(high, 2)::numeric(10,2) as high,
			substring(median, 2)::numeric(10,2) as median,
			substring(low, 2)::numeric(10,2) as low,
			substring(avearge, 2)::numeric(10,2) as average,
            sys_load_time::date AS load_date,
			row_number() OVER (PARTITION BY code, sys_load_time::date ORDER BY sys_load_time::time  DESC) AS rnum
           FROM ods.web_consensus
          WHERE buy IS NOT NULL AND buy::text <> ''''::text 
			AND overweight IS NOT NULL AND overweight::text <> ''''::text 
			AND hold IS NOT NULL AND hold::text <> ''''::text 
			AND underweight IS NOT NULL AND underweight::text <> ''''::text 
			AND sell IS NOT NULL AND sell::text <> ''''::text
			and high is not null and high <> '''' and high like ''$%'' and length(high) > 1 
			and median is not null and median <> '''' and median like ''$%'' and length(median) > 1 
			and low is not null and low <> '''' and low like ''$%'' and length(low) > 1 
			and avearge is not null and avearge <> '''' and avearge like ''$%'' and length(avearge) > 1 
 			and substring(high, 2)::numeric(10,2) > substring(median, 2)::numeric(10,2)
 			and substring(median, 2)::numeric(10,2) > substring(low, 2)::numeric(10,2)
	 		and sys_load_time::date = ( select max(sys_load_time::date) from ods.web_consensus)
        ), sub_consensus AS (
         SELECT code, load_date,
            (sb + nb + hd + ns + ss)::integer AS analysis,
            ((sb * 1::numeric + nb * 2::numeric + hd * 3::numeric + ns * 4::numeric + ss * 5::numeric) 
			 / (sb + nb + hd + ns + ss))::numeric(5,3) AS weight,
			((median - low)/(high - low))::numeric (5,3) as target_ratio
           FROM temp_consensus
          WHERE (sb + nb + hd + ns + ss) > 3::numeric AND rnum = 1
        )
 SELECT code::varchar AS code,
    load_date,
    analysis,
    weight,
	target_ratio
   FROM sub_consensus
ON CONFLICT (code, load_date) do nothing;

END;
';


--
-- Name: finance_update(); Type: FUNCTION; Schema: ods; Owner: -
--

CREATE FUNCTION ods.finance_update() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN
insert into vlt.finance  
WITH temp_finance AS (
         SELECT row_number() OVER (PARTITION BY web_finance.code, (web_finance.sys_load_time::date) ORDER BY (web_finance.sys_load_time::time without time zone) DESC) AS rnum,
            web_finance.code,
            web_finance.sys_load_time::date AS load_date,
            COALESCE(
                CASE
                    WHEN web_finance.market_open::text = ''''::text THEN NULL::character varying
                    ELSE web_finance.market_open
                END,
                CASE
                    WHEN web_finance.regular_market_open::text = ''''::text THEN NULL::character varying
                    ELSE web_finance.regular_market_open
                END)::numeric(6,3) AS open,
            COALESCE(
                CASE
                    WHEN web_finance.market_previous_close::text = ''''::text THEN NULL::character varying
                    ELSE web_finance.market_previous_close
                END,
                CASE
                    WHEN web_finance.regular_market_previous_close::text = ''''::text THEN NULL::character varying
                    ELSE web_finance.regular_market_previous_close
                END)::numeric(6,3) AS previous_close,
            COALESCE(
                CASE
                    WHEN web_finance.market_price::text = ''''::text THEN NULL::character varying
                    ELSE web_finance.market_price
                END,
                CASE
                    WHEN web_finance.current_price::text = ''''::text THEN NULL::character varying
                    ELSE web_finance.current_price
                END)::numeric(6,3) AS close,
            COALESCE(
                CASE
                    WHEN web_finance.market_volume::text = ''''::text THEN NULL::character varying
                    ELSE web_finance.market_volume
                END,
                CASE
                    WHEN web_finance.regualr_market_volume::text = ''''::text THEN NULL::character varying
                    ELSE web_finance.regualr_market_volume
                END)::bigint AS volume,
                CASE
                    WHEN web_finance.target_low_price::text = ''''::text THEN NULL::character varying
                    ELSE web_finance.target_low_price
                END::numeric(6,3) AS tlow,
                CASE
                    WHEN web_finance.target_high_price::text = ''''::text THEN NULL::character varying
                    ELSE web_finance.target_high_price
                END::numeric(6,3) AS thigh,
                CASE
                    WHEN web_finance.target_median_price::text = ''''::text THEN NULL::character varying
                    ELSE web_finance.target_median_price
                END::numeric(6,3) AS tmedian,
                CASE
                    WHEN web_finance.forward_pe::text = ''''::text OR web_finance.forward_pe::text = ''Infinity''::text THEN NULL::character varying
                    ELSE web_finance.forward_pe
                END::numeric(6,1) AS forward_pe
           FROM ods.web_finance
		where web_finance.sys_load_time::date = ( select max(sys_load_time::date) from ods.web_finance)
        ), temp AS (
         SELECT temp_finance.code,
            temp_finance.load_date,
            temp_finance.open,
            temp_finance.previous_close,
            temp_finance.close,
            temp_finance.volume,
            COALESCE(temp_finance.forward_pe, lag(temp_finance.forward_pe, 1, NULL::numeric) OVER (PARTITION BY temp_finance.code ORDER BY temp_finance.load_date), lag(temp_finance.forward_pe, 2, NULL::numeric) OVER (PARTITION BY temp_finance.code ORDER BY temp_finance.load_date), lag(temp_finance.forward_pe, 3, NULL::numeric) OVER (PARTITION BY temp_finance.code ORDER BY temp_finance.load_date), lag(temp_finance.forward_pe, 4, NULL::numeric) OVER (PARTITION BY temp_finance.code ORDER BY temp_finance.load_date)) AS forward_pe,
                CASE
                    WHEN temp_finance.thigh IS NOT NULL AND temp_finance.tlow IS NOT NULL AND temp_finance.thigh <> temp_finance.tlow THEN (temp_finance.tmedian - temp_finance.tlow) / (temp_finance.thigh - temp_finance.tlow)
                    ELSE 0::numeric
                END::numeric(5,3) AS target_ratio
           FROM temp_finance
          WHERE temp_finance.rnum = 1
        ), sub_finance AS (
         SELECT temp.code,
            temp.load_date,
            temp.open,
            temp.previous_close,
            temp.close,
            temp.volume,
            temp.forward_pe,
            temp.target_ratio
			-- ,rank() OVER (PARTITION BY temp.load_date ORDER BY temp.forward_pe DESC) AS pe_rank
           FROM temp
          WHERE temp.forward_pe IS NOT NULL -- AND temp.target_ratio > 0.5
        )
 SELECT sub_finance.code,
    sub_finance.load_date,
    sub_finance.open,
    sub_finance.previous_close,
    sub_finance.close,
    sub_finance.volume,
    sub_finance.forward_pe,
    sub_finance.target_ratio
	-- ,sub_finance.pe_rank
   FROM sub_finance
   
ON CONFLICT (code, load_date) do nothing;
END;
';


--
-- Name: forex_clean(); Type: FUNCTION; Schema: ods; Owner: -
--

CREATE FUNCTION ods.forex_clean() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists  temp_set;
create temp table temp_set as 
select * from ods.v_snapshot;


insert into vlt.forex_eur
select instrument, snapshot_on_gtc
, bid, ask, sys_dt from temp_set
where instrument = ''EUR_USD'';

insert into vlt.forex_jpy 
select instrument, snapshot_on_gtc
, bid, ask, sys_dt from temp_set
where instrument = ''USD_JPY'';

insert into vlt.forex_aud
select instrument, snapshot_on_gtc
, bid, ask, sys_dt from temp_set
where instrument = ''AUD_USD'';

insert into  vlt.forex_gbp 
select instrument, snapshot_on_gtc
, bid, ask, sys_dt from temp_set
where instrument = ''GBP_USD'';

delete from ods.forex_snapshot
where sys_dt <= (select max(sys_dt) from temp_set);


END;
';


--
-- Name: quotes_update(); Type: FUNCTION; Schema: ods; Owner: -
--

CREATE FUNCTION ods.quotes_update() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

insert into vlt.quotes
with validation as (
	select code, tick_price::numeric(9,4)
	, TO_TIMESTAMP(tick_time,''YYYY-MM-DD"T"HH24:MI:SS"Z"'')::timestamp without time zone 
		at time zone ''UTC'' at time zone ''AEDT'' as tick_ts
	, sys_load_time::date as load_date
	from ods.web_ticker where sys_load_time::date > current_date -7
), filter as (
	select code, load_date 
	from validation	group by code, load_date 
	having load_date = max(tick_ts::date) 
), output as (
select q.code
	, cast(q.sys_load_time as date) as record_date
	, case when q.open_price <> '''' then open_price else null end::numeric(8,3) as open
	, case when q.low_price <> '''' then low_price else null end::numeric(8,3) as low
	, case when q.high_price <> '''' then high_price else null end::numeric(8,3) as high
	, case when q.previous_close <> '''' then previous_close else null end::numeric(8,3) as pclose
	, case when q.close_price <> '''' then close_price else null end::numeric(8,3) as close
	, case when q.volume <> '''' then volume else null end ::int as volume
	, case when q.turnover <> '''' then turnover else null end ::numeric(16,3) as turnover
	, case when q.market_cap <> '''' then market_cap else null end ::numeric(21,2) as market_cap
	, case when q.ask <> '''' then ask else null end ::numeric(8,3) as ask
	, case when q.bid <> '''' then bid else null end ::numeric(8,3) as bid
from ods.web_quote q
inner join filter f
	on q.code= f.code and cast(q.sys_load_time as date) = f.load_date
)
select code, record_date, open, low, high, close, pclose, volume, turnover, market_cap, ask, bid
	, (close/pclose)::numeric(8,4) as daily_change
	, ((COALESCE(high, close) + COALESCE(low, close) + close) / 3.0)::numeric(8,3) AS typ3
	, ((COALESCE(high, close) + COALESCE(low, close) + COALESCE(open, close) + close) / 4.0)::numeric(8,3) AS typ4
from output 
ON CONFLICT (code, load_date) do nothing;
END;
';


--
-- Name: rush_1230_update(); Type: FUNCTION; Schema: ods; Owner: -
--

CREATE FUNCTION ods.rush_1230_update() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

insert into vlt.rush_1230
with clean as (
	select code, tick_price::numeric(9,4)
	, TO_TIMESTAMP(tick_time,''YYYY-MM-DD"T"HH24:MI:SS"Z"'')::timestamp without time zone 
		at time zone ''UTC'' at time zone ''AEDT'' as tick_ts
from ods.web_rush_1230 
), idx as (
	select tick_ts::date  as tick_date
		, row_number() over(order by tick_ts::date desc) as idx
	from clean 
	where extract(isodow from tick_ts::date) not in (6,7)
	group by tick_ts::date
), subset as (
	select c.code, c.tick_price, c.tick_ts 
		, row_number() over (partition by code order by tick_ts desc) as close
		, row_number() over (partition by code order by tick_ts ) as open
	from clean c inner join idx i on c.tick_ts::date = i.tick_date
	where i.idx = 1 and tick_ts::time <= ''12:30:00''
), begins as (
	select code, tick_price as open from subset where open = 1
), ends as (
	select code, tick_price as close from subset where close = 1
), minmax as(
	select code, tick_ts::date as load_date
		, min(tick_price) as lowest, max(tick_price) as highest 
	from subset group by code, tick_ts::date
), output as (
	select m.code,m.load_date, m.highest as high, m.lowest as low
	, b.open, e.close
	from minmax m 
	inner join begins b on m.code = b.code 
	inner join ends e on m.code = e.code
) select code, load_date, high, low, open, close 
	, ((COALESCE(high, close) + COALESCE(low, close) + close) / 3.0)::numeric(9,4) AS typ3
	, ((COALESCE(high, close) + COALESCE(low, close) + COALESCE(open, close) + close) / 4.0)::numeric(9,4) AS typ4
from output	ON CONFLICT (code, load_date) do nothing;

insert into rtc.list_1230 
with rush as (
select * 
	from vlt.rush_1230
	where load_date = (select max(load_date) from vlt.rush_1230)
), sar as (
	select * 
	from mnp.sar 
	where load_date = (select max(load_date) from mnp.sar)
		and (ud_trend2 = ''down'' or ud_trend3 = ''down'')
), current_anc as (
select code 
	from vlt.announcements 
	where pub_datetime::date = current_date
		and pub_datetime < current_date::timestamp + interval ''10 hour''
	group by code
), hist_anc as (
select code, min(i.rnum) as last_anc 
	from vlt.announcements a
	inner join vlt.v_idx i on a.pub_datetime::date = i.load_date
	group by code
), tech as (
select r.code, r.load_date
	, ((l.turnover + l.popularity)/2.0)::numeric(2,1) as popularity
	, CASE 
		WHEN (r.high > s.n_sar2 and ud_trend2 = ''down'') 
			AND (r.high > s.n_sar3 and ud_trend3 = ''down'') 
			THEN concat(''$'', s.n_sar2::varchar, ''~'', ''$'', s.n_sar3::varchar)  
		WHEN (r.high > s.n_sar2 and ud_trend2 = ''down'') 
			THEN concat(''$'', s.n_sar2::varchar, ''~'', ''-'')  
		WHEN (r.high > s.n_sar3 and ud_trend3 = ''down'')
			THEN concat(''-'', ''~'', ''$'', s.n_sar3::varchar)  
		ELSE ''(-~-)'' END AS SAR
	, case when ca.code is not null then 0
		when last_anc < 10 then last_anc
		else -1 end as reporting_date
	from rush r
	inner join sar s on r.code = s.code
	inner join mnp.v_current_actionable_list l on r.code = l.code 
	left outer join current_anc ca on r.code = ca.code
	left outer join  hist_anc ha on r.code = ha.code
	where ((r.high > s.n_sar2 and ud_trend2 = ''down'')
	   or (r.high > s.n_sar3 and ud_trend3 = ''down''))
), long_list as (
select l.code, l.load_date
	, l.quarterly_direction, l.semester_direction
	, l.quarterly_stability, l.semester_stability	
	, row_number() over (partition by code order by l.load_date desc) as rnum
	from xpt.daily_long_list l
	inner join vlt.v_idx i on l.load_date = i.load_date
	where rnum < 6
), action_list as ( 
select code, load_date
	, concat ( ''('', quarterly_direction, ''~'', semester_direction, 
		'','', quarterly_stability, ''~'', semester_stability, '')'')::varchar as trend
	from long_list 
	where rnum = 1 
	and (quarterly_direction <> 0 or semester_direction <> 0)
), act_list as ( 
select c.category, t.code, t.load_date, t.popularity, t.sar, t.reporting_date
	, a.trend , v.rec, v.financial_healthy, v.pe_ranking
	from tech t
	inner join action_list a on t.code = a.code
	inner join mtd.code_category c on t.code = c.code
	left outer join vlt.v_analysis v on t.code = v.code
), output as (
	select l.category, l.code, l.load_date, l.popularity, l.sar
		, l.reporting_date, l.trend, l.rec, l.financial_healthy
		, l.pe_ranking, q.avg_range, q.avg_diff, q.std_range, q.std_diff
	from act_list l
	inner join mnp.v_current_simple_moving_range q on l.code = q.code
)select category, code, load_date, popularity, sar,trend, reporting_date
	, concat (
		(avg_diff*2- std_diff)::numeric(6,2), ''%'', ''~'',
		(avg_diff*2)::numeric(6,2), ''%'', ''~'',
		(avg_diff*2+ std_diff)::numeric(6,2), ''%'') as expect_ratio
	, rec, financial_healthy, pe_ranking
from output	ON CONFLICT (code, load_date) do nothing;

PERFORM cal.rush_1230_index();
PERFORM cal.rush_1230_ha(current_date);
PERFORM rtc.rush_1230_trend(current_date);
PERFORM rtc.rush_1230_ema(current_date);
PERFORM rtc.rush_1230_ema_on_ha(current_date);
PERFORM rtc.rush_1230_macd(current_date);


END;
';


--
-- Name: rush_1345_update(); Type: FUNCTION; Schema: ods; Owner: -
--

CREATE FUNCTION ods.rush_1345_update() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

insert into vlt.rush_1345
with clean as (
	select code, tick_price::numeric(9,4)
	, TO_TIMESTAMP(tick_time,''YYYY-MM-DD"T"HH24:MI:SS"Z"'')::timestamp without time zone 
		at time zone ''UTC'' at time zone ''AEDT'' as tick_ts
from ods.web_rush_1345
), idx as (
	select tick_ts::date  as tick_date
		, row_number() over(order by tick_ts::date desc) as idx
	from clean 
	where extract(isodow from tick_ts::date) not in (6,7)
	group by tick_ts::date
), subset as (
	select c.code, c.tick_price, c.tick_ts 
		, row_number() over (partition by code order by tick_ts desc) as close
		, row_number() over (partition by code order by tick_ts ) as open
	from clean c inner join idx i on c.tick_ts::date = i.tick_date
	where i.idx = 1 and tick_ts::time <= ''13:45:00''
), begins as (
	select code, tick_price as open from subset where open = 1
), ends as (
	select code, tick_price as close from subset where close = 1
), minmax as(
	select code, tick_ts::date as load_date
		, min(tick_price) as lowest, max(tick_price) as highest 
	from subset group by code, tick_ts::date
), output as (
	select m.code,m.load_date, m.highest as high, m.lowest as low
	, b.open, e.close
	from minmax m 
	inner join begins b on m.code = b.code 
	inner join ends e on m.code = e.code
) select code, load_date, high, low, open, close 
	, ((COALESCE(high, close) + COALESCE(low, close) + close) / 3.0)::numeric(9,4) AS typ3
	, ((COALESCE(high, close) + COALESCE(low, close) + COALESCE(open, close) + close) / 4.0)::numeric(9,4) AS typ4
from output	ON CONFLICT (code, load_date) do nothing;

insert into rtc.list_1345
with rush as (
select * 
	from vlt.rush_1345
	where load_date = (select max(load_date) from vlt.rush_1345)
), sar as (
	select * 
	from mnp.sar 
	where load_date = (select max(load_date) from mnp.sar)
		and (ud_trend2 = ''down'' or ud_trend3 = ''down'')
), current_anc as (
select code 
	from vlt.announcements 
	where pub_datetime::date = current_date
		and pub_datetime < current_date::timestamp + interval ''10 hour''
	group by code
), hist_anc as (
select code, min(i.rnum) as last_anc 
	from vlt.announcements a
	inner join vlt.v_idx i on a.pub_datetime::date = i.load_date
	group by code
), tech as (
select r.code, r.load_date
	, ((l.turnover + l.popularity)/2.0)::numeric(2,1) as popularity
	, CASE 
		WHEN (r.high > s.n_sar2 and ud_trend2 = ''down'') 
			AND (r.high > s.n_sar3 and ud_trend3 = ''down'') 
			THEN concat(''$'', s.n_sar2::varchar, ''~'', ''$'', s.n_sar3::varchar)  
		WHEN (r.high > s.n_sar2 and ud_trend2 = ''down'') 
			THEN concat(''$'', s.n_sar2::varchar, ''~'', ''-'')  
		WHEN (r.high > s.n_sar3 and ud_trend3 = ''down'')
			THEN concat(''-'', ''~'', ''$'', s.n_sar3::varchar)  
		ELSE ''(-~-)'' END AS SAR
	, case when ca.code is not null then 0
		when last_anc < 10 then last_anc
		else -1 end as reporting_date
	from rush r
	inner join sar s on r.code = s.code
	inner join mnp.v_current_actionable_list l on r.code = l.code 
	left outer join current_anc ca on r.code = ca.code
	left outer join  hist_anc ha on r.code = ha.code
	where ((r.high > s.n_sar2 and ud_trend2 = ''down'')
	   or (r.high > s.n_sar3 and ud_trend3 = ''down''))
), long_list as (
select l.code, l.load_date
	, l.quarterly_direction, l.semester_direction
	, l.quarterly_stability, l.semester_stability	
	, row_number() over (partition by code order by l.load_date desc) as rnum
	from xpt.daily_long_list l
	inner join vlt.v_idx i on l.load_date = i.load_date
	where rnum < 6
), action_list as ( 
select code, load_date
	, concat ( ''('', quarterly_direction, ''~'', semester_direction, 
		'','', quarterly_stability, ''~'', semester_stability, '')'')::varchar as trend
	from long_list 
	where rnum = 1 
	and (quarterly_direction <> 0 or semester_direction <> 0)
), act_list as ( 
select c.category, t.code, t.load_date, t.popularity, t.sar, t.reporting_date
	, a.trend , v.rec, v.financial_healthy, v.pe_ranking
	from tech t
	inner join action_list a on t.code = a.code
	inner join mtd.code_category c on t.code = c.code
	left outer join vlt.v_analysis v on t.code = v.code
), output as (
	select l.category, l.code, l.load_date, l.popularity, l.sar
		, l.reporting_date, l.trend, l.rec, l.financial_healthy
		, l.pe_ranking, q.avg_range, q.avg_diff, q.std_range, q.std_diff
	from act_list l
	inner join mnp.v_current_simple_moving_range q on l.code = q.code
)select category, code, load_date, popularity, sar,trend, reporting_date
	, concat (
		(avg_diff*2- std_diff)::numeric(6,2), ''%'', ''~'',
		(avg_diff*2)::numeric(6,2), ''%'', ''~'',
		(avg_diff*2+ std_diff)::numeric(6,2), ''%'') as expect_ratio
	, rec, financial_healthy, pe_ranking
from output	ON CONFLICT (code, load_date) do nothing;

PERFORM cal.rush_1345_index();
PERFORM cal.rush_1345_ha(current_date);
PERFORM rtc.rush_1345_trend(current_date);
PERFORM rtc.rush_1345_ema(current_date);
PERFORM rtc.rush_1345_ema_on_ha(current_date);
PERFORM rtc.rush_1345_macd(current_date);

END;
';


--
-- Name: rush_1500_update(); Type: FUNCTION; Schema: ods; Owner: -
--

CREATE FUNCTION ods.rush_1500_update() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

insert into vlt.rush_1500
with clean as (
	select code, tick_price::numeric(9,4)
	, TO_TIMESTAMP(tick_time,''YYYY-MM-DD"T"HH24:MI:SS"Z"'')::timestamp without time zone 
		at time zone ''UTC'' at time zone ''AEDT'' as tick_ts
from ods.web_rush_1500
), idx as (
	select tick_ts::date  as tick_date
		, row_number() over(order by tick_ts::date desc) as idx
	from clean 
	where extract(isodow from tick_ts::date) not in (6,7)
	group by tick_ts::date
), subset as (
	select c.code, c.tick_price, c.tick_ts 
		, row_number() over (partition by code order by tick_ts desc) as close
		, row_number() over (partition by code order by tick_ts ) as open
	from clean c inner join idx i on c.tick_ts::date = i.tick_date
	where i.idx = 1 and tick_ts::time <= ''15:00:00''
), begins as (
	select code, tick_price as open from subset where open = 1
), ends as (
	select code, tick_price as close from subset where close = 1
), minmax as(
	select code, tick_ts::date as load_date
		, min(tick_price) as lowest, max(tick_price) as highest 
	from subset group by code, tick_ts::date
), output as (
	select m.code,m.load_date, m.highest as high, m.lowest as low
	, b.open, e.close
	from minmax m 
	inner join begins b on m.code = b.code 
	inner join ends e on m.code = e.code
) select code, load_date, high, low, open, close 
	, ((COALESCE(high, close) + COALESCE(low, close) + close) / 3.0)::numeric(9,4) AS typ3
	, ((COALESCE(high, close) + COALESCE(low, close) + COALESCE(open, close) + close) / 4.0)::numeric(9,4) AS typ4
from output	ON CONFLICT (code, load_date) do nothing;

insert into rtc.list_1500 
with rush as (
select * 
	from vlt.rush_1500
	where load_date = (select max(load_date) from vlt.rush_1500)
), sar as (
	select * 
	from mnp.sar 
	where load_date = (select max(load_date) from mnp.sar)
		and (ud_trend2 = ''down'' or ud_trend3 = ''down'')
), current_anc as (
select code 
	from vlt.announcements 
	where pub_datetime::date = current_date
		and pub_datetime < current_date::timestamp + interval ''10 hour''
	group by code
), hist_anc as (
select code, min(i.rnum) as last_anc 
	from vlt.announcements a
	inner join vlt.v_idx i on a.pub_datetime::date = i.load_date
	group by code
), tech as (
select r.code, r.load_date
	, ((l.turnover + l.popularity)/2.0)::numeric(2,1) as popularity
	, CASE 
		WHEN (r.high > s.n_sar2 and ud_trend2 = ''down'') 
			AND (r.high > s.n_sar3 and ud_trend3 = ''down'') 
			THEN concat(''$'', s.n_sar2::varchar, ''~'', ''$'', s.n_sar3::varchar)  
		WHEN (r.high > s.n_sar2 and ud_trend2 = ''down'') 
			THEN concat(''$'', s.n_sar2::varchar, ''~'', ''-'')  
		WHEN (r.high > s.n_sar3 and ud_trend3 = ''down'')
			THEN concat(''-'', ''~'', ''$'', s.n_sar3::varchar)  
		ELSE ''(-~-)'' END AS SAR
	, case when ca.code is not null then 0
		when last_anc < 10 then last_anc
		else -1 end as reporting_date
	from rush r
	inner join sar s on r.code = s.code
	inner join mnp.v_current_actionable_list l on r.code = l.code 
	left outer join current_anc ca on r.code = ca.code
	left outer join  hist_anc ha on r.code = ha.code
	where ((r.high > s.n_sar2 and ud_trend2 = ''down'')
	   or (r.high > s.n_sar3 and ud_trend3 = ''down''))
), long_list as (
select l.code, l.load_date
	, l.quarterly_direction, l.semester_direction
	, l.quarterly_stability, l.semester_stability	
	, row_number() over (partition by code order by l.load_date desc) as rnum
	from xpt.daily_long_list l
	inner join vlt.v_idx i on l.load_date = i.load_date
	where rnum < 6
), action_list as ( 
select code, load_date
	, concat ( ''('', quarterly_direction, ''~'', semester_direction, 
		'','', quarterly_stability, ''~'', semester_stability, '')'')::varchar as trend
	from long_list 
	where rnum = 1 
	and (quarterly_direction <> 0 or semester_direction <> 0)
), act_list as ( 
select c.category, t.code, t.load_date, t.popularity, t.sar, t.reporting_date
	, a.trend , v.rec, v.financial_healthy, v.pe_ranking
	from tech t
	inner join action_list a on t.code = a.code
	inner join mtd.code_category c on t.code = c.code
	left outer join vlt.v_analysis v on t.code = v.code
), output as (
	select l.category, l.code, l.load_date, l.popularity, l.sar
		, l.reporting_date, l.trend, l.rec, l.financial_healthy
		, l.pe_ranking, q.avg_range, q.avg_diff, q.std_range, q.std_diff
	from act_list l
	inner join mnp.v_current_simple_moving_range q on l.code = q.code
)select category, code, load_date, popularity, sar,trend, reporting_date
	, concat (
		(avg_diff*2- std_diff)::numeric(6,2), ''%'', ''~'',
		(avg_diff*2)::numeric(6,2), ''%'', ''~'',
		(avg_diff*2+ std_diff)::numeric(6,2), ''%'') as expect_ratio
	, rec, financial_healthy, pe_ranking
from output	ON CONFLICT (code, load_date) do nothing;

PERFORM cal.rush_1500_index();
PERFORM cal.rush_1500_ha(current_date);
PERFORM rtc.rush_1500_trend(current_date);
PERFORM rtc.rush_1500_ema(current_date);
PERFORM rtc.rush_1500_ema_on_ha(current_date);
PERFORM rtc.rush_1500_macd(current_date);

END;
';


--
-- Name: shorts_update(); Type: FUNCTION; Schema: ods; Owner: -
--

CREATE FUNCTION ods.shorts_update() RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN
insert into vlt.shorts
WITH sub_short AS (
         SELECT btrim(product_code) AS code,
            sys_load::date AS load_date,
                CASE
                    WHEN short_position = '''' THEN NULL::bigint
                    ELSE short_position::bigint
                END AS short_position,
                CASE
                    WHEN total_in_issue = '''' THEN NULL::bigint
                    ELSE total_in_issue::bigint
                END AS total_in_issue,
                CASE
                    WHEN reported_position = '''' THEN NULL::numeric
                    ELSE reported_position::numeric(31,8)
                END AS reported_position,
            row_number() OVER (PARTITION BY product_code, (sys_load::date) ORDER BY (sys_load::time) DESC) AS rnum
           FROM ods.web_short
	 where sys_load::date = (select max(sys_load::date) from ods.web_short)
        )
 SELECT sub_short.code::character varying AS code,
    sub_short.load_date,
    sub_short.short_position,
    sub_short.total_in_issue,
    sub_short.reported_position
   FROM sub_short
  WHERE sub_short.rnum = 1
ON CONFLICT (code, load_date) do nothing;

END;
';


--
-- Name: rush_1230_ema(date); Type: FUNCTION; Schema: rtc; Owner: -
--

CREATE FUNCTION rtc.rush_1230_ema(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists temp_daily_ema15;
create temp table temp_daily_ema15 as 
with quote as (
select q.code, q.close, q.load_date 
	, row_number() over(partition by code order by load_date desc)+1 as idx
	from vlt.quotes q where load_date < c_date
union 
select code, close, load_date , 1 as idx
	from vlt.rush_1230 where load_date = c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 15-w.orders as new_order,  15-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema15''	
), temp as ( 
select code, c_date::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema, q.close as price
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =15
)select code, load_date, price, ema
from output ;

drop table if exists temp_daily_ema40;
create temp table temp_daily_ema40 as 
with quote as (
select q.code, q.close, q.load_date
	, row_number() over(partition by code order by load_date desc)+1 as idx
	from vlt.quotes q where load_date < c_date
union 
select code, close, load_date , 1 as idx
	from vlt.rush_1230 where load_date = c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 40-w.orders as new_order,  40-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema40''	
), temp as ( 
select code, c_date::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema, q.close as price
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =40
)select code, load_date, price, ema
from output ;

insert into rtc.ema_1230
select coalesce (e1.code, e2.code) as code
, coalesce (e1.load_date, e2.load_date) as load_date
, coalesce (e1.price, e2.price) as price
, e1.ema as ema15 ,e2.ema as ema40
from temp_daily_ema15 e1 
inner join temp_daily_ema40 e2
on e1.code = e2.code and e1.load_date = e2.load_date
ON CONFLICT (code, load_date) do nothing;


END;
';


--
-- Name: rush_1230_ema_on_ha(date); Type: FUNCTION; Schema: rtc; Owner: -
--

CREATE FUNCTION rtc.rush_1230_ema_on_ha(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists temp_daily_ema15;
create temp table temp_daily_ema15 as 
with quote as (
select q.code, q.close, q.load_date 
	, row_number() over(partition by code order by load_date desc)+1 as idx
	from cal.heikin_ashi q where load_date < c_date
union 
select code, h_close, load_date , 1 as idx
	from rtc.ha_1230 where load_date = c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 15-w.orders as new_order,  15-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema15''	
), temp as ( 
select code, (c_date)::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema, q.close as price
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =15
)select code, load_date, price, ema
from output ;

drop table if exists temp_daily_ema40;
create temp table temp_daily_ema40 as 
with quote as (
select q.code, q.close, q.load_date
	, row_number() over(partition by code order by load_date desc)+1 as idx
	from cal.heikin_ashi q where load_date < c_date
union 
select code, h_close, load_date , 1 as idx
	from rtc.ha_1230 where load_date = c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 40-w.orders as new_order,  40-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema40''	
), temp as ( 
select code, (c_date)::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema, q.close as price
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =40
)select code, load_date, price, ema
from output ;

insert into rtc.ema_on_ha_1230
select coalesce (e1.code, e2.code) as code
, coalesce (e1.load_date, e2.load_date) as load_date
, coalesce (e1.price, e2.price) as price
, e1.ema as ema15 ,e2.ema as ema40
from temp_daily_ema15 e1 
inner join temp_daily_ema40 e2
on e1.code = e2.code and e1.load_date = e2.load_date
ON CONFLICT (code, load_date) do nothing;


drop table if exists temp_daily_ema15;
drop table if exists temp_daily_ema40;

END;
';


--
-- Name: rush_1230_macd(date); Type: FUNCTION; Schema: rtc; Owner: -
--

CREATE FUNCTION rtc.rush_1230_macd(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN


insert into rtc.macd_1230  
with quote as (
select q.code, (q.ema15- q.ema40) as close, load_date
	, row_number() over(partition by code order by load_date desc)+1  as idx
	from cal.ha_ema q where load_date < c_date	
union	
select q.code, (q.ema15- q.ema40) as close, load_date
	, row_number() over(partition by code order by load_date desc) as idx
	from rtc.ema_on_ha_1230 q where load_date = c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 15-w.orders as new_order,  15-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema15''	
), temp as ( 
select code, c_date::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema as dea, q.close as diff
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =15
)select code, load_date, diff, dea, ''ha'' as chart_type
from output 
ON CONFLICT (code, load_date) do nothing;

END;
';


--
-- Name: rush_1230_trend(date); Type: FUNCTION; Schema: rtc; Owner: -
--

CREATE FUNCTION rtc.rush_1230_trend(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists current_ha;
create temp table current_ha as 
select * from cal.heikin_ashi 
	where load_date < c_date
	and load_date > c_date - 48 *7
union 
select * from rtc.ha_1230
	where load_date = c_date;
	
	

drop table if exists icompare;
create temp table icompare as 
with temp as (
select *
	, lag(open , 1 , null) over (partition by code order by load_date) as last_open
	, lag(close , 1 , null) over (partition by code order by load_date) as last_close
	, lead(open , 1 , null) over (partition by code order by load_date) as next_open
	, lead(close , 1 , null) over (partition by code order by load_date) as next_close
from current_ha 
), ientry as (
select * from temp 
where open <= close and last_open > last_close
), iclose as (
select * from temp 
where open <= close and next_open > next_close
), combine as (
select ie.code
	, ie.load_date as entry_date
	, ic.load_date as exit_date
	, row_number() over (partition by ie.code , ie.load_date order by ic.load_date ) as rnum
from ientry ie
inner join iclose ic
on ie.code = ic.code
where ie.load_date < ic.load_date
), period as (
select code, entry_date, exit_date
	, row_number() over (partition by code order by exit_date desc) as rnum
from combine where rnum =1
), subset as ( select t.*, p.rnum from temp t
inner join period p
on t.code = p.code 
where t.load_date >= p.entry_date
and t.load_date <= p.exit_date
) select code, rnum, max(close) as hpoint from subset
where rnum in (1,2)
group by code, rnum
order by code, rnum 
;		

drop table if exists dcompare;
create temp table dcompare as 
with temp as (
select *
	, lag(open , 1 , null) over (partition by code order by load_date) as last_open
	, lag(close , 1 , null) over (partition by code order by load_date) as last_close
	, lead(open , 1 , null) over (partition by code order by load_date) as next_open
	, lead(close , 1 , null) over (partition by code order by load_date) as next_close
from current_ha 
), ientry as (
select * from temp 
where open > close and last_open <= last_close
), iclose as (
select * from temp 
where open > close and next_open <= next_close
), combine as (
select ie.code
	, ie.load_date as entry_date
	, ic.load_date as exit_date
	, row_number() over (partition by ie.code , ie.load_date order by ic.load_date ) as rnum
from ientry ie
inner join iclose ic
on ie.code = ic.code
where ie.load_date < ic.load_date
), period as (
select code, entry_date, exit_date
	, row_number() over (partition by code order by exit_date desc) as rnum
from combine where rnum =1
), subset as ( select t.*, p.rnum from temp t
inner join period p
on t.code = p.code 
where t.load_date >= p.entry_date
and t.load_date <= p.exit_date
)select code, rnum, min(close) as lpoint from subset
where rnum in (1,2)
group by code, rnum
order by code, rnum ;	

drop table if exists itrend;
create temp table itrend as 
with dlist as (
select d1.code from dcompare d1
inner join dcompare d2
on d1.code = d2.code 
where d1.lpoint > d2.lpoint
and d1.rnum =1 and d2.rnum =2 
), ilist as (
select i1.code from icompare i1
inner join icompare i2
on i1.code = i2.code 
where i1.hpoint > i2.hpoint
and i1.rnum =1 and i2.rnum =2 
) select d.code from dlist d
inner join ilist i
on d.code = i.code ;

drop table if exists dtrend;
create temp table dtrend as 
with dlist as (
select d1.code from dcompare d1
inner join dcompare d2
on d1.code = d2.code 
where d1.lpoint < d2.lpoint
and d1.rnum =1 and d2.rnum =2 
), ilist as (
select i1.code from icompare i1
inner join icompare i2
on i1.code = i2.code 
where i1.hpoint < i2.hpoint
and i1.rnum =1 and i2.rnum =2 
) select d.code from dlist d
inner join ilist i
on d.code = i.code ;

insert into rtc.trend_1230
select code, c_date, ''i''
from itrend;


insert into rtc.trend_1230
select code, c_date, ''d''
from dtrend;

END;
';


--
-- Name: rush_1345_ema(date); Type: FUNCTION; Schema: rtc; Owner: -
--

CREATE FUNCTION rtc.rush_1345_ema(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists temp_daily_ema15;
create temp table temp_daily_ema15 as 
with quote as (
select q.code, q.close, q.load_date 
	, row_number() over(partition by code order by load_date desc)+1 as idx
	from vlt.quotes q where load_date < c_date
union 
select code, close, load_date , 1 as idx
	from vlt.rush_1345 where load_date = c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 15-w.orders as new_order,  15-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema15''	
), temp as ( 
select code, c_date::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema, q.close as price
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =15
)select code, load_date, price, ema
from output ;

drop table if exists temp_daily_ema40;
create temp table temp_daily_ema40 as 
with quote as (
select q.code, q.close, q.load_date
	, row_number() over(partition by code order by load_date desc)+1 as idx
	from vlt.quotes q where load_date < c_date
union 
select code, close, load_date , 1 as idx
	from vlt.rush_1345 where load_date = c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 40-w.orders as new_order,  40-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema40''	
), temp as ( 
select code, c_date::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema, q.close as price
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =40
)select code, load_date, price, ema
from output ;

insert into rtc.ema_1345
select coalesce (e1.code, e2.code) as code
, coalesce (e1.load_date, e2.load_date) as load_date
, coalesce (e1.price, e2.price) as price
, e1.ema as ema15 ,e2.ema as ema40
from temp_daily_ema15 e1 
inner join temp_daily_ema40 e2
on e1.code = e2.code and e1.load_date = e2.load_date
ON CONFLICT (code, load_date) do nothing;


END;
';


--
-- Name: rush_1345_ema_on_ha(date); Type: FUNCTION; Schema: rtc; Owner: -
--

CREATE FUNCTION rtc.rush_1345_ema_on_ha(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists temp_daily_ema15;
create temp table temp_daily_ema15 as 
with quote as (
select q.code, q.close, q.load_date 
	, row_number() over(partition by code order by load_date desc)+1 as idx
	from cal.heikin_ashi q where load_date < c_date
union 
select code, h_close, load_date , 1 as idx
	from rtc.ha_1345 where load_date = c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 15-w.orders as new_order,  15-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema15''	
), temp as ( 
select code, (c_date)::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema, q.close as price
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =15
)select code, load_date, price, ema
from output ;

drop table if exists temp_daily_ema40;
create temp table temp_daily_ema40 as 
with quote as (
select q.code, q.close, q.load_date
	, row_number() over(partition by code order by load_date desc)+1 as idx
	from cal.heikin_ashi q where load_date < c_date
union 
select code, h_close, load_date , 1 as idx
	from rtc.ha_1345 where load_date = c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 40-w.orders as new_order,  40-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema40''	
), temp as ( 
select code, (c_date)::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema, q.close as price
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =40
)select code, load_date, price, ema
from output ;

insert into rtc.ema_on_ha_1345
select coalesce (e1.code, e2.code) as code
, coalesce (e1.load_date, e2.load_date) as load_date
, coalesce (e1.price, e2.price) as price
, e1.ema as ema15 ,e2.ema as ema40
from temp_daily_ema15 e1 
inner join temp_daily_ema40 e2
on e1.code = e2.code and e1.load_date = e2.load_date
ON CONFLICT (code, load_date) do nothing;


drop table if exists temp_daily_ema15;
drop table if exists temp_daily_ema40;

END;
';


--
-- Name: rush_1345_macd(date); Type: FUNCTION; Schema: rtc; Owner: -
--

CREATE FUNCTION rtc.rush_1345_macd(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN


insert into rtc.macd_1345  
with quote as (
select q.code, (q.ema15- q.ema40) as close, load_date
	, row_number() over(partition by code order by load_date desc)+1  as idx
	from cal.ha_ema q where load_date < c_date	
union	
select q.code, (q.ema15- q.ema40) as close, load_date
	, row_number() over(partition by code order by load_date desc) as idx
	from rtc.ema_on_ha_1345 q where load_date = c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 15-w.orders as new_order,  15-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema15''	
), temp as ( 
select code, c_date::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema as dea, q.close as diff
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =15
)select code, load_date, diff, dea, ''ha'' as chart_type
from output 
ON CONFLICT (code, load_date) do nothing;

END;
';


--
-- Name: rush_1345_trend(date); Type: FUNCTION; Schema: rtc; Owner: -
--

CREATE FUNCTION rtc.rush_1345_trend(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists current_ha;
create temp table current_ha as 
select * from cal.heikin_ashi 
	where load_date < c_date
	and load_date > c_date - 48 *7
union 
select * from rtc.ha_1345
	where load_date = c_date;
	
	

drop table if exists icompare;
create temp table icompare as 
with temp as (
select *
	, lag(open , 1 , null) over (partition by code order by load_date) as last_open
	, lag(close , 1 , null) over (partition by code order by load_date) as last_close
	, lead(open , 1 , null) over (partition by code order by load_date) as next_open
	, lead(close , 1 , null) over (partition by code order by load_date) as next_close
from current_ha 
), ientry as (
select * from temp 
where open <= close and last_open > last_close
), iclose as (
select * from temp 
where open <= close and next_open > next_close
), combine as (
select ie.code
	, ie.load_date as entry_date
	, ic.load_date as exit_date
	, row_number() over (partition by ie.code , ie.load_date order by ic.load_date ) as rnum
from ientry ie
inner join iclose ic
on ie.code = ic.code
where ie.load_date < ic.load_date
), period as (
select code, entry_date, exit_date
	, row_number() over (partition by code order by exit_date desc) as rnum
from combine where rnum =1
), subset as ( select t.*, p.rnum from temp t
inner join period p
on t.code = p.code 
where t.load_date >= p.entry_date
and t.load_date <= p.exit_date
) select code, rnum, max(close) as hpoint from subset
where rnum in (1,2)
group by code, rnum
order by code, rnum 
;		

drop table if exists dcompare;
create temp table dcompare as 
with temp as (
select *
	, lag(open , 1 , null) over (partition by code order by load_date) as last_open
	, lag(close , 1 , null) over (partition by code order by load_date) as last_close
	, lead(open , 1 , null) over (partition by code order by load_date) as next_open
	, lead(close , 1 , null) over (partition by code order by load_date) as next_close
from current_ha 
), ientry as (
select * from temp 
where open > close and last_open <= last_close
), iclose as (
select * from temp 
where open > close and next_open <= next_close
), combine as (
select ie.code
	, ie.load_date as entry_date
	, ic.load_date as exit_date
	, row_number() over (partition by ie.code , ie.load_date order by ic.load_date ) as rnum
from ientry ie
inner join iclose ic
on ie.code = ic.code
where ie.load_date < ic.load_date
), period as (
select code, entry_date, exit_date
	, row_number() over (partition by code order by exit_date desc) as rnum
from combine where rnum =1
), subset as ( select t.*, p.rnum from temp t
inner join period p
on t.code = p.code 
where t.load_date >= p.entry_date
and t.load_date <= p.exit_date
)select code, rnum, min(close) as lpoint from subset
where rnum in (1,2)
group by code, rnum
order by code, rnum ;	

drop table if exists itrend;
create temp table itrend as 
with dlist as (
select d1.code from dcompare d1
inner join dcompare d2
on d1.code = d2.code 
where d1.lpoint > d2.lpoint
and d1.rnum =1 and d2.rnum =2 
), ilist as (
select i1.code from icompare i1
inner join icompare i2
on i1.code = i2.code 
where i1.hpoint > i2.hpoint
and i1.rnum =1 and i2.rnum =2 
) select d.code from dlist d
inner join ilist i
on d.code = i.code ;

drop table if exists dtrend;
create temp table dtrend as 
with dlist as (
select d1.code from dcompare d1
inner join dcompare d2
on d1.code = d2.code 
where d1.lpoint < d2.lpoint
and d1.rnum =1 and d2.rnum =2 
), ilist as (
select i1.code from icompare i1
inner join icompare i2
on i1.code = i2.code 
where i1.hpoint < i2.hpoint
and i1.rnum =1 and i2.rnum =2 
) select d.code from dlist d
inner join ilist i
on d.code = i.code ;

insert into rtc.trend_1345
select code, c_date, ''i''
from itrend;


insert into rtc.trend_1345
select code, c_date, ''d''
from dtrend;

END;
';


--
-- Name: rush_1500_ema(date); Type: FUNCTION; Schema: rtc; Owner: -
--

CREATE FUNCTION rtc.rush_1500_ema(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists temp_daily_ema15;
create temp table temp_daily_ema15 as 
with quote as (
select q.code, q.close, q.load_date 
	, row_number() over(partition by code order by load_date desc)+1 as idx
	from vlt.quotes q where load_date < c_date
union 
select code, close, load_date , 1 as idx
	from vlt.rush_1500 where load_date = c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 15-w.orders as new_order,  15-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema15''	
), temp as ( 
select code, c_date::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema, q.close as price
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =15
)select code, load_date, price, ema
from output ;

drop table if exists temp_daily_ema40;
create temp table temp_daily_ema40 as 
with quote as (
select q.code, q.close, q.load_date
	, row_number() over(partition by code order by load_date desc)+1 as idx
	from vlt.quotes q where load_date < c_date
union 
select code, close, load_date , 1 as idx
	from vlt.rush_1500 where load_date = c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 40-w.orders as new_order,  40-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema40''	
), temp as ( 
select code, c_date::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema, q.close as price
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =40
)select code, load_date, price, ema
from output ;

insert into rtc.ema_1500
select coalesce (e1.code, e2.code) as code
, coalesce (e1.load_date, e2.load_date) as load_date
, coalesce (e1.price, e2.price) as price
, e1.ema as ema15 ,e2.ema as ema40
from temp_daily_ema15 e1 
inner join temp_daily_ema40 e2
on e1.code = e2.code and e1.load_date = e2.load_date
ON CONFLICT (code, load_date) do nothing;


END;
';


--
-- Name: rush_1500_ema_on_ha(date); Type: FUNCTION; Schema: rtc; Owner: -
--

CREATE FUNCTION rtc.rush_1500_ema_on_ha(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists temp_daily_ema15;
create temp table temp_daily_ema15 as 
with quote as (
select q.code, q.close, q.load_date 
	, row_number() over(partition by code order by load_date desc)+1 as idx
	from cal.heikin_ashi q where load_date < c_date
union 
select code, h_close, load_date , 1 as idx
	from rtc.ha_1500 where load_date = c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 15-w.orders as new_order,  15-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema15''	
), temp as ( 
select code, (c_date)::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema, q.close as price
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =15
)select code, load_date, price, ema
from output ;

drop table if exists temp_daily_ema40;
create temp table temp_daily_ema40 as 
with quote as (
select q.code, q.close, q.load_date
	, row_number() over(partition by code order by load_date desc)+1 as idx
	from cal.heikin_ashi q where load_date < c_date
union 
select code, h_close, load_date , 1 as idx
	from rtc.ha_1500 where load_date = c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 40-w.orders as new_order,  40-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema40''	
), temp as ( 
select code, (c_date)::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema, q.close as price
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =40
)select code, load_date, price, ema
from output ;

insert into rtc.ema_on_ha_1500
select coalesce (e1.code, e2.code) as code
, coalesce (e1.load_date, e2.load_date) as load_date
, coalesce (e1.price, e2.price) as price
, e1.ema as ema15 ,e2.ema as ema40
from temp_daily_ema15 e1 
inner join temp_daily_ema40 e2
on e1.code = e2.code and e1.load_date = e2.load_date
ON CONFLICT (code, load_date) do nothing;


drop table if exists temp_daily_ema15;
drop table if exists temp_daily_ema40;
END;
';


--
-- Name: rush_1500_macd(date); Type: FUNCTION; Schema: rtc; Owner: -
--

CREATE FUNCTION rtc.rush_1500_macd(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN


insert into rtc.macd_1500  
with quote as (
select q.code, (q.ema15- q.ema40) as close, load_date
	, row_number() over(partition by code order by load_date desc)+1  as idx
	from cal.ha_ema q where load_date < c_date	
union	
select q.code, (q.ema15- q.ema40) as close, load_date
	, row_number() over(partition by code order by load_date desc) as idx
	from rtc.ema_on_ha_1500 q where load_date = c_date
), subset as (
select code from quote where idx = 1 and load_date = c_date
), comb as (
select w.weight, 15-w.orders as new_order,  15-w.orders + q.idx as team , q.*
	from quote q inner join mtd.weight_maps w 
	on q.idx = w.orders+1
	inner join subset s
	on q.code = s.code
	where w.categories = ''ema15''	
), temp as ( 
select code, c_date::date as load_date
  	, sum(weight * close)::numeric(8,4) as ema
	, count(*) as cnt
 	from comb group by code
), output as (
select t.code, t.load_date, t.ema as dea, q.close as diff
 	from temp t inner join quote q 
	on t.code = q.code and t.load_date = q.load_date
	where t.cnt =15
)select code, load_date, diff, dea, ''ha'' as chart_type
from output 
ON CONFLICT (code, load_date) do nothing;

END;
';


--
-- Name: rush_1500_trend(date); Type: FUNCTION; Schema: rtc; Owner: -
--

CREATE FUNCTION rtc.rush_1500_trend(c_date date) RETURNS void
    LANGUAGE plpgsql
    AS '
BEGIN

drop table if exists current_ha;
create temp table current_ha as 
select * from cal.heikin_ashi 
	where load_date < c_date
	and load_date > c_date - 48 *7
union 
select * from rtc.ha_1500
	where load_date = c_date;
	
	

drop table if exists icompare;
create temp table icompare as 
with temp as (
select *
	, lag(open , 1 , null) over (partition by code order by load_date) as last_open
	, lag(close , 1 , null) over (partition by code order by load_date) as last_close
	, lead(open , 1 , null) over (partition by code order by load_date) as next_open
	, lead(close , 1 , null) over (partition by code order by load_date) as next_close
from current_ha 
), ientry as (
select * from temp 
where open <= close and last_open > last_close
), iclose as (
select * from temp 
where open <= close and next_open > next_close
), combine as (
select ie.code
	, ie.load_date as entry_date
	, ic.load_date as exit_date
	, row_number() over (partition by ie.code , ie.load_date order by ic.load_date ) as rnum
from ientry ie
inner join iclose ic
on ie.code = ic.code
where ie.load_date < ic.load_date
), period as (
select code, entry_date, exit_date
	, row_number() over (partition by code order by exit_date desc) as rnum
from combine where rnum =1
), subset as ( select t.*, p.rnum from temp t
inner join period p
on t.code = p.code 
where t.load_date >= p.entry_date
and t.load_date <= p.exit_date
) select code, rnum, max(close) as hpoint from subset
where rnum in (1,2)
group by code, rnum
order by code, rnum 
;		

drop table if exists dcompare;
create temp table dcompare as 
with temp as (
select *
	, lag(open , 1 , null) over (partition by code order by load_date) as last_open
	, lag(close , 1 , null) over (partition by code order by load_date) as last_close
	, lead(open , 1 , null) over (partition by code order by load_date) as next_open
	, lead(close , 1 , null) over (partition by code order by load_date) as next_close
from current_ha 
), ientry as (
select * from temp 
where open > close and last_open <= last_close
), iclose as (
select * from temp 
where open > close and next_open <= next_close
), combine as (
select ie.code
	, ie.load_date as entry_date
	, ic.load_date as exit_date
	, row_number() over (partition by ie.code , ie.load_date order by ic.load_date ) as rnum
from ientry ie
inner join iclose ic
on ie.code = ic.code
where ie.load_date < ic.load_date
), period as (
select code, entry_date, exit_date
	, row_number() over (partition by code order by exit_date desc) as rnum
from combine where rnum =1
), subset as ( select t.*, p.rnum from temp t
inner join period p
on t.code = p.code 
where t.load_date >= p.entry_date
and t.load_date <= p.exit_date
)select code, rnum, min(close) as lpoint from subset
where rnum in (1,2)
group by code, rnum
order by code, rnum ;	

drop table if exists itrend;
create temp table itrend as 
with dlist as (
select d1.code from dcompare d1
inner join dcompare d2
on d1.code = d2.code 
where d1.lpoint > d2.lpoint
and d1.rnum =1 and d2.rnum =2 
), ilist as (
select i1.code from icompare i1
inner join icompare i2
on i1.code = i2.code 
where i1.hpoint > i2.hpoint
and i1.rnum =1 and i2.rnum =2 
) select d.code from dlist d
inner join ilist i
on d.code = i.code ;

drop table if exists dtrend;
create temp table dtrend as 
with dlist as (
select d1.code from dcompare d1
inner join dcompare d2
on d1.code = d2.code 
where d1.lpoint < d2.lpoint
and d1.rnum =1 and d2.rnum =2 
), ilist as (
select i1.code from icompare i1
inner join icompare i2
on i1.code = i2.code 
where i1.hpoint < i2.hpoint
and i1.rnum =1 and i2.rnum =2 
) select d.code from dlist d
inner join ilist i
on d.code = i.code ;

insert into rtc.trend_1500
select code, c_date, ''i''
from itrend;


insert into rtc.trend_1500
select code, c_date, ''d''
from dtrend;

END;
';


--
-- Name: actionable_list; Type: TABLE; Schema: cal; Owner: -
--

CREATE TABLE cal.actionable_list (
    code character varying,
    load_date date,
    turnover integer,
    popularity integer,
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: ema; Type: TABLE; Schema: cal; Owner: -
--

CREATE TABLE cal.ema (
    code character varying,
    load_date date,
    price numeric(8,3),
    ema15 numeric(8,4),
    ema40 numeric(8,4),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: ema_on_ha_ranking; Type: TABLE; Schema: cal; Owner: -
--

CREATE TABLE cal.ema_on_ha_ranking (
    code character varying,
    load_date date,
    usage_direction character varying,
    semester_ratio numeric(5,4),
    quarter_ratio numeric(5,4)
);


--
-- Name: ema_on_sar_ranking; Type: TABLE; Schema: cal; Owner: -
--

CREATE TABLE cal.ema_on_sar_ranking (
    code character varying,
    load_date date,
    usage_direction character varying,
    semester_ratio numeric(5,4),
    quarter_ratio numeric(5,4)
);


--
-- Name: ema_trend; Type: TABLE; Schema: cal; Owner: -
--

CREATE TABLE cal.ema_trend (
    code character varying,
    load_date date,
    prc_e10_trend integer,
    prc_e10_direction integer,
    prc_e25_trend integer,
    prc_e25_direction integer,
    e10_e25_trend integer,
    e10_e25_direction integer,
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: ha_ema; Type: TABLE; Schema: cal; Owner: -
--

CREATE TABLE cal.ha_ema (
    code character varying,
    load_date date,
    price numeric(8,3),
    ema15 numeric(8,4),
    ema40 numeric(8,4),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: ha_ranking; Type: TABLE; Schema: cal; Owner: -
--

CREATE TABLE cal.ha_ranking (
    code character varying,
    load_date date,
    usage_direction character varying,
    semester_ratio numeric(5,4),
    quarter_ratio numeric(5,4),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: heikin_ashi; Type: TABLE; Schema: cal; Owner: -
--

CREATE TABLE cal.heikin_ashi (
    code character varying,
    load_date date,
    open numeric(7,3),
    high numeric(7,3),
    low numeric(7,3),
    close numeric(7,3),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: index_component; Type: TABLE; Schema: cal; Owner: -
--

CREATE TABLE cal.index_component (
    code character varying,
    load_date date
);


--
-- Name: index_component_history; Type: TABLE; Schema: cal; Owner: -
--

CREATE TABLE cal.index_component_history (
    code character varying,
    load_date date,
    open numeric(10,3),
    low numeric(10,3),
    high numeric(10,3),
    close numeric(10,3),
    turnover numeric(100,3),
    volume integer,
    market_cap numeric(21,2),
    typ3 numeric(10,3),
    typ4 numeric(10,3),
    match_price numeric(8,3),
    weight_ratio numeric(5,4),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: index_component_snapshot; Type: TABLE; Schema: cal; Owner: -
--

CREATE TABLE cal.index_component_snapshot (
    code character varying,
    load_date date,
    open numeric(10,3),
    low numeric(10,3),
    high numeric(10,3),
    close numeric(10,3),
    turnover numeric(100,3),
    volume integer,
    market_cap numeric(21,2),
    typ3 numeric(10,3),
    typ4 numeric(10,3),
    match_price numeric(8,3),
    weight_ratio numeric(5,4)
);


--
-- Name: index_direction; Type: TABLE; Schema: cal; Owner: -
--

CREATE TABLE cal.index_direction (
    category character varying,
    load_date date,
    s_open numeric,
    s_close numeric,
    s_high numeric,
    s_low numeric,
    h_open numeric,
    h_close numeric,
    h_high numeric,
    h_low numeric,
    ema25 numeric,
    ema10 numeric
);


--
-- Name: macd; Type: TABLE; Schema: cal; Owner: -
--

CREATE TABLE cal.macd (
    code character varying,
    load_date date,
    diff numeric,
    dea numeric(8,4),
    chart_type character varying,
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: sar; Type: TABLE; Schema: cal; Owner: -
--

CREATE TABLE cal.sar (
    code character varying,
    load_date date,
    extreme numeric(8,3),
    ud_trend character varying,
    af numeric(8,3),
    sar numeric(8,3),
    n_sar numeric(8,3),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: simple_moving_range; Type: TABLE; Schema: cal; Owner: -
--

CREATE TABLE cal.simple_moving_range (
    code character varying,
    load_date date,
    avg_range numeric(7,3),
    std_range numeric(7,3),
    avg_diff numeric(7,3),
    std_diff numeric(7,3),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: stb_on_ha_ranking; Type: TABLE; Schema: cal; Owner: -
--

CREATE TABLE cal.stb_on_ha_ranking (
    code character varying,
    load_date date,
    usage_direction character varying,
    semester_ratio numeric(12,3),
    quarter_ratio numeric(12,3)
);


--
-- Name: stb_on_sar_ranking; Type: TABLE; Schema: cal; Owner: -
--

CREATE TABLE cal.stb_on_sar_ranking (
    code character varying,
    load_date date,
    usage_direction character varying,
    semester_ratio numeric(12,3),
    quarter_ratio numeric(12,3)
);


--
-- Name: trading_days; Type: TABLE; Schema: cal; Owner: -
--

CREATE TABLE cal.trading_days (
    load_date date,
    semester_trading_days integer,
    quaterly_trading_days integer,
    monthly_trading_days integer,
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: v_ema_current; Type: VIEW; Schema: cal; Owner: -
--

CREATE VIEW cal.v_ema_current AS
 WITH temp AS (
         SELECT ema.code,
            ema.load_date,
            ema.price,
                CASE
                    WHEN (ema.ema15 >= ema.ema40) THEN 'BUY'::text
                    ELSE 'SELL'::text
                END AS indicator,
            concat(((((1)::numeric - (ema.ema15 / ema.price)) * (100)::numeric))::numeric(7,3), '%') AS ema10,
            concat(((((1)::numeric - (ema.ema40 / ema.price)) * (100)::numeric))::numeric(7,3), '%') AS ema25,
            row_number() OVER (PARTITION BY ema.code ORDER BY ema.load_date DESC) AS rnum
           FROM cal.ema
        )
 SELECT temp.code,
    temp.load_date,
    temp.indicator,
    temp.price,
    concat(temp.ema10, ' ~ ', temp.ema25) AS ema
   FROM temp
  WHERE (temp.rnum = 1);


--
-- Name: code_category; Type: TABLE; Schema: mtd; Owner: -
--

CREATE TABLE mtd.code_category (
    code character varying,
    category character varying
);


--
-- Name: v_ema_on_ha_long_current; Type: VIEW; Schema: cal; Owner: -
--

CREATE VIEW cal.v_ema_on_ha_long_current AS
 WITH temp AS (
         SELECT ema_on_ha_ranking.code,
            ema_on_ha_ranking.load_date,
            ema_on_ha_ranking.usage_direction,
            ema_on_ha_ranking.semester_ratio,
            ema_on_ha_ranking.quarter_ratio,
            row_number() OVER (PARTITION BY ema_on_ha_ranking.code, ema_on_ha_ranking.usage_direction ORDER BY ema_on_ha_ranking.load_date DESC) AS rnum
           FROM cal.ema_on_ha_ranking
          WHERE ((ema_on_ha_ranking.semester_ratio IS NOT NULL) AND (ema_on_ha_ranking.quarter_ratio IS NOT NULL))
        ), ranking AS (
         SELECT c.category,
            t.code,
            t.load_date,
            t.usage_direction,
            t.semester_ratio,
            t.quarter_ratio,
            t.rnum,
            row_number() OVER (ORDER BY t.semester_ratio DESC) AS sr,
            row_number() OVER (ORDER BY t.quarter_ratio DESC) AS qr
           FROM ((temp t
             JOIN cal.actionable_list a ON (((t.code)::text = (a.code)::text)))
             JOIN mtd.code_category c ON ((((t.code)::text = (c.code)::text) AND (a.load_date = t.load_date))))
          WHERE ((t.rnum = 1) AND ((t.usage_direction)::text = 'long_end'::text) AND (a.turnover <> 4) AND (a.popularity <> 4))
        )
 SELECT ranking.category,
    ranking.code,
    ranking.load_date,
    rank() OVER (ORDER BY ((ranking.sr * 2) + ranking.qr)) AS total_ranking,
    rank() OVER (PARTITION BY ranking.category ORDER BY ((ranking.sr * 2) + ranking.qr)) AS category_ranking
   FROM ranking
  WHERE (ranking.load_date > (CURRENT_DATE - 28))
  ORDER BY (rank() OVER (ORDER BY ((ranking.sr * 2) + ranking.qr))), (rank() OVER (PARTITION BY ranking.category ORDER BY ((ranking.sr * 2) + ranking.qr)));


--
-- Name: v_ema_on_ha_short_current; Type: VIEW; Schema: cal; Owner: -
--

CREATE VIEW cal.v_ema_on_ha_short_current AS
 WITH temp AS (
         SELECT ema_on_ha_ranking.code,
            ema_on_ha_ranking.load_date,
            ema_on_ha_ranking.usage_direction,
            ema_on_ha_ranking.semester_ratio,
            ema_on_ha_ranking.quarter_ratio,
            row_number() OVER (PARTITION BY ema_on_ha_ranking.code, ema_on_ha_ranking.usage_direction ORDER BY ema_on_ha_ranking.load_date DESC) AS rnum
           FROM cal.ema_on_ha_ranking
          WHERE ((ema_on_ha_ranking.semester_ratio IS NOT NULL) AND (ema_on_ha_ranking.quarter_ratio IS NOT NULL))
        ), ranking AS (
         SELECT c.category,
            t.code,
            t.load_date,
            t.usage_direction,
            t.semester_ratio,
            t.quarter_ratio,
            t.rnum,
            row_number() OVER (ORDER BY t.semester_ratio) AS sr,
            row_number() OVER (ORDER BY t.quarter_ratio) AS qr
           FROM ((temp t
             JOIN cal.actionable_list a ON (((t.code)::text = (a.code)::text)))
             JOIN mtd.code_category c ON ((((t.code)::text = (c.code)::text) AND (a.load_date = t.load_date))))
          WHERE ((t.rnum = 1) AND ((t.usage_direction)::text = 'short_end'::text) AND (a.turnover <> 4) AND (a.popularity <> 4))
        )
 SELECT ranking.category,
    ranking.code,
    ranking.load_date,
    rank() OVER (ORDER BY ((ranking.sr * 2) + ranking.qr)) AS total_ranking,
    rank() OVER (PARTITION BY ranking.category ORDER BY ((ranking.sr * 2) + ranking.qr)) AS category_ranking
   FROM ranking
  WHERE (ranking.load_date > (CURRENT_DATE - 28))
  ORDER BY (rank() OVER (ORDER BY ((ranking.sr * 2) + ranking.qr))), (rank() OVER (PARTITION BY ranking.category ORDER BY ((ranking.sr * 2) + ranking.qr)));


--
-- Name: v_ema_on_sar_long_current; Type: VIEW; Schema: cal; Owner: -
--

CREATE VIEW cal.v_ema_on_sar_long_current AS
 WITH temp AS (
         SELECT ema_on_sar_ranking.code,
            ema_on_sar_ranking.load_date,
            ema_on_sar_ranking.usage_direction,
            ema_on_sar_ranking.semester_ratio,
            ema_on_sar_ranking.quarter_ratio,
            row_number() OVER (PARTITION BY ema_on_sar_ranking.code, ema_on_sar_ranking.usage_direction ORDER BY ema_on_sar_ranking.load_date DESC) AS rnum
           FROM cal.ema_on_sar_ranking
          WHERE ((ema_on_sar_ranking.semester_ratio IS NOT NULL) AND (ema_on_sar_ranking.quarter_ratio IS NOT NULL))
        ), ranking AS (
         SELECT c.category,
            t.code,
            t.load_date,
            t.usage_direction,
            t.semester_ratio,
            t.quarter_ratio,
            t.rnum,
            row_number() OVER (ORDER BY t.semester_ratio DESC) AS sr,
            row_number() OVER (ORDER BY t.quarter_ratio DESC) AS qr
           FROM ((temp t
             JOIN cal.actionable_list a ON (((t.code)::text = (a.code)::text)))
             JOIN mtd.code_category c ON ((((t.code)::text = (c.code)::text) AND (a.load_date = t.load_date))))
          WHERE ((t.rnum = 1) AND ((t.usage_direction)::text = 'long_end'::text) AND (a.turnover <> 4) AND (a.popularity <> 4))
        )
 SELECT ranking.category,
    ranking.code,
    ranking.load_date,
    rank() OVER (ORDER BY ((ranking.sr * 2) + ranking.qr)) AS total_ranking,
    rank() OVER (PARTITION BY ranking.category ORDER BY ((ranking.sr * 2) + ranking.qr)) AS category_ranking
   FROM ranking
  WHERE (ranking.load_date > (CURRENT_DATE - 28))
  ORDER BY (rank() OVER (ORDER BY ((ranking.sr * 2) + ranking.qr))), (rank() OVER (PARTITION BY ranking.category ORDER BY ((ranking.sr * 2) + ranking.qr)));


--
-- Name: v_ema_on_sar_short_current; Type: VIEW; Schema: cal; Owner: -
--

CREATE VIEW cal.v_ema_on_sar_short_current AS
 WITH temp AS (
         SELECT ema_on_sar_ranking.code,
            ema_on_sar_ranking.load_date,
            ema_on_sar_ranking.usage_direction,
            ema_on_sar_ranking.semester_ratio,
            ema_on_sar_ranking.quarter_ratio,
            row_number() OVER (PARTITION BY ema_on_sar_ranking.code, ema_on_sar_ranking.usage_direction ORDER BY ema_on_sar_ranking.load_date DESC) AS rnum
           FROM cal.ema_on_sar_ranking
          WHERE ((ema_on_sar_ranking.semester_ratio IS NOT NULL) AND (ema_on_sar_ranking.quarter_ratio IS NOT NULL))
        ), ranking AS (
         SELECT c.category,
            t.code,
            t.load_date,
            t.usage_direction,
            t.semester_ratio,
            t.quarter_ratio,
            t.rnum,
            row_number() OVER (ORDER BY t.semester_ratio) AS sr,
            row_number() OVER (ORDER BY t.quarter_ratio) AS qr
           FROM ((temp t
             JOIN cal.actionable_list a ON (((t.code)::text = (a.code)::text)))
             JOIN mtd.code_category c ON ((((t.code)::text = (c.code)::text) AND (a.load_date = t.load_date))))
          WHERE ((t.rnum = 1) AND ((t.usage_direction)::text = 'short_end'::text) AND (a.turnover <> 4) AND (a.popularity <> 4))
        )
 SELECT ranking.category,
    ranking.code,
    ranking.load_date,
    rank() OVER (ORDER BY ((ranking.sr * 2) + ranking.qr)) AS total_ranking,
    rank() OVER (PARTITION BY ranking.category ORDER BY ((ranking.sr * 2) + ranking.qr)) AS category_ranking
   FROM ranking
  WHERE (ranking.load_date > (CURRENT_DATE - 28))
  ORDER BY (rank() OVER (ORDER BY ((ranking.sr * 2) + ranking.qr))), (rank() OVER (PARTITION BY ranking.category ORDER BY ((ranking.sr * 2) + ranking.qr)));


--
-- Name: v_stb_on_ha_long_current; Type: VIEW; Schema: cal; Owner: -
--

CREATE VIEW cal.v_stb_on_ha_long_current AS
 WITH temp AS (
         SELECT stb_on_ha_ranking.code,
            stb_on_ha_ranking.load_date,
            stb_on_ha_ranking.usage_direction,
            stb_on_ha_ranking.semester_ratio,
            stb_on_ha_ranking.quarter_ratio,
            row_number() OVER (PARTITION BY stb_on_ha_ranking.code, stb_on_ha_ranking.usage_direction ORDER BY stb_on_ha_ranking.load_date DESC) AS rnum
           FROM cal.stb_on_ha_ranking
          WHERE ((stb_on_ha_ranking.semester_ratio IS NOT NULL) AND (stb_on_ha_ranking.quarter_ratio IS NOT NULL))
        ), ranking AS (
         SELECT c.category,
            t.code,
            t.load_date,
            t.usage_direction,
            t.semester_ratio,
            t.quarter_ratio,
            t.rnum,
            row_number() OVER (ORDER BY t.semester_ratio) AS sr,
            row_number() OVER (ORDER BY t.quarter_ratio) AS qr
           FROM ((temp t
             JOIN cal.actionable_list a ON (((t.code)::text = (a.code)::text)))
             JOIN mtd.code_category c ON ((((t.code)::text = (c.code)::text) AND (a.load_date = t.load_date))))
          WHERE ((t.rnum = 1) AND ((t.usage_direction)::text = 'long_end'::text) AND (a.turnover <> 4) AND (a.popularity <> 4))
        )
 SELECT ranking.category,
    ranking.code,
    ranking.load_date,
    rank() OVER (ORDER BY ((ranking.sr * 2) + ranking.qr)) AS total_ranking,
    rank() OVER (PARTITION BY ranking.category ORDER BY ((ranking.sr * 2) + ranking.qr)) AS category_ranking
   FROM ranking
  WHERE (ranking.load_date > (CURRENT_DATE - 28))
  ORDER BY (rank() OVER (ORDER BY ((ranking.sr * 2) + ranking.qr))), (rank() OVER (PARTITION BY ranking.category ORDER BY ((ranking.sr * 2) + ranking.qr)));


--
-- Name: v_stb_on_sar_long_current; Type: VIEW; Schema: cal; Owner: -
--

CREATE VIEW cal.v_stb_on_sar_long_current AS
 WITH temp AS (
         SELECT stb_on_sar_ranking.code,
            stb_on_sar_ranking.load_date,
            stb_on_sar_ranking.usage_direction,
            stb_on_sar_ranking.semester_ratio,
            stb_on_sar_ranking.quarter_ratio,
            row_number() OVER (PARTITION BY stb_on_sar_ranking.code, stb_on_sar_ranking.usage_direction ORDER BY stb_on_sar_ranking.load_date DESC) AS rnum
           FROM cal.stb_on_sar_ranking
          WHERE ((stb_on_sar_ranking.semester_ratio IS NOT NULL) AND (stb_on_sar_ranking.quarter_ratio IS NOT NULL))
        ), ranking AS (
         SELECT c.category,
            t.code,
            t.load_date,
            t.usage_direction,
            t.semester_ratio,
            t.quarter_ratio,
            t.rnum,
            row_number() OVER (ORDER BY t.semester_ratio) AS sr,
            row_number() OVER (ORDER BY t.quarter_ratio) AS qr
           FROM ((temp t
             JOIN cal.actionable_list a ON (((t.code)::text = (a.code)::text)))
             JOIN mtd.code_category c ON ((((t.code)::text = (c.code)::text) AND (a.load_date = t.load_date))))
          WHERE ((t.rnum = 1) AND ((t.usage_direction)::text = 'long_end'::text) AND (a.turnover <> 4) AND (a.popularity <> 4))
        )
 SELECT ranking.category,
    ranking.code,
    ranking.load_date,
    rank() OVER (ORDER BY ((ranking.sr * 2) + ranking.qr)) AS total_ranking,
    rank() OVER (PARTITION BY ranking.category ORDER BY ((ranking.sr * 2) + ranking.qr)) AS category_ranking
   FROM ranking
  WHERE (ranking.load_date > (CURRENT_DATE - 28))
  ORDER BY (rank() OVER (ORDER BY ((ranking.sr * 2) + ranking.qr))), (rank() OVER (PARTITION BY ranking.category ORDER BY ((ranking.sr * 2) + ranking.qr)));


--
-- Name: v_full_long_current; Type: VIEW; Schema: cal; Owner: -
--

CREATE VIEW cal.v_full_long_current AS
 WITH temp AS (
         SELECT eh.category,
            eh.code,
            GREATEST(eh.load_date, es.load_date, sh.load_date, ss.load_date) AS last_update_date,
            (((eh.total_ranking + es.total_ranking) + sh.total_ranking) + ss.total_ranking) AS total_ranking,
            (((eh.category_ranking + es.category_ranking) + sh.category_ranking) + ss.category_ranking) AS category_ranking
           FROM (((cal.v_ema_on_ha_long_current eh
             JOIN cal.v_ema_on_sar_long_current es ON (((eh.code)::text = (es.code)::text)))
             JOIN cal.v_stb_on_ha_long_current sh ON (((eh.code)::text = (sh.code)::text)))
             JOIN cal.v_stb_on_sar_long_current ss ON (((eh.code)::text = (ss.code)::text)))
        ), output AS (
         SELECT temp.category,
            temp.code,
            temp.last_update_date,
            row_number() OVER (ORDER BY temp.total_ranking) AS total_ranking,
            row_number() OVER (PARTITION BY temp.category ORDER BY temp.category_ranking) AS category_ranking
           FROM temp
        )
 SELECT output.category,
    output.code,
    output.last_update_date,
    output.total_ranking,
    output.category_ranking
   FROM output;


--
-- Name: v_stb_on_ha_short_current; Type: VIEW; Schema: cal; Owner: -
--

CREATE VIEW cal.v_stb_on_ha_short_current AS
 WITH temp AS (
         SELECT stb_on_ha_ranking.code,
            stb_on_ha_ranking.load_date,
            stb_on_ha_ranking.usage_direction,
            stb_on_ha_ranking.semester_ratio,
            stb_on_ha_ranking.quarter_ratio,
            row_number() OVER (PARTITION BY stb_on_ha_ranking.code, stb_on_ha_ranking.usage_direction ORDER BY stb_on_ha_ranking.load_date DESC) AS rnum
           FROM cal.stb_on_ha_ranking
          WHERE ((stb_on_ha_ranking.semester_ratio IS NOT NULL) AND (stb_on_ha_ranking.quarter_ratio IS NOT NULL))
        ), ranking AS (
         SELECT c.category,
            t.code,
            t.load_date,
            t.usage_direction,
            t.semester_ratio,
            t.quarter_ratio,
            t.rnum,
            row_number() OVER (ORDER BY t.semester_ratio DESC) AS sr,
            row_number() OVER (ORDER BY t.quarter_ratio DESC) AS qr
           FROM ((temp t
             JOIN cal.actionable_list a ON (((t.code)::text = (a.code)::text)))
             JOIN mtd.code_category c ON ((((t.code)::text = (c.code)::text) AND (a.load_date = t.load_date))))
          WHERE ((t.rnum = 1) AND ((t.usage_direction)::text = 'short_end'::text) AND (a.turnover <> 4) AND (a.popularity <> 4))
        )
 SELECT ranking.category,
    ranking.code,
    ranking.load_date,
    rank() OVER (ORDER BY ((ranking.sr * 2) + ranking.qr)) AS total_ranking,
    rank() OVER (PARTITION BY ranking.category ORDER BY ((ranking.sr * 2) + ranking.qr)) AS category_ranking
   FROM ranking
  WHERE (ranking.load_date > (CURRENT_DATE - 28))
  ORDER BY (rank() OVER (ORDER BY ((ranking.sr * 2) + ranking.qr))), (rank() OVER (PARTITION BY ranking.category ORDER BY ((ranking.sr * 2) + ranking.qr)));


--
-- Name: v_stb_on_sar_short_current; Type: VIEW; Schema: cal; Owner: -
--

CREATE VIEW cal.v_stb_on_sar_short_current AS
 WITH temp AS (
         SELECT stb_on_sar_ranking.code,
            stb_on_sar_ranking.load_date,
            stb_on_sar_ranking.usage_direction,
            stb_on_sar_ranking.semester_ratio,
            stb_on_sar_ranking.quarter_ratio,
            row_number() OVER (PARTITION BY stb_on_sar_ranking.code, stb_on_sar_ranking.usage_direction ORDER BY stb_on_sar_ranking.load_date DESC) AS rnum
           FROM cal.stb_on_sar_ranking
          WHERE ((stb_on_sar_ranking.semester_ratio IS NOT NULL) AND (stb_on_sar_ranking.quarter_ratio IS NOT NULL))
        ), ranking AS (
         SELECT c.category,
            t.code,
            t.load_date,
            t.usage_direction,
            t.semester_ratio,
            t.quarter_ratio,
            t.rnum,
            row_number() OVER (ORDER BY t.semester_ratio DESC) AS sr,
            row_number() OVER (ORDER BY t.quarter_ratio DESC) AS qr
           FROM ((temp t
             JOIN cal.actionable_list a ON (((t.code)::text = (a.code)::text)))
             JOIN mtd.code_category c ON ((((t.code)::text = (c.code)::text) AND (a.load_date = t.load_date))))
          WHERE ((t.rnum = 1) AND ((t.usage_direction)::text = 'short_end'::text) AND (a.turnover <> 4) AND (a.popularity <> 4))
        )
 SELECT ranking.category,
    ranking.code,
    ranking.load_date,
    rank() OVER (ORDER BY ((ranking.sr * 2) + ranking.qr)) AS total_ranking,
    rank() OVER (PARTITION BY ranking.category ORDER BY ((ranking.sr * 2) + ranking.qr)) AS category_ranking
   FROM ranking
  WHERE (ranking.load_date > (CURRENT_DATE - 28))
  ORDER BY (rank() OVER (ORDER BY ((ranking.sr * 2) + ranking.qr))), (rank() OVER (PARTITION BY ranking.category ORDER BY ((ranking.sr * 2) + ranking.qr)));


--
-- Name: v_full_short_current; Type: VIEW; Schema: cal; Owner: -
--

CREATE VIEW cal.v_full_short_current AS
 WITH temp AS (
         SELECT eh.category,
            eh.code,
            GREATEST(eh.load_date, es.load_date, sh.load_date, ss.load_date) AS last_update_date,
            (((eh.total_ranking + es.total_ranking) + sh.total_ranking) + ss.total_ranking) AS total_ranking,
            (((eh.category_ranking + es.category_ranking) + sh.category_ranking) + ss.category_ranking) AS category_ranking
           FROM (((cal.v_ema_on_ha_short_current eh
             JOIN cal.v_ema_on_sar_short_current es ON (((eh.code)::text = (es.code)::text)))
             JOIN cal.v_stb_on_ha_short_current sh ON (((eh.code)::text = (sh.code)::text)))
             JOIN cal.v_stb_on_sar_short_current ss ON (((eh.code)::text = (ss.code)::text)))
        ), output AS (
         SELECT temp.category,
            temp.code,
            temp.last_update_date,
            row_number() OVER (ORDER BY temp.total_ranking) AS total_ranking,
            row_number() OVER (PARTITION BY temp.category ORDER BY temp.category_ranking) AS category_ranking
           FROM temp
        )
 SELECT output.category,
    output.code,
    output.last_update_date,
    output.total_ranking,
    output.category_ranking
   FROM output;


--
-- Name: v_ha_current; Type: VIEW; Schema: cal; Owner: -
--

CREATE VIEW cal.v_ha_current AS
 WITH temp AS (
         SELECT heikin_ashi.code,
            heikin_ashi.load_date,
                CASE
                    WHEN ((heikin_ashi.close >= heikin_ashi.open) AND (heikin_ashi.open = heikin_ashi.low)) THEN 'Positive'::text
                    WHEN ((heikin_ashi.close < heikin_ashi.open) AND (heikin_ashi.open = heikin_ashi.high)) THEN 'Negative'::text
                    WHEN (heikin_ashi.close >= heikin_ashi.open) THEN 'Long'::text
                    WHEN (heikin_ashi.close < heikin_ashi.open) THEN 'Short'::text
                    ELSE NULL::text
                END AS status,
            heikin_ashi.open,
            heikin_ashi.close,
            heikin_ashi.low,
            heikin_ashi.high,
            lag(heikin_ashi.open, 1) OVER (PARTITION BY heikin_ashi.code ORDER BY heikin_ashi.load_date) AS last_open,
            lag(heikin_ashi.close, 1) OVER (PARTITION BY heikin_ashi.code ORDER BY heikin_ashi.load_date) AS last_close,
            row_number() OVER (PARTITION BY heikin_ashi.code ORDER BY heikin_ashi.load_date DESC) AS rnum
           FROM cal.heikin_ashi
        )
 SELECT temp.code,
    temp.load_date,
    temp.status,
        CASE
            WHEN (((temp.last_close >= temp.last_open) AND (temp.close < temp.open)) OR ((temp.last_close < temp.last_open) AND (temp.close >= temp.open))) THEN 'Reverse'::text
            ELSE 'Continuously'::text
        END AS trend
   FROM temp
  WHERE (temp.rnum = 1);


--
-- Name: v_ha_sequence_current; Type: VIEW; Schema: cal; Owner: -
--

CREATE VIEW cal.v_ha_sequence_current AS
 WITH idx AS (
         SELECT heikin_ashi.load_date,
            row_number() OVER (ORDER BY heikin_ashi.load_date DESC) AS rnum
           FROM cal.heikin_ashi
          GROUP BY heikin_ashi.load_date
        ), ext AS (
         SELECT heikin_ashi.code,
            heikin_ashi.load_date,
            heikin_ashi.open,
            heikin_ashi.high,
            heikin_ashi.low,
            heikin_ashi.close,
            heikin_ashi.sys_load_time,
            lag(heikin_ashi.open, 1) OVER (PARTITION BY heikin_ashi.code ORDER BY heikin_ashi.load_date) AS last_open,
            lag(heikin_ashi.close, 1) OVER (PARTITION BY heikin_ashi.code ORDER BY heikin_ashi.load_date) AS last_close
           FROM cal.heikin_ashi
        ), list AS (
         SELECT ext.code,
            ext.load_date,
            ext.open,
            ext.high,
            ext.low,
            ext.close,
            ext.sys_load_time,
            ext.last_open,
            ext.last_close,
            row_number() OVER (PARTITION BY ext.code ORDER BY ext.load_date DESC) AS rnum
           FROM ext
          WHERE (((ext.open <= ext.close) AND (ext.last_open > ext.last_close)) OR ((ext.open > ext.close) AND (ext.last_open <= ext.last_close)))
        ), cur AS (
         SELECT heikin_ashi.code,
            heikin_ashi.load_date,
            heikin_ashi.open,
            heikin_ashi.high,
            heikin_ashi.low,
            heikin_ashi.close,
            heikin_ashi.sys_load_time,
                CASE
                    WHEN ((heikin_ashi.close >= heikin_ashi.open) AND (heikin_ashi.open = heikin_ashi.low)) THEN 'Positive'::text
                    WHEN ((heikin_ashi.close < heikin_ashi.open) AND (heikin_ashi.open = heikin_ashi.high)) THEN 'Negative'::text
                    WHEN ((heikin_ashi.close >= heikin_ashi.open) AND (heikin_ashi.open > heikin_ashi.low)) THEN 'Long'::text
                    WHEN ((heikin_ashi.close < heikin_ashi.open) AND (heikin_ashi.open < heikin_ashi.high)) THEN 'Short'::text
                    ELSE NULL::text
                END AS status
           FROM cal.heikin_ashi
          WHERE (heikin_ashi.load_date = ( SELECT max(heikin_ashi_1.load_date) AS max
                   FROM cal.heikin_ashi heikin_ashi_1))
        ), comb AS (
         SELECT l.code,
            l.load_date,
            i.rnum AS sequence
           FROM (list l
             JOIN idx i ON ((l.load_date = i.load_date)))
          WHERE (l.rnum = 1)
        ), output AS (
         SELECT b.code,
            c.load_date,
            b.sequence,
            c.status
           FROM (cur c
             JOIN comb b ON (((c.code)::text = (b.code)::text)))
        )
 SELECT output.code,
    output.load_date,
    output.sequence,
    output.status
   FROM output
  ORDER BY output.code;


--
-- Name: v_sar_current; Type: VIEW; Schema: cal; Owner: -
--

CREATE VIEW cal.v_sar_current AS
 WITH temp AS (
         SELECT sar.code,
            sar.load_date,
            sar.ud_trend,
            sar.n_sar,
            row_number() OVER (PARTITION BY sar.code ORDER BY sar.load_date DESC) AS rnum
           FROM cal.sar
        )
 SELECT temp.code,
    temp.load_date,
    temp.ud_trend,
    temp.n_sar
   FROM temp
  WHERE (temp.rnum = 1);


--
-- Name: volume_bands; Type: TABLE; Schema: cal; Owner: -
--

CREATE TABLE cal.volume_bands (
    code character varying,
    load_date date,
    volume integer,
    avg_volume integer,
    std_volume integer,
    benchmark integer,
    flag integer
);


--
-- Name: v_volume_current; Type: VIEW; Schema: cal; Owner: -
--

CREATE VIEW cal.v_volume_current AS
 WITH temp AS (
         SELECT volume_bands.code,
            volume_bands.load_date,
            volume_bands.volume,
            volume_bands.avg_volume,
            volume_bands.std_volume,
            volume_bands.benchmark,
            volume_bands.flag,
            (((volume_bands.volume)::numeric / (volume_bands.avg_volume)::numeric))::numeric(7,3) AS ratio,
                CASE
                    WHEN (volume_bands.volume >= (volume_bands.avg_volume + (3 * volume_bands.std_volume))) THEN 3
                    WHEN (volume_bands.volume >= (volume_bands.avg_volume + (2 * volume_bands.std_volume))) THEN 2
                    WHEN (volume_bands.volume >= (volume_bands.avg_volume + (1 * volume_bands.std_volume))) THEN 1
                    ELSE 0
                END AS range,
            row_number() OVER (PARTITION BY volume_bands.code ORDER BY volume_bands.load_date DESC) AS rnum
           FROM cal.volume_bands
        )
 SELECT temp.code,
    temp.load_date,
    temp.volume,
    temp.avg_volume,
    temp.std_volume,
    temp.ratio,
    temp.range
   FROM temp
  WHERE (temp.rnum = 1);


--
-- Name: quotes; Type: TABLE; Schema: vlt; Owner: -
--

CREATE TABLE vlt.quotes (
    code character varying,
    load_date date,
    open numeric(8,3),
    low numeric(8,3),
    high numeric(8,3),
    close numeric(8,3),
    pclose numeric(8,3),
    volume integer,
    turnover numeric(16,3),
    market_cap numeric(21,2),
    ask numeric(8,3),
    bid numeric(8,3),
    daily_change numeric(8,4),
    typ3 numeric(8,3),
    typ4 numeric(8,3)
);


--
-- Name: v_volume_osc; Type: VIEW; Schema: cal; Owner: -
--

CREATE VIEW cal.v_volume_osc AS
 WITH temp AS (
         SELECT quotes.code,
            quotes.load_date,
            avg(quotes.volume) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date DESC ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS short_avg,
            avg(quotes.volume) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date DESC ROWS BETWEEN CURRENT ROW AND 4 FOLLOWING) AS long_avg
           FROM vlt.quotes
        )
 SELECT temp.code,
    temp.load_date,
    (temp.short_avg)::numeric(16,2) AS short_avg,
    (temp.long_avg)::numeric(16,2) AS long_avg,
    ((((temp.short_avg - temp.long_avg) / temp.long_avg) * (100)::numeric))::numeric(8,4) AS vos
   FROM temp;


--
-- Name: actionable_list; Type: TABLE; Schema: mnp; Owner: -
--

CREATE TABLE mnp.actionable_list (
    code character varying,
    load_date date,
    turnover integer,
    popularity integer,
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: ema; Type: TABLE; Schema: mnp; Owner: -
--

CREATE TABLE mnp.ema (
    code character varying,
    load_date date,
    price numeric(8,3),
    ema15 numeric(8,4),
    ema40 numeric(8,4)
);


--
-- Name: ema_trend; Type: TABLE; Schema: mnp; Owner: -
--

CREATE TABLE mnp.ema_trend (
    code character varying,
    load_date date,
    trend_period bigint
);


--
-- Name: quarterly_trend_direction_source; Type: TABLE; Schema: mnp; Owner: -
--

CREATE TABLE mnp.quarterly_trend_direction_source (
    category character varying,
    code character varying,
    load_date date,
    rec bigint,
    pe2 numeric(5,3),
    pe5 numeric(5,3),
    e2e5 numeric(5,3),
    turnover integer,
    popularity integer,
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: quarterly_trend_stability_list; Type: TABLE; Schema: mnp; Owner: -
--

CREATE TABLE mnp.quarterly_trend_stability_list (
    category character varying,
    code character varying,
    load_date date,
    ratio numeric(12,3),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: sar; Type: TABLE; Schema: mnp; Owner: -
--

CREATE TABLE mnp.sar (
    code character varying,
    load_date date,
    extreme2 numeric(8,3),
    ud_trend2 character varying,
    af2 numeric(8,3),
    sar2 numeric(8,3),
    n_sar2 numeric(8,3),
    extreme3 numeric(8,3),
    ud_trend3 character varying,
    af3 numeric(8,3),
    sar3 numeric(8,3),
    n_sar3 numeric(8,3)
);


--
-- Name: semester_trend_direction_source; Type: TABLE; Schema: mnp; Owner: -
--

CREATE TABLE mnp.semester_trend_direction_source (
    category character varying,
    code character varying,
    load_date date,
    rec bigint,
    pe2 numeric(5,3),
    pe5 numeric(5,3),
    e2e5 numeric(5,3),
    turnover integer,
    popularity integer,
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: semester_trend_stability_list; Type: TABLE; Schema: mnp; Owner: -
--

CREATE TABLE mnp.semester_trend_stability_list (
    category character varying,
    code character varying,
    load_date date,
    ratio numeric(12,3),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: simple_moving_range; Type: TABLE; Schema: mnp; Owner: -
--

CREATE TABLE mnp.simple_moving_range (
    code character varying,
    latest_date date,
    avg_range numeric(6,3),
    std_range numeric(6,3),
    avg_diff numeric(6,3),
    std_diff numeric(6,3),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: v_current_actionable_list; Type: VIEW; Schema: mnp; Owner: -
--

CREATE VIEW mnp.v_current_actionable_list AS
 SELECT actionable_list.code,
    actionable_list.load_date,
    actionable_list.turnover,
    actionable_list.popularity,
    actionable_list.sys_load_time
   FROM mnp.actionable_list
  WHERE ((actionable_list.load_date = ( SELECT max(actionable_list_1.load_date) AS max
           FROM mnp.actionable_list actionable_list_1)) AND ((actionable_list.turnover <> 4) OR (actionable_list.popularity <> 4)));


--
-- Name: v_current_simple_moving_range; Type: VIEW; Schema: mnp; Owner: -
--

CREATE VIEW mnp.v_current_simple_moving_range AS
 SELECT simple_moving_range.code,
    simple_moving_range.latest_date,
    simple_moving_range.avg_range,
    simple_moving_range.std_range,
    simple_moving_range.avg_diff,
    simple_moving_range.std_diff,
    simple_moving_range.sys_load_time
   FROM mnp.simple_moving_range
  WHERE ((simple_moving_range.avg_range IS NOT NULL) AND (simple_moving_range.avg_diff IS NOT NULL) AND (simple_moving_range.latest_date = ( SELECT max(simple_moving_range_1.latest_date) AS max
           FROM mnp.simple_moving_range simple_moving_range_1)));


--
-- Name: v_idx; Type: VIEW; Schema: vlt; Owner: -
--

CREATE VIEW vlt.v_idx AS
 SELECT quotes.load_date,
    row_number() OVER (ORDER BY quotes.load_date DESC) AS rnum
   FROM vlt.quotes
  GROUP BY quotes.load_date;


--
-- Name: v_ema_trend; Type: VIEW; Schema: mnp; Owner: -
--

CREATE VIEW mnp.v_ema_trend AS
 WITH temp AS (
         SELECT ema.code,
            ema.load_date,
            ema.price,
            ema.ema15,
            ema.ema40,
            lag(ema.ema15, 1) OVER (PARTITION BY ema.code ORDER BY ema.load_date) AS last_ema15,
            lag(ema.ema40, 1) OVER (PARTITION BY ema.code ORDER BY ema.load_date) AS last_ema40
           FROM mnp.ema
        ), utrend AS (
         SELECT temp.code,
            temp.load_date,
            temp.price,
            temp.ema15,
            temp.ema40,
            temp.last_ema15,
            temp.last_ema40,
            row_number() OVER (PARTITION BY temp.code ORDER BY temp.load_date DESC) AS rnum
           FROM temp
          WHERE ((temp.ema15 > temp.ema40) AND (temp.last_ema15 <= temp.last_ema40))
        ), dtrend AS (
         SELECT temp.code,
            temp.load_date,
            temp.price,
            temp.ema15,
            temp.ema40,
            temp.last_ema15,
            temp.last_ema40,
            row_number() OVER (PARTITION BY temp.code ORDER BY temp.load_date DESC) AS rnum
           FROM temp
          WHERE ((temp.ema15 < temp.ema40) AND (temp.last_ema15 >= temp.last_ema40))
        ), output AS (
         SELECT u.code,
            c.load_date,
            i.rnum,
            u.load_date AS up_date,
            d.load_date AS down_date
           FROM (((utrend u
             JOIN dtrend d ON ((((u.code)::text = (d.code)::text) AND (u.rnum = 1) AND (d.rnum = 1))))
             JOIN vlt.v_idx i ON ((u.load_date = i.load_date)))
             CROSS JOIN vlt.v_idx c)
          WHERE (c.rnum = 1)
        )
 SELECT output.code,
    output.load_date,
        CASE
            WHEN (output.up_date > output.down_date) THEN output.rnum
            ELSE (0)::bigint
        END AS trend_period
   FROM output;


--
-- Name: v_quarterly_trend_direction_list; Type: VIEW; Schema: mnp; Owner: -
--

CREATE VIEW mnp.v_quarterly_trend_direction_list AS
 SELECT quarterly_trend_direction_source.category,
    quarterly_trend_direction_source.code,
    max(quarterly_trend_direction_source.load_date) AS recent_calculation_date,
    (avg((((quarterly_trend_direction_source.pe2 + quarterly_trend_direction_source.pe5) + quarterly_trend_direction_source.e2e5) / 3.0)))::numeric(5,4) AS trend,
    (avg(((quarterly_trend_direction_source.popularity + quarterly_trend_direction_source.turnover) / 2)))::numeric(2,1) AS popularity
   FROM mnp.quarterly_trend_direction_source
  WHERE (quarterly_trend_direction_source.load_date > (CURRENT_DATE - '2 mons'::interval))
  GROUP BY quarterly_trend_direction_source.category, quarterly_trend_direction_source.code
 HAVING ((count(*) > 1) AND (avg(((quarterly_trend_direction_source.popularity + quarterly_trend_direction_source.turnover) / 2)) < (3)::numeric))
  ORDER BY quarterly_trend_direction_source.category, (count(*)) DESC, (avg((((quarterly_trend_direction_source.pe2 + quarterly_trend_direction_source.pe5) + quarterly_trend_direction_source.e2e5) / 3.0))) DESC;


--
-- Name: v_semester_trend_direction_list; Type: VIEW; Schema: mnp; Owner: -
--

CREATE VIEW mnp.v_semester_trend_direction_list AS
 SELECT semester_trend_direction_source.category,
    semester_trend_direction_source.code,
    max(semester_trend_direction_source.load_date) AS recent_calculation_date,
    (avg((((semester_trend_direction_source.pe2 + semester_trend_direction_source.pe5) + semester_trend_direction_source.e2e5) / 3.0)))::numeric(5,4) AS trend,
    (avg(((semester_trend_direction_source.popularity + semester_trend_direction_source.turnover) / 2)))::numeric(2,1) AS popularity
   FROM mnp.semester_trend_direction_source
  WHERE (semester_trend_direction_source.load_date > (CURRENT_DATE - '2 mons'::interval))
  GROUP BY semester_trend_direction_source.category, semester_trend_direction_source.code
 HAVING ((count(*) > 1) AND (avg(((semester_trend_direction_source.popularity + semester_trend_direction_source.turnover) / 2)) < (3)::numeric))
  ORDER BY semester_trend_direction_source.category, (count(*)) DESC, (avg((((semester_trend_direction_source.pe2 + semester_trend_direction_source.pe5) + semester_trend_direction_source.e2e5) / 3.0))) DESC;


--
-- Name: full_code_list; Type: TABLE; Schema: mtd; Owner: -
--

CREATE TABLE mtd.full_code_list (
    code character varying,
    market_cap character varying,
    record_dts timestamp with time zone DEFAULT now()
);


--
-- Name: weight_maps; Type: TABLE; Schema: mtd; Owner: -
--

CREATE TABLE mtd.weight_maps (
    categories character varying,
    orders integer,
    weight numeric
);


--
-- Name: batch_log; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.batch_log (
    batch_id character varying,
    job_name character varying,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    sys_load_time timestamp with time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: code_list_analysis; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.code_list_analysis (
    code character varying
);


--
-- Name: code_list_consensus; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.code_list_consensus (
    code character varying
);


--
-- Name: code_list_finance; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.code_list_finance (
    code character varying
);


--
-- Name: code_list_quote; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.code_list_quote (
    code character varying
);


--
-- Name: code_list_rush_1230; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.code_list_rush_1230 (
    code character varying
);


--
-- Name: code_list_rush_1345; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.code_list_rush_1345 (
    code character varying
);


--
-- Name: code_list_rush_1500; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.code_list_rush_1500 (
    code character varying
);


--
-- Name: forex_snapshot; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.forex_snapshot (
    thread character varying(160),
    batch character varying(160),
    info character varying(1000),
    sys_dt timestamp without time zone DEFAULT now()
);


--
-- Name: web_analysis; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.web_analysis (
    batch_id character varying,
    code character varying,
    revenue character varying,
    net_income character varying,
    market_cap character varying,
    enterprise_value character varying,
    net_profit_margin character varying,
    peg_ratio character varying,
    beta character varying,
    forward_pe character varying,
    price_per_sales character varying,
    price_per_book_value character varying,
    price_per_cashflow character varying,
    ebitda character varying,
    return_on_capital character varying,
    return_on_equity character varying,
    return_on_assets character varying,
    book_value_per_share character varying,
    shares_outstanding character varying,
    last_split_factor_date character varying,
    last_dividend_date character varying,
    dividend_declaration_date character varying,
    reco_price_target character varying,
    num_analysts character varying,
    eps_estimate character varying,
    cashflow_estimate character varying,
    average_recommendation character varying,
    recommendation_date character varying,
    sys_load_time timestamp with time zone DEFAULT now()
);


--
-- Name: web_announcement; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.web_announcement (
    code character varying,
    batch_type character varying,
    pub_time character varying,
    contents character varying,
    is_price_sens character varying,
    sys_load_time timestamp with time zone DEFAULT now()
);


--
-- Name: web_consensus; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.web_consensus (
    batch_id character varying,
    code character varying,
    buy character varying,
    overweight character varying,
    hold character varying,
    underweight character varying,
    sell character varying,
    high character varying,
    median character varying,
    low character varying,
    avearge character varying,
    current character varying,
    sys_load_time timestamp with time zone DEFAULT now()
);


--
-- Name: web_finance; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.web_finance (
    batch_id character varying,
    code character varying,
    market_open character varying,
    market_day_high character varying,
    market_previous_close character varying,
    market_day_low character varying,
    market_price character varying,
    market_volume character varying,
    current_price character varying,
    target_low_price character varying,
    target_median_price character varying,
    number_of_analyst character varying,
    target_mean_price character varying,
    target_high_price character varying,
    recommendation_mean character varying,
    regular_market_open character varying,
    regular_market_day_high character varying,
    regular_market_previous_close character varying,
    regular_market_day_low character varying,
    tailing_pe character varying,
    regualr_market_volume character varying,
    average_volume character varying,
    ask character varying,
    ask_size character varying,
    forward_pe character varying,
    bid character varying,
    bid_size character varying,
    enterprise_revenue character varying,
    profit_margins character varying,
    enterprise_ebitda character varying,
    book_value character varying,
    tailing_eps character varying,
    price_to_book character varying,
    beta character varying,
    quarterly_earning_growth character varying,
    sys_load_time timestamp with time zone DEFAULT now()
);


--
-- Name: web_quote; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.web_quote (
    batch_id character varying,
    code character varying,
    open_price character varying,
    high_price character varying,
    low_price character varying,
    close_price character varying,
    previous_close character varying,
    volume character varying,
    turnover character varying,
    pe_ratio character varying,
    ask character varying,
    bid character varying,
    outstanding character varying,
    dividend_yield character varying,
    market_cap character varying,
    sys_load_time timestamp with time zone DEFAULT now()
);


--
-- Name: web_rush_1230; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.web_rush_1230 (
    batch_id character varying,
    code character varying,
    tick_price character varying,
    tick_time character varying,
    sys_load_time timestamp with time zone DEFAULT now()
);


--
-- Name: web_rush_1345; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.web_rush_1345 (
    batch_id character varying,
    code character varying,
    tick_price character varying,
    tick_time character varying,
    sys_load_time timestamp with time zone DEFAULT now()
);


--
-- Name: web_rush_1500; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.web_rush_1500 (
    batch_id character varying,
    code character varying,
    tick_price character varying,
    tick_time character varying,
    sys_load_time timestamp with time zone DEFAULT now()
);


--
-- Name: web_short; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.web_short (
    company_full_name character varying,
    product_code character varying,
    short_position character varying,
    total_in_issue character varying,
    reported_position character varying,
    sys_load timestamp with time zone DEFAULT now()
);


--
-- Name: v_etl_log; Type: VIEW; Schema: ods; Owner: -
--

CREATE VIEW ods.v_etl_log AS
 WITH batchs AS (
         SELECT batch_log.batch_id,
            batch_log.job_name,
            batch_log.start_time,
            batch_log.end_time
           FROM ods.batch_log
          WHERE ((batch_log.sys_load_time)::date = CURRENT_DATE)
        ), quotes AS (
         SELECT q.batch_id,
            count(*) AS cnt
           FROM ods.web_quote q
          WHERE ((q.sys_load_time)::date = CURRENT_DATE)
          GROUP BY q.batch_id
        ), consensus AS (
         SELECT q.batch_id,
            count(*) AS cnt
           FROM ods.web_consensus q
          WHERE ((q.sys_load_time)::date = CURRENT_DATE)
          GROUP BY q.batch_id
        ), analysis AS (
         SELECT q.batch_id,
            count(*) AS cnt
           FROM ods.web_analysis q
          WHERE ((q.sys_load_time)::date = CURRENT_DATE)
          GROUP BY q.batch_id
        ), statements AS (
         SELECT q.batch_id,
            count(*) AS cnt
           FROM ods.web_finance q
          WHERE ((q.sys_load_time)::date = CURRENT_DATE)
          GROUP BY q.batch_id
        ), r1230 AS (
         SELECT q.batch_id,
            count(*) AS cnt
           FROM ods.web_rush_1230 q
          WHERE ((q.sys_load_time)::date = CURRENT_DATE)
          GROUP BY q.batch_id
        ), r1345 AS (
         SELECT q.batch_id,
            count(*) AS cnt
           FROM ods.web_rush_1345 q
          WHERE ((q.sys_load_time)::date = CURRENT_DATE)
          GROUP BY q.batch_id
        ), r1500 AS (
         SELECT q.batch_id,
            count(*) AS cnt
           FROM ods.web_rush_1500 q
          WHERE ((q.sys_load_time)::date = CURRENT_DATE)
          GROUP BY q.batch_id
        ), annc AS (
         SELECT count(*) AS cnt
           FROM ods.web_announcement q
          WHERE ((q.sys_load_time)::date = CURRENT_DATE)
        ), shorts AS (
         SELECT count(*) AS cnt
           FROM ods.web_short q
          WHERE ((q.sys_load)::date = CURRENT_DATE)
        ), output AS (
         SELECT b.batch_id,
            b.job_name,
            b.start_time,
            b.end_time,
            COALESCE(q.cnt, c.cnt, a.cnt, s.cnt, r2.cnt, r3.cnt, r5.cnt,
                CASE
                    WHEN ((b.job_name)::text = 'dAnnouncement'::text) THEN n.cnt
                    ELSE NULL::bigint
                END,
                CASE
                    WHEN ((b.job_name)::text = 'dShort'::text) THEN h.cnt
                    ELSE NULL::bigint
                END, (0)::bigint) AS records
           FROM (((((((((batchs b
             LEFT JOIN quotes q ON (((b.batch_id)::text = (q.batch_id)::text)))
             LEFT JOIN consensus c ON (((b.batch_id)::text = (c.batch_id)::text)))
             LEFT JOIN analysis a ON (((b.batch_id)::text = (a.batch_id)::text)))
             LEFT JOIN statements s ON (((b.batch_id)::text = (s.batch_id)::text)))
             LEFT JOIN r1230 r2 ON (((b.batch_id)::text = (r2.batch_id)::text)))
             LEFT JOIN r1345 r3 ON (((b.batch_id)::text = (r3.batch_id)::text)))
             LEFT JOIN r1500 r5 ON (((b.batch_id)::text = (r5.batch_id)::text)))
             CROSS JOIN annc n)
             CROSS JOIN shorts h)
        )
 SELECT output.job_name,
    sum(output.records) AS records,
    CURRENT_DATE AS record_date
   FROM output
  GROUP BY output.job_name
  ORDER BY (min(output.start_time));


--
-- Name: v_snapshot; Type: VIEW; Schema: ods; Owner: -
--

CREATE VIEW ods.v_snapshot AS
 WITH temp AS (
         SELECT snapshot.batch,
            "substring"("substring"((snapshot.info)::text, "position"((snapshot.info)::text, 'instrument'::text)), (length('instrument'::text) + 2), (("position"("substring"((snapshot.info)::text, "position"((snapshot.info)::text, 'instrument'::text)), ','::text) - 2) - length('instrument'::text))) AS instrument,
            "substring"("substring"((snapshot.info)::text, "position"((snapshot.info)::text, 'time'::text)), (length('time'::text) + 2), (("position"("substring"((snapshot.info)::text, "position"((snapshot.info)::text, 'time'::text)), ','::text) - 2) - length('time'::text))) AS "time",
            "substring"("substring"((snapshot.info)::text, "position"((snapshot.info)::text, 'closeoutBid'::text)), (length('closeoutBid'::text) + 2), (("position"("substring"((snapshot.info)::text, "position"((snapshot.info)::text, 'closeoutBid'::text)), ','::text) - 2) - length('closeoutBid'::text))) AS closeoutbid,
            "substring"("substring"((snapshot.info)::text, "position"((snapshot.info)::text, 'closeoutAsk'::text)), (length('closeoutAsk'::text) + 2), (("position"("substring"((snapshot.info)::text, "position"((snapshot.info)::text, 'closeoutAsk'::text)), ','::text) - 2) - length('closeoutAsk'::text))) AS closeoutask,
            snapshot.sys_dt
           FROM ods.forex_snapshot snapshot
        ), output AS (
         SELECT temp.batch,
            temp.instrument,
            (temp."time")::timestamp without time zone AS snapshot_on_gtc,
            (temp.closeoutbid)::numeric AS bid,
            (temp.closeoutask)::numeric AS ask,
            temp.sys_dt
           FROM temp
        )
 SELECT output.batch,
    output.instrument,
    date_trunc('second'::text, output.snapshot_on_gtc) AS snapshot_on_gtc,
    output.bid,
    output.ask,
    output.sys_dt
   FROM output;


--
-- Name: web_blackhole_1230; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.web_blackhole_1230 (
    batch_id character varying,
    code character varying,
    open_price character varying,
    high_price character varying,
    low_price character varying,
    close_price character varying,
    previous_close character varying,
    volume character varying,
    turnover character varying,
    pe_ratio character varying,
    ask character varying,
    bid character varying,
    outstanding character varying,
    dividend_yield character varying,
    market_cap character varying,
    sys_load_time timestamp with time zone DEFAULT now()
);


--
-- Name: web_blackhole_1345; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.web_blackhole_1345 (
    batch_id character varying,
    code character varying,
    open_price character varying,
    high_price character varying,
    low_price character varying,
    close_price character varying,
    previous_close character varying,
    volume character varying,
    turnover character varying,
    pe_ratio character varying,
    ask character varying,
    bid character varying,
    outstanding character varying,
    dividend_yield character varying,
    market_cap character varying,
    sys_load_time timestamp with time zone DEFAULT now()
);


--
-- Name: web_blackhole_1500; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.web_blackhole_1500 (
    batch_id character varying,
    code character varying,
    open_price character varying,
    high_price character varying,
    low_price character varying,
    close_price character varying,
    previous_close character varying,
    volume character varying,
    turnover character varying,
    pe_ratio character varying,
    ask character varying,
    bid character varying,
    outstanding character varying,
    dividend_yield character varying,
    market_cap character varying,
    sys_load_time timestamp with time zone DEFAULT now()
);


--
-- Name: web_sentiment; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.web_sentiment (
    batch_id character varying,
    code character varying,
    publish_title character varying,
    publish_time character varying,
    sys_load_time timestamp with time zone DEFAULT now()
);


--
-- Name: web_ticker; Type: TABLE; Schema: ods; Owner: -
--

CREATE TABLE ods.web_ticker (
    batch_id character varying,
    code character varying,
    tick_price character varying,
    tick_time character varying,
    sys_load_time timestamp with time zone DEFAULT now()
);


--
-- Name: index_summary_report; Type: TABLE; Schema: rpt; Owner: -
--

CREATE TABLE rpt.index_summary_report (
    category character varying,
    load_date date,
    daily_perf text,
    ha text,
    ema text
);


--
-- Name: long_list_snapshot; Type: TABLE; Schema: rpt; Owner: -
--

CREATE TABLE rpt.long_list_snapshot (
    category character varying,
    code character varying,
    load_date date,
    total_ranking bigint,
    category_ranking bigint
);


--
-- Name: long_summary_report; Type: TABLE; Schema: rpt; Owner: -
--

CREATE TABLE rpt.long_summary_report (
    "category (EMA,HA,DIRC)" text,
    code character varying,
    price numeric(8,3),
    ranking text,
    option text,
    status text,
    trend bigint,
    volume text,
    daily_range text,
    short_indicator text,
    sar text,
    last_anc bigint,
    rnum bigint,
    cnum bigint,
    load_date date
);


--
-- Name: long_summary_report_backup; Type: TABLE; Schema: rpt; Owner: -
--

CREATE TABLE rpt.long_summary_report_backup (
    category text,
    code character varying,
    ranking text,
    option text,
    status text,
    trend text,
    volume text,
    daily_range text,
    rnum bigint,
    load_date date
);


--
-- Name: short_list_snapshot; Type: TABLE; Schema: rpt; Owner: -
--

CREATE TABLE rpt.short_list_snapshot (
    category character varying,
    code character varying,
    load_date date,
    total_ranking bigint,
    category_ranking bigint
);


--
-- Name: short_summary_report; Type: TABLE; Schema: rpt; Owner: -
--

CREATE TABLE rpt.short_summary_report (
    "category (EMA,HA,DIRC)" text,
    code character varying,
    price numeric(8,3),
    ranking text,
    option text,
    status text,
    trend bigint,
    volume text,
    daily_range text,
    short_indicator text,
    sar text,
    last_anc bigint,
    rnum bigint,
    cnum bigint,
    load_date date
);


--
-- Name: short_summary_report_backup; Type: TABLE; Schema: rpt; Owner: -
--

CREATE TABLE rpt.short_summary_report_backup (
    category text,
    code character varying,
    ranking text,
    option text,
    status text,
    trend text,
    volume text,
    daily_range text,
    rnum bigint,
    load_date date
);


--
-- Name: index_1230; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.index_1230 (
    category character varying,
    load_date date,
    s_open numeric(10,3),
    s_close numeric(10,3),
    s_high numeric(10,3),
    s_low numeric(10,3),
    h_open numeric(10,3),
    h_close numeric(10,3),
    h_high numeric(10,3),
    h_low numeric(10,3),
    ema25 numeric(10,3),
    ema10 numeric(10,3)
);


--
-- Name: v_daily_index_report_1230; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_index_report_1230 AS
 WITH cset AS (
         SELECT index_1230.category,
            index_1230.load_date,
            index_1230.s_open,
            index_1230.s_close,
            index_1230.s_high,
            index_1230.s_low,
            index_1230.h_open,
            index_1230.h_close,
            index_1230.h_high,
            index_1230.h_low,
            index_1230.ema25,
            index_1230.ema10
           FROM rtc.index_1230
          WHERE (index_1230.load_date = ( SELECT max(index_1230_1.load_date) AS max
                   FROM rtc.index_1230 index_1230_1))
        ), pset AS (
         SELECT index_direction.category,
            index_direction.load_date,
            index_direction.s_open,
            index_direction.s_close,
            index_direction.s_high,
            index_direction.s_low,
            index_direction.h_open,
            index_direction.h_close,
            index_direction.h_high,
            index_direction.h_low,
            index_direction.ema25,
            index_direction.ema10
           FROM cal.index_direction
          WHERE (index_direction.load_date = ( SELECT max(index_direction_1.load_date) AS max
                   FROM cal.index_direction index_direction_1
                  WHERE (index_direction_1.load_date < ( SELECT max(index_1230.load_date) AS max
                           FROM rtc.index_1230))))
        ), features AS (
         SELECT c.category,
            c.load_date,
                CASE
                    WHEN (p.h_close >= p.h_open) THEN '+'::text
                    ELSE '-'::text
                END AS last_ha,
                CASE
                    WHEN (c.h_close >= c.h_open) THEN '+'::text
                    ELSE '-'::text
                END AS current_ha,
                CASE
                    WHEN (c.s_close >= p.s_close) THEN '+'::text
                    ELSE '-'::text
                END AS daily_perf,
                CASE
                    WHEN (p.ema10 >= p.ema25) THEN '+'::text
                    ELSE '-'::text
                END AS last_ema,
                CASE
                    WHEN (c.ema10 >= c.ema25) THEN '+'::text
                    ELSE '-'::text
                END AS current_ema
           FROM (cset c
             LEFT JOIN pset p ON (((c.category)::text = (p.category)::text)))
        )
 SELECT features.category,
    features.load_date,
    features.daily_perf,
    concat(features.last_ha, features.current_ha) AS ha,
    concat(features.last_ema, features.current_ema) AS ema
   FROM features
  WHERE ((features.category)::text <> 'Unclassified'::text)
  ORDER BY features.category;


--
-- Name: index_1345; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.index_1345 (
    category character varying,
    load_date date,
    s_open numeric(10,3),
    s_close numeric(10,3),
    s_high numeric(10,3),
    s_low numeric(10,3),
    h_open numeric(10,3),
    h_close numeric(10,3),
    h_high numeric(10,3),
    h_low numeric(10,3),
    ema25 numeric(10,3),
    ema10 numeric(10,3)
);


--
-- Name: v_daily_index_report_1345; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_index_report_1345 AS
 WITH cset AS (
         SELECT index_1345.category,
            index_1345.load_date,
            index_1345.s_open,
            index_1345.s_close,
            index_1345.s_high,
            index_1345.s_low,
            index_1345.h_open,
            index_1345.h_close,
            index_1345.h_high,
            index_1345.h_low,
            index_1345.ema25,
            index_1345.ema10
           FROM rtc.index_1345
          WHERE (index_1345.load_date = ( SELECT max(index_1345_1.load_date) AS max
                   FROM rtc.index_1345 index_1345_1))
        ), pset AS (
         SELECT index_direction.category,
            index_direction.load_date,
            index_direction.s_open,
            index_direction.s_close,
            index_direction.s_high,
            index_direction.s_low,
            index_direction.h_open,
            index_direction.h_close,
            index_direction.h_high,
            index_direction.h_low,
            index_direction.ema25,
            index_direction.ema10
           FROM cal.index_direction
          WHERE (index_direction.load_date = ( SELECT max(index_direction_1.load_date) AS max
                   FROM cal.index_direction index_direction_1
                  WHERE (index_direction_1.load_date < ( SELECT max(index_1345.load_date) AS max
                           FROM rtc.index_1345))))
        ), features AS (
         SELECT c.category,
            c.load_date,
                CASE
                    WHEN (p.h_close >= p.h_open) THEN '+'::text
                    ELSE '-'::text
                END AS last_ha,
                CASE
                    WHEN (c.h_close >= c.h_open) THEN '+'::text
                    ELSE '-'::text
                END AS current_ha,
                CASE
                    WHEN (c.s_close >= p.s_close) THEN '+'::text
                    ELSE '-'::text
                END AS daily_perf,
                CASE
                    WHEN (p.ema10 >= p.ema25) THEN '+'::text
                    ELSE '-'::text
                END AS last_ema,
                CASE
                    WHEN (c.ema10 >= c.ema25) THEN '+'::text
                    ELSE '-'::text
                END AS current_ema
           FROM (cset c
             LEFT JOIN pset p ON (((c.category)::text = (p.category)::text)))
        )
 SELECT features.category,
    features.load_date,
    features.daily_perf,
    concat(features.last_ha, features.current_ha) AS ha,
    concat(features.last_ema, features.current_ema) AS ema
   FROM features
  WHERE ((features.category)::text <> 'Unclassified'::text)
  ORDER BY features.category;


--
-- Name: index_1500; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.index_1500 (
    category character varying,
    load_date date,
    s_open numeric(10,3),
    s_close numeric(10,3),
    s_high numeric(10,3),
    s_low numeric(10,3),
    h_open numeric(10,3),
    h_close numeric(10,3),
    h_high numeric(10,3),
    h_low numeric(10,3),
    ema25 numeric(10,3),
    ema10 numeric(10,3)
);


--
-- Name: v_daily_index_report_1500; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_index_report_1500 AS
 WITH cset AS (
         SELECT index_1500.category,
            index_1500.load_date,
            index_1500.s_open,
            index_1500.s_close,
            index_1500.s_high,
            index_1500.s_low,
            index_1500.h_open,
            index_1500.h_close,
            index_1500.h_high,
            index_1500.h_low,
            index_1500.ema25,
            index_1500.ema10
           FROM rtc.index_1500
          WHERE (index_1500.load_date = ( SELECT max(index_1500_1.load_date) AS max
                   FROM rtc.index_1500 index_1500_1))
        ), pset AS (
         SELECT index_direction.category,
            index_direction.load_date,
            index_direction.s_open,
            index_direction.s_close,
            index_direction.s_high,
            index_direction.s_low,
            index_direction.h_open,
            index_direction.h_close,
            index_direction.h_high,
            index_direction.h_low,
            index_direction.ema25,
            index_direction.ema10
           FROM cal.index_direction
          WHERE (index_direction.load_date = ( SELECT max(index_direction_1.load_date) AS max
                   FROM cal.index_direction index_direction_1
                  WHERE (index_direction_1.load_date < ( SELECT max(index_1500.load_date) AS max
                           FROM rtc.index_1500))))
        ), features AS (
         SELECT c.category,
            c.load_date,
                CASE
                    WHEN (p.h_close >= p.h_open) THEN '+'::text
                    ELSE '-'::text
                END AS last_ha,
                CASE
                    WHEN (c.h_close >= c.h_open) THEN '+'::text
                    ELSE '-'::text
                END AS current_ha,
                CASE
                    WHEN (c.s_close >= p.s_close) THEN '+'::text
                    ELSE '-'::text
                END AS daily_perf,
                CASE
                    WHEN (p.ema10 >= p.ema25) THEN '+'::text
                    ELSE '-'::text
                END AS last_ema,
                CASE
                    WHEN (c.ema10 >= c.ema25) THEN '+'::text
                    ELSE '-'::text
                END AS current_ema
           FROM (cset c
             LEFT JOIN pset p ON (((c.category)::text = (p.category)::text)))
        )
 SELECT features.category,
    features.load_date,
    features.daily_perf,
    concat(features.last_ha, features.current_ha) AS ha,
    concat(features.last_ema, features.current_ema) AS ema
   FROM features
  WHERE ((features.category)::text <> 'Unclassified'::text)
  ORDER BY features.category;


--
-- Name: v_daily_index_summary; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_index_summary AS
 SELECT index_summary_report.category,
    index_summary_report.load_date,
    index_summary_report.daily_perf,
    index_summary_report.ha,
    index_summary_report.ema
   FROM rpt.index_summary_report
  WHERE (index_summary_report.load_date = ( SELECT max(index_summary_report_1.load_date) AS max
           FROM rpt.index_summary_report index_summary_report_1));


--
-- Name: ema_1230; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.ema_1230 (
    code character varying,
    load_date date,
    price numeric,
    ema15 numeric(8,4),
    ema40 numeric(8,4),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: ha_1230; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.ha_1230 (
    code character varying,
    load_date date,
    h_open numeric(10,4),
    h_high numeric(10,4),
    h_low numeric(10,4),
    h_close numeric(10,4),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: v_ema_1230_current; Type: VIEW; Schema: rtc; Owner: -
--

CREATE VIEW rtc.v_ema_1230_current AS
 SELECT ema_1230.code,
    ema_1230.load_date,
    ema_1230.price,
    ema_1230.ema15,
    ema_1230.ema40
   FROM rtc.ema_1230
  WHERE (ema_1230.load_date = ( SELECT max(ema_1230_1.load_date) AS max
           FROM rtc.ema_1230 ema_1230_1));


--
-- Name: v_ha_1230_sequence_current; Type: VIEW; Schema: rtc; Owner: -
--

CREATE VIEW rtc.v_ha_1230_sequence_current AS
 WITH idx AS (
         SELECT ha_1230.load_date,
            row_number() OVER (ORDER BY ha_1230.load_date DESC) AS rnum
           FROM rtc.ha_1230
          GROUP BY ha_1230.load_date
        ), ext AS (
         SELECT ha_1230.code,
            ha_1230.load_date,
            ha_1230.h_open,
            ha_1230.h_high,
            ha_1230.h_low,
            ha_1230.h_close,
            ha_1230.sys_load_time,
            lag(ha_1230.h_open, 1) OVER (PARTITION BY ha_1230.code ORDER BY ha_1230.load_date) AS last_open,
            lag(ha_1230.h_close, 1) OVER (PARTITION BY ha_1230.code ORDER BY ha_1230.load_date) AS last_close
           FROM rtc.ha_1230
        ), list AS (
         SELECT ext.code,
            ext.load_date,
            ext.h_open,
            ext.h_high,
            ext.h_low,
            ext.h_close,
            ext.sys_load_time,
            ext.last_open,
            ext.last_close,
            row_number() OVER (PARTITION BY ext.code ORDER BY ext.load_date DESC) AS rnum
           FROM ext
          WHERE (((ext.h_open <= ext.h_close) AND (ext.last_open > ext.last_close)) OR ((ext.h_open > ext.h_close) AND (ext.last_open <= ext.last_close)))
        ), cur AS (
         SELECT ha_1230.code,
            ha_1230.load_date,
            ha_1230.h_open,
            ha_1230.h_high,
            ha_1230.h_low,
            ha_1230.h_close,
            ha_1230.sys_load_time,
                CASE
                    WHEN ((ha_1230.h_close >= ha_1230.h_open) AND (ha_1230.h_open = ha_1230.h_low)) THEN 'Positive'::text
                    WHEN ((ha_1230.h_close < ha_1230.h_open) AND (ha_1230.h_open = ha_1230.h_high)) THEN 'Negative'::text
                    WHEN ((ha_1230.h_close >= ha_1230.h_open) AND (ha_1230.h_open > ha_1230.h_low)) THEN 'Long'::text
                    WHEN ((ha_1230.h_close < ha_1230.h_open) AND (ha_1230.h_open < ha_1230.h_high)) THEN 'Short'::text
                    ELSE NULL::text
                END AS status
           FROM rtc.ha_1230
          WHERE (ha_1230.load_date = ( SELECT max(ha_1230_1.load_date) AS max
                   FROM rtc.ha_1230 ha_1230_1))
        ), comb AS (
         SELECT l.code,
            l.load_date,
            i.rnum AS sequence
           FROM (list l
             JOIN idx i ON ((l.load_date = i.load_date)))
          WHERE (l.rnum = 1)
        ), output AS (
         SELECT b.code,
            c.load_date,
            b.sequence,
            c.status
           FROM (cur c
             JOIN comb b ON (((c.code)::text = (b.code)::text)))
        )
 SELECT output.code,
    output.load_date,
    output.sequence,
    output.status
   FROM output
  ORDER BY output.code;


--
-- Name: announcements; Type: TABLE; Schema: vlt; Owner: -
--

CREATE TABLE vlt.announcements (
    code character varying,
    pub_datetime timestamp without time zone
);


--
-- Name: rush_1230; Type: TABLE; Schema: vlt; Owner: -
--

CREATE TABLE vlt.rush_1230 (
    code character varying,
    load_date date,
    high numeric,
    low numeric,
    open numeric(9,4),
    close numeric(9,4),
    typ3 numeric(9,4),
    typ4 numeric(9,4),
    sys_load_time timestamp without time zone DEFAULT now()
);


--
-- Name: shorts; Type: TABLE; Schema: vlt; Owner: -
--

CREATE TABLE vlt.shorts (
    code character varying,
    load_date date,
    short_position bigint,
    total_in_issue bigint,
    reported_position numeric
);


--
-- Name: v_announcements; Type: VIEW; Schema: vlt; Owner: -
--

CREATE VIEW vlt.v_announcements AS
 WITH temp AS (
         SELECT announcements.code,
            0 AS last_anc
           FROM vlt.announcements
          WHERE (((announcements.pub_datetime)::date = CURRENT_DATE) AND (announcements.pub_datetime < ((CURRENT_DATE)::timestamp without time zone + '10:00:00'::interval)))
          GROUP BY announcements.code
        UNION
         SELECT a.code,
            min(i.rnum) AS last_anc
           FROM (vlt.announcements a
             JOIN vlt.v_idx i ON (((a.pub_datetime)::date = i.load_date)))
          GROUP BY a.code
        )
 SELECT temp.code,
    min(temp.last_anc) AS last_anc
   FROM temp
  GROUP BY temp.code;


--
-- Name: v_rush_1230_current; Type: VIEW; Schema: vlt; Owner: -
--

CREATE VIEW vlt.v_rush_1230_current AS
 SELECT rush_1230.code,
    rush_1230.load_date,
    rush_1230.high,
    rush_1230.low,
    rush_1230.open,
    rush_1230.close,
    rush_1230.typ3,
    rush_1230.typ4
   FROM vlt.rush_1230
  WHERE (rush_1230.load_date = ( SELECT max(rush_1230_1.load_date) AS max
           FROM vlt.rush_1230 rush_1230_1));


--
-- Name: v_short; Type: VIEW; Schema: vlt; Owner: -
--

CREATE VIEW vlt.v_short AS
 WITH tq AS (
         SELECT quotes.code,
            quotes.load_date,
            quotes.typ3,
            row_number() OVER (PARTITION BY quotes.code, quotes.load_date ORDER BY quotes.market_cap DESC) AS rnum
           FROM vlt.quotes
          WHERE (quotes.market_cap IS NOT NULL)
        ), cb AS (
         SELECT q.code,
            q.load_date,
            q.typ3,
            q.rnum,
            s.short_position
           FROM (tq q
             JOIN vlt.shorts s ON ((((q.code)::text = (s.code)::text) AND (q.load_date = s.load_date))))
        ), lt AS (
         SELECT cb.code,
            cb.load_date,
            row_number() OVER (PARTITION BY cb.code ORDER BY cb.load_date) AS rnum,
            sum((cb.typ3 * (cb.short_position)::numeric)) AS short
           FROM cb
          GROUP BY cb.code, cb.load_date
        ), xt AS (
         SELECT lt.code,
            lt.load_date,
            lt.rnum,
            lt.short,
            avg(lt.short) OVER (PARTITION BY lt.code ORDER BY lt.rnum ROWS BETWEEN 19 PRECEDING AND CURRENT ROW) AS avg,
            stddev(lt.short) OVER (PARTITION BY lt.code ORDER BY lt.rnum ROWS BETWEEN 19 PRECEDING AND CURRENT ROW) AS std
           FROM lt
        ), output AS (
         SELECT xt.code,
            xt.load_date,
            xt.short,
            (xt.avg + (xt.std * (2)::numeric)) AS up_band,
            (xt.avg - (xt.std * (2)::numeric)) AS down_band,
                CASE
                    WHEN (xt.short >= (xt.avg + (xt.std * 1.28))) THEN 1
                    WHEN (xt.short < (xt.avg - (xt.std * 1.28))) THEN '-1'::integer
                    ELSE 0
                END AS short_amount
           FROM xt
          WHERE ((xt.avg IS NOT NULL) AND (xt.std IS NOT NULL) AND ((xt.short >= (xt.avg + (xt.std * 1.28))) OR (xt.short < (xt.avg - (xt.std * 1.28)))))
        )
 SELECT o.code,
    o.load_date,
    o.short,
    o.up_band,
    o.down_band,
    o.short_amount,
    row_number() OVER (PARTITION BY o.code ORDER BY o.load_date DESC) AS rnum,
    i.rnum AS cal_dist
   FROM (output o
     JOIN vlt.v_idx i ON ((o.load_date = i.load_date)));


--
-- Name: v_short_current; Type: VIEW; Schema: vlt; Owner: -
--

CREATE VIEW vlt.v_short_current AS
 SELECT COALESCE(s1.code, s2.code) AS code,
    s1.short_amount AS nearest_break,
    s2.short_amount AS previous_break,
    s1.cal_dist AS nearest_distance,
    s2.cal_dist AS previous_distance
   FROM (vlt.v_short s1
     JOIN vlt.v_short s2 ON ((((s1.code)::text = (s2.code)::text) AND (s1.rnum = 1) AND (s2.rnum = 2))));


--
-- Name: v_daily_long_report_1230; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_long_report_1230 AS
 SELECT concat(l.category, '(', i.daily_perf, ',', i.ema, ',', i.ha, ')') AS "category (daily/ema/ha)",
    concat(l.code, '(', "substring"(((l.last_update_date)::character varying)::text, 6, 5), ')') AS "code(update_ts)",
    concat(l.total_ranking, '(', l.category_ranking, ')') AS "ranking(in category)",
    e.price AS current_price,
        CASE
            WHEN (e.ema15 >= e.ema40) THEN 'BUY'::text
            ELSE 'SELL'::text
        END AS "option(ema)",
    concat(h.status, '(', h.sequence, ')') AS "status(ha)",
        CASE
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar <= r.high)) THEN '-+'::text
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar > r.high)) THEN '--'::text
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar > r.low)) THEN '+-'::text
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar <= r.low)) THEN '++'::text
            ELSE ''::text
        END AS sar,
    concat((t.nearest_break)::character varying, '(', t.nearest_distance, ')/', (t.previous_break)::character varying, '(', t.previous_distance, ')') AS short_indicator,
    a.last_anc,
    r.load_date
   FROM (((((((cal.v_full_long_current l
     JOIN vlt.v_rush_1230_current r ON (((l.code)::text = (r.code)::text)))
     LEFT JOIN rpt.v_daily_index_report_1230 i ON (((l.category)::text = (i.category)::text)))
     LEFT JOIN rtc.v_ema_1230_current e ON (((l.code)::text = (e.code)::text)))
     LEFT JOIN rtc.v_ha_1230_sequence_current h ON (((l.code)::text = (h.code)::text)))
     LEFT JOIN cal.v_sar_current s ON (((l.code)::text = (s.code)::text)))
     LEFT JOIN vlt.v_short_current t ON (((l.code)::text = (t.code)::text)))
     LEFT JOIN vlt.v_announcements a ON (((l.code)::text = (a.code)::text)))
  WHERE ((l.total_ranking <= 40) AND (l.category_ranking <= 4))
  ORDER BY l.total_ranking;


--
-- Name: macd_1230; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.macd_1230 (
    code character varying,
    load_date date,
    diff numeric,
    dea numeric(8,4),
    chart_type text,
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: v_ha_comp_current_1230; Type: VIEW; Schema: rtc; Owner: -
--

CREATE VIEW rtc.v_ha_comp_current_1230 AS
 WITH quotes AS (
         SELECT ha_1230.code,
            ha_1230.load_date,
            ha_1230.h_open AS open,
            ha_1230.h_close AS close
           FROM rtc.ha_1230
          WHERE (ha_1230.load_date = ( SELECT max(ha_1230_1.load_date) AS max
                   FROM rtc.ha_1230 ha_1230_1))
        UNION
         SELECT heikin_ashi.code,
            heikin_ashi.load_date,
            heikin_ashi.open,
            heikin_ashi.close
           FROM cal.heikin_ashi
          WHERE ((heikin_ashi.load_date < ( SELECT max(ha_1230.load_date) AS max
                   FROM rtc.ha_1230)) AND (heikin_ashi.load_date > ( SELECT (max(ha_1230.load_date) - 28)
                   FROM rtc.ha_1230)))
        ), comb AS (
         SELECT quotes.code,
            quotes.load_date,
            quotes.open AS current_open,
            quotes.close AS current_close,
            row_number() OVER (PARTITION BY quotes.code ORDER BY quotes.load_date DESC) AS rnum,
            lag(quotes.open, 1) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS last_open,
            lag(quotes.close, 1) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS last_close,
            lag(quotes.open, 2) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS previous_open,
            lag(quotes.close, 2) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS previous_close
           FROM quotes
        ), subset AS (
         SELECT comb.code,
            comb.load_date,
            comb.current_open,
            comb.current_close,
            comb.last_open,
            comb.last_close,
            comb.previous_open,
            comb.previous_close
           FROM comb
          WHERE (comb.load_date = ( SELECT max(comb_1.load_date) AS max
                   FROM comb comb_1))
        )
 SELECT subset.code,
    subset.load_date,
    subset.current_open,
    subset.current_close,
    subset.last_open,
    subset.last_close,
    subset.previous_open,
    subset.previous_close
   FROM subset;


--
-- Name: v_macd_comp_current_1230; Type: VIEW; Schema: rtc; Owner: -
--

CREATE VIEW rtc.v_macd_comp_current_1230 AS
 WITH quotes AS (
         SELECT macd_1230.code,
            macd_1230.load_date,
            macd_1230.diff,
            macd_1230.dea
           FROM rtc.macd_1230
          WHERE ((macd_1230.load_date = CURRENT_DATE) AND (macd_1230.chart_type = 'ha'::text))
        UNION
         SELECT macd.code,
            macd.load_date,
            macd.diff,
            macd.dea
           FROM cal.macd
          WHERE ((macd.load_date < CURRENT_DATE) AND (macd.load_date > (CURRENT_DATE - 28)))
        ), comb AS (
         SELECT quotes.code,
            quotes.load_date,
            quotes.diff AS current_diff,
            quotes.dea AS current_dea,
            row_number() OVER (PARTITION BY quotes.code ORDER BY quotes.load_date DESC) AS rnum,
            lag(quotes.diff, 1) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS last_diff,
            lag(quotes.dea, 1) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS last_dea,
            lag(quotes.diff, 2) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS previous_diff,
            lag(quotes.dea, 2) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS previous_dea
           FROM quotes
        ), subset AS (
         SELECT comb.code,
            comb.load_date,
            comb.current_diff,
            comb.current_dea,
            comb.last_diff,
            comb.last_dea,
            comb.previous_diff,
            comb.previous_dea
           FROM comb
          WHERE (comb.load_date = CURRENT_DATE)
        )
 SELECT subset.code,
    subset.load_date,
    subset.current_diff,
    subset.current_dea,
    subset.last_diff,
    subset.last_dea,
    subset.previous_diff,
    subset.previous_dea
   FROM subset;


--
-- Name: v_daily_long_report_1230_backup; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_long_report_1230_backup AS
 WITH temp AS (
         SELECT l.category,
            r.close,
            r.high,
            r.low,
            (
                CASE
                    WHEN (i.h_close >= i.h_open) THEN '+'::text
                    ELSE '-'::text
                END)::character varying AS index_ha,
            (
                CASE
                    WHEN (i.ema10 >= i.ema25) THEN '+'::text
                    ELSE '-'::text
                END)::character varying AS index_ema,
            l.code,
            l.last_update_date AS ranking_date,
            l.total_ranking,
            l.category_ranking,
                CASE
                    WHEN ((m.current_diff >= m.current_dea) AND (m.last_diff < m.last_dea)) THEN 1
                    ELSE 0
                END AS macd_conversion,
                CASE
                    WHEN (((m.current_diff - m.current_dea) >= (m.last_diff - m.last_dea)) AND ((m.last_diff - m.last_dea) >= (m.previous_diff - m.previous_dea))) THEN 1
                    ELSE 0
                END AS macd_trend,
                CASE
                    WHEN (((m.current_diff - m.current_dea) >= (m.last_diff - m.last_dea)) AND ((m.last_diff - m.last_dea) < (m.previous_diff - m.previous_dea))) THEN 1
                    ELSE 0
                END AS macd_bottom,
                CASE
                    WHEN ((h.current_close >= h.current_open) AND (h.last_close < h.last_open)) THEN 1
                    ELSE 0
                END AS ha_conversion,
                CASE
                    WHEN ((h.previous_close < h.last_close) AND (h.last_close < h.current_close) AND ((h.previous_close < h.previous_open) OR (h.last_close < h.last_open)) AND (h.current_close >= h.current_open)) THEN 1
                    ELSE 0
                END AS ha_trend,
                CASE
                    WHEN ((h.current_close >= h.last_close) AND (h.last_close < h.previous_close)) THEN 1
                    ELSE 0
                END AS ha_bottom,
            s_1.nearest_break AS nearest_short_amount,
            s_1.previous_break AS previous_short_amount,
            s_1.nearest_distance AS nearest_cal_dist,
            s_1.previous_distance AS previous_cal_dist
           FROM (((((cal.v_full_long_current l
             JOIN vlt.rush_1230 r ON ((((l.code)::text = (r.code)::text) AND (r.load_date = CURRENT_DATE))))
             JOIN rtc.index_1230 i ON ((((l.category)::text = (i.category)::text) AND (i.load_date = CURRENT_DATE))))
             JOIN rtc.v_macd_comp_current_1230 m ON (((l.code)::text = (m.code)::text)))
             JOIN rtc.v_ha_comp_current_1230 h ON (((l.code)::text = (h.code)::text)))
             JOIN vlt.v_short_current s_1 ON (((l.code)::text = (s_1.code)::text)))
          WHERE ((i.load_date = CURRENT_DATE) AND (l.total_ranking <= 40) AND (l.category_ranking <= 4))
        )
 SELECT concat(t.category, '(', t.index_ha, ',', t.index_ema, ')') AS "category(ha,ema)",
    concat(t.code, '(', "substring"(((t.ranking_date)::character varying)::text, 6, 5), ')') AS "code(date)",
    concat(row_number() OVER (PARTITION BY t.category ORDER BY t.category_ranking), '(', t.category_ranking, ', ', t.total_ranking, ')') AS ranking,
        CASE
            WHEN ((t.ha_conversion = 1) AND (t.macd_conversion = 1)) THEN 'BOTH'::text
            WHEN ((t.ha_conversion = 1) AND (t.macd_conversion <> 1)) THEN 'HA'::text
            WHEN ((t.ha_conversion <> 1) AND (t.macd_conversion = 1)) THEN 'MACD'::text
            ELSE ''::text
        END AS conversion_type,
        CASE
            WHEN ((t.ha_trend = 1) AND (t.macd_trend = 1)) THEN 'BOTH'::text
            WHEN ((t.ha_trend = 1) AND (t.macd_trend <> 1)) THEN 'HA'::text
            WHEN ((t.ha_trend <> 1) AND (t.macd_trend = 1)) THEN 'MACD'::text
            ELSE ''::text
        END AS trend_type,
        CASE
            WHEN ((t.ha_bottom = 1) AND (t.macd_bottom = 1)) THEN 'BOTH'::text
            WHEN ((t.ha_bottom = 1) AND (t.macd_bottom <> 1)) THEN 'HA'::text
            WHEN ((t.ha_bottom <> 1) AND (t.macd_bottom = 1)) THEN 'MACD'::text
            ELSE ''::text
        END AS bottom_type,
    concat((t.nearest_short_amount)::character varying, '(', t.nearest_cal_dist, ')/', (t.previous_short_amount)::character varying, '(', t.previous_cal_dist, ')') AS short_indicator,
        CASE
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar <= t.high)) THEN concat(chr(1783), chr(1784))
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar > t.high)) THEN concat(chr(1783), chr(1783))
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar > t.low)) THEN concat(chr(1784), chr(1783))
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar <= t.low)) THEN concat(chr(1784), chr(1784))
            ELSE ''::text
        END AS sar,
    a.last_anc
   FROM ((temp t
     LEFT JOIN vlt.v_announcements a ON (((t.code)::text = (a.code)::text)))
     LEFT JOIN cal.v_sar_current s ON (((t.code)::text = (s.code)::text)))
  WHERE ((t.ha_conversion = 1) OR (t.macd_conversion = 1))
  ORDER BY t.total_ranking;


--
-- Name: ema_1345; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.ema_1345 (
    code character varying,
    load_date date,
    price numeric,
    ema15 numeric(8,4),
    ema40 numeric(8,4),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: ha_1345; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.ha_1345 (
    code character varying,
    load_date date,
    h_open numeric(10,4),
    h_high numeric(10,4),
    h_low numeric(10,4),
    h_close numeric(10,4),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: v_ema_1345_current; Type: VIEW; Schema: rtc; Owner: -
--

CREATE VIEW rtc.v_ema_1345_current AS
 SELECT ema_1345.code,
    ema_1345.load_date,
    ema_1345.price,
    ema_1345.ema15,
    ema_1345.ema40
   FROM rtc.ema_1345
  WHERE (ema_1345.load_date = ( SELECT max(ema_1345_1.load_date) AS max
           FROM rtc.ema_1345 ema_1345_1));


--
-- Name: v_ha_1345_sequence_current; Type: VIEW; Schema: rtc; Owner: -
--

CREATE VIEW rtc.v_ha_1345_sequence_current AS
 WITH idx AS (
         SELECT ha_1345.load_date,
            row_number() OVER (ORDER BY ha_1345.load_date DESC) AS rnum
           FROM rtc.ha_1345
          GROUP BY ha_1345.load_date
        ), ext AS (
         SELECT ha_1345.code,
            ha_1345.load_date,
            ha_1345.h_open,
            ha_1345.h_high,
            ha_1345.h_low,
            ha_1345.h_close,
            ha_1345.sys_load_time,
            lag(ha_1345.h_open, 1) OVER (PARTITION BY ha_1345.code ORDER BY ha_1345.load_date) AS last_open,
            lag(ha_1345.h_close, 1) OVER (PARTITION BY ha_1345.code ORDER BY ha_1345.load_date) AS last_close
           FROM rtc.ha_1345
        ), list AS (
         SELECT ext.code,
            ext.load_date,
            ext.h_open,
            ext.h_high,
            ext.h_low,
            ext.h_close,
            ext.sys_load_time,
            ext.last_open,
            ext.last_close,
            row_number() OVER (PARTITION BY ext.code ORDER BY ext.load_date DESC) AS rnum
           FROM ext
          WHERE (((ext.h_open <= ext.h_close) AND (ext.last_open > ext.last_close)) OR ((ext.h_open > ext.h_close) AND (ext.last_open <= ext.last_close)))
        ), cur AS (
         SELECT ha_1345.code,
            ha_1345.load_date,
            ha_1345.h_open,
            ha_1345.h_high,
            ha_1345.h_low,
            ha_1345.h_close,
            ha_1345.sys_load_time,
                CASE
                    WHEN ((ha_1345.h_close >= ha_1345.h_open) AND (ha_1345.h_open = ha_1345.h_low)) THEN 'Positive'::text
                    WHEN ((ha_1345.h_close < ha_1345.h_open) AND (ha_1345.h_open = ha_1345.h_high)) THEN 'Negative'::text
                    WHEN ((ha_1345.h_close >= ha_1345.h_open) AND (ha_1345.h_open > ha_1345.h_low)) THEN 'Long'::text
                    WHEN ((ha_1345.h_close < ha_1345.h_open) AND (ha_1345.h_open < ha_1345.h_high)) THEN 'Short'::text
                    ELSE NULL::text
                END AS status
           FROM rtc.ha_1345
          WHERE (ha_1345.load_date = ( SELECT max(ha_1345_1.load_date) AS max
                   FROM rtc.ha_1345 ha_1345_1))
        ), comb AS (
         SELECT l.code,
            l.load_date,
            i.rnum AS sequence
           FROM (list l
             JOIN idx i ON ((l.load_date = i.load_date)))
          WHERE (l.rnum = 1)
        ), output AS (
         SELECT b.code,
            c.load_date,
            b.sequence,
            c.status
           FROM (cur c
             JOIN comb b ON (((c.code)::text = (b.code)::text)))
        )
 SELECT output.code,
    output.load_date,
    output.sequence,
    output.status
   FROM output
  ORDER BY output.code;


--
-- Name: rush_1345; Type: TABLE; Schema: vlt; Owner: -
--

CREATE TABLE vlt.rush_1345 (
    code character varying,
    load_date date,
    high numeric,
    low numeric,
    open numeric(9,4),
    close numeric(9,4),
    typ3 numeric(9,4),
    typ4 numeric(9,4),
    sys_load_time timestamp without time zone DEFAULT now()
);


--
-- Name: v_rush_1345_current; Type: VIEW; Schema: vlt; Owner: -
--

CREATE VIEW vlt.v_rush_1345_current AS
 SELECT rush_1345.code,
    rush_1345.load_date,
    rush_1345.high,
    rush_1345.low,
    rush_1345.open,
    rush_1345.close,
    rush_1345.typ3,
    rush_1345.typ4
   FROM vlt.rush_1345
  WHERE (rush_1345.load_date = ( SELECT max(rush_1345_1.load_date) AS max
           FROM vlt.rush_1345 rush_1345_1));


--
-- Name: v_daily_long_report_1345; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_long_report_1345 AS
 SELECT concat(l.category, '(', i.daily_perf, ',', i.ema, ',', i.ha, ')') AS "category (daily/ema/ha)",
    concat(l.code, '(', "substring"(((l.last_update_date)::character varying)::text, 6, 5), ')') AS "code(update_ts)",
    concat(l.total_ranking, '(', l.category_ranking, ')') AS "ranking(in category)",
    e.price AS current_price,
        CASE
            WHEN (e.ema15 >= e.ema40) THEN 'BUY'::text
            ELSE 'SELL'::text
        END AS "option(ema)",
    concat(h.status, '(', h.sequence, ')') AS "status(ha)",
        CASE
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar <= r.high)) THEN '-+'::text
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar > r.high)) THEN '--'::text
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar > r.low)) THEN '+-'::text
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar <= r.low)) THEN '++'::text
            ELSE ''::text
        END AS sar,
    concat((t.nearest_break)::character varying, '(', t.nearest_distance, ')/', (t.previous_break)::character varying, '(', t.previous_distance, ')') AS short_indicator,
    a.last_anc,
    r.load_date
   FROM (((((((cal.v_full_long_current l
     JOIN vlt.v_rush_1345_current r ON (((l.code)::text = (r.code)::text)))
     LEFT JOIN rpt.v_daily_index_report_1345 i ON (((l.category)::text = (i.category)::text)))
     LEFT JOIN rtc.v_ema_1345_current e ON (((l.code)::text = (e.code)::text)))
     LEFT JOIN rtc.v_ha_1345_sequence_current h ON (((l.code)::text = (h.code)::text)))
     LEFT JOIN cal.v_sar_current s ON (((l.code)::text = (s.code)::text)))
     LEFT JOIN vlt.v_short_current t ON (((l.code)::text = (t.code)::text)))
     LEFT JOIN vlt.v_announcements a ON (((l.code)::text = (a.code)::text)))
  WHERE ((l.total_ranking <= 40) AND (l.category_ranking <= 4))
  ORDER BY l.total_ranking;


--
-- Name: macd_1345; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.macd_1345 (
    code character varying,
    load_date date,
    diff numeric,
    dea numeric(8,4),
    chart_type text,
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: v_ha_comp_current_1345; Type: VIEW; Schema: rtc; Owner: -
--

CREATE VIEW rtc.v_ha_comp_current_1345 AS
 WITH quotes AS (
         SELECT ha_1345.code,
            ha_1345.load_date,
            ha_1345.h_open AS open,
            ha_1345.h_close AS close
           FROM rtc.ha_1345
          WHERE (ha_1345.load_date = ( SELECT max(ha_1345_1.load_date) AS max
                   FROM rtc.ha_1345 ha_1345_1))
        UNION
         SELECT heikin_ashi.code,
            heikin_ashi.load_date,
            heikin_ashi.open,
            heikin_ashi.close
           FROM cal.heikin_ashi
          WHERE ((heikin_ashi.load_date < ( SELECT max(ha_1345.load_date) AS max
                   FROM rtc.ha_1345)) AND (heikin_ashi.load_date > ( SELECT (max(ha_1345.load_date) - 28)
                   FROM rtc.ha_1345)))
        ), comb AS (
         SELECT quotes.code,
            quotes.load_date,
            quotes.open AS current_open,
            quotes.close AS current_close,
            row_number() OVER (PARTITION BY quotes.code ORDER BY quotes.load_date DESC) AS rnum,
            lag(quotes.open, 1) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS last_open,
            lag(quotes.close, 1) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS last_close,
            lag(quotes.open, 2) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS previous_open,
            lag(quotes.close, 2) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS previous_close
           FROM quotes
        ), subset AS (
         SELECT comb.code,
            comb.load_date,
            comb.current_open,
            comb.current_close,
            comb.last_open,
            comb.last_close,
            comb.previous_open,
            comb.previous_close
           FROM comb
          WHERE (comb.load_date = ( SELECT max(comb_1.load_date) AS max
                   FROM comb comb_1))
        )
 SELECT subset.code,
    subset.load_date,
    subset.current_open,
    subset.current_close,
    subset.last_open,
    subset.last_close,
    subset.previous_open,
    subset.previous_close
   FROM subset;


--
-- Name: v_macd_comp_current_1345; Type: VIEW; Schema: rtc; Owner: -
--

CREATE VIEW rtc.v_macd_comp_current_1345 AS
 WITH quotes AS (
         SELECT macd_1345.code,
            macd_1345.load_date,
            macd_1345.diff,
            macd_1345.dea
           FROM rtc.macd_1345
          WHERE ((macd_1345.load_date = CURRENT_DATE) AND (macd_1345.chart_type = 'ha'::text))
        UNION
         SELECT macd.code,
            macd.load_date,
            macd.diff,
            macd.dea
           FROM cal.macd
          WHERE ((macd.load_date < CURRENT_DATE) AND (macd.load_date > (CURRENT_DATE - 28)))
        ), comb AS (
         SELECT quotes.code,
            quotes.load_date,
            quotes.diff AS current_diff,
            quotes.dea AS current_dea,
            row_number() OVER (PARTITION BY quotes.code ORDER BY quotes.load_date DESC) AS rnum,
            lag(quotes.diff, 1) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS last_diff,
            lag(quotes.dea, 1) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS last_dea,
            lag(quotes.diff, 2) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS previous_diff,
            lag(quotes.dea, 2) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS previous_dea
           FROM quotes
        ), subset AS (
         SELECT comb.code,
            comb.load_date,
            comb.current_diff,
            comb.current_dea,
            comb.last_diff,
            comb.last_dea,
            comb.previous_diff,
            comb.previous_dea
           FROM comb
          WHERE (comb.load_date = CURRENT_DATE)
        )
 SELECT subset.code,
    subset.load_date,
    subset.current_diff,
    subset.current_dea,
    subset.last_diff,
    subset.last_dea,
    subset.previous_diff,
    subset.previous_dea
   FROM subset;


--
-- Name: v_daily_long_report_1345_backup; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_long_report_1345_backup AS
 WITH temp AS (
         SELECT l.category,
            r.close,
            r.high,
            r.low,
            (
                CASE
                    WHEN (i.h_close >= i.h_open) THEN '+'::text
                    ELSE '-'::text
                END)::character varying AS index_ha,
            (
                CASE
                    WHEN (i.ema10 >= i.ema25) THEN '+'::text
                    ELSE '-'::text
                END)::character varying AS index_ema,
            l.code,
            l.last_update_date AS ranking_date,
            l.total_ranking,
            l.category_ranking,
                CASE
                    WHEN ((m.current_diff >= m.current_dea) AND (m.last_diff < m.last_dea)) THEN 1
                    ELSE 0
                END AS macd_conversion,
                CASE
                    WHEN (((m.current_diff - m.current_dea) >= (m.last_diff - m.last_dea)) AND ((m.last_diff - m.last_dea) >= (m.previous_diff - m.previous_dea))) THEN 1
                    ELSE 0
                END AS macd_trend,
                CASE
                    WHEN (((m.current_diff - m.current_dea) >= (m.last_diff - m.last_dea)) AND ((m.last_diff - m.last_dea) < (m.previous_diff - m.previous_dea))) THEN 1
                    ELSE 0
                END AS macd_bottom,
                CASE
                    WHEN ((h.current_close >= h.current_open) AND (h.last_close < h.last_open)) THEN 1
                    ELSE 0
                END AS ha_conversion,
                CASE
                    WHEN ((h.previous_close < h.last_close) AND (h.last_close < h.current_close) AND ((h.previous_close < h.previous_open) OR (h.last_close < h.last_open)) AND (h.current_close >= h.current_open)) THEN 1
                    ELSE 0
                END AS ha_trend,
                CASE
                    WHEN ((h.current_close >= h.last_close) AND (h.last_close < h.previous_close)) THEN 1
                    ELSE 0
                END AS ha_bottom,
            s_1.nearest_break AS nearest_short_amount,
            s_1.previous_break AS previous_short_amount,
            s_1.nearest_distance AS nearest_cal_dist,
            s_1.previous_distance AS previous_cal_dist
           FROM (((((cal.v_full_long_current l
             JOIN vlt.rush_1345 r ON ((((l.code)::text = (r.code)::text) AND (r.load_date = CURRENT_DATE))))
             JOIN rtc.index_1345 i ON ((((l.category)::text = (i.category)::text) AND (i.load_date = CURRENT_DATE))))
             JOIN rtc.v_macd_comp_current_1345 m ON (((l.code)::text = (m.code)::text)))
             JOIN rtc.v_ha_comp_current_1345 h ON (((l.code)::text = (h.code)::text)))
             JOIN vlt.v_short_current s_1 ON (((l.code)::text = (s_1.code)::text)))
          WHERE ((i.load_date = CURRENT_DATE) AND (l.total_ranking <= 40) AND (l.category_ranking <= 4))
        )
 SELECT concat(t.category, '(', t.index_ha, ',', t.index_ema, ')') AS "category(ha,ema)",
    concat(t.code, '(', "substring"(((t.ranking_date)::character varying)::text, 6, 5), ')') AS "code(date)",
    concat(row_number() OVER (PARTITION BY t.category ORDER BY t.category_ranking), '(', t.category_ranking, ', ', t.total_ranking, ')') AS ranking,
        CASE
            WHEN ((t.ha_conversion = 1) AND (t.macd_conversion = 1)) THEN 'BOTH'::text
            WHEN ((t.ha_conversion = 1) AND (t.macd_conversion <> 1)) THEN 'HA'::text
            WHEN ((t.ha_conversion <> 1) AND (t.macd_conversion = 1)) THEN 'MACD'::text
            ELSE ''::text
        END AS conversion_type,
        CASE
            WHEN ((t.ha_trend = 1) AND (t.macd_trend = 1)) THEN 'BOTH'::text
            WHEN ((t.ha_trend = 1) AND (t.macd_trend <> 1)) THEN 'HA'::text
            WHEN ((t.ha_trend <> 1) AND (t.macd_trend = 1)) THEN 'MACD'::text
            ELSE ''::text
        END AS trend_type,
        CASE
            WHEN ((t.ha_bottom = 1) AND (t.macd_bottom = 1)) THEN 'BOTH'::text
            WHEN ((t.ha_bottom = 1) AND (t.macd_bottom <> 1)) THEN 'HA'::text
            WHEN ((t.ha_bottom <> 1) AND (t.macd_bottom = 1)) THEN 'MACD'::text
            ELSE ''::text
        END AS bottom_type,
    concat((t.nearest_short_amount)::character varying, '(', t.nearest_cal_dist, ')/', (t.previous_short_amount)::character varying, '(', t.previous_cal_dist, ')') AS short_indicator,
        CASE
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar <= t.high)) THEN concat(chr(1783), chr(1784))
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar > t.high)) THEN concat(chr(1783), chr(1783))
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar > t.low)) THEN concat(chr(1784), chr(1783))
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar <= t.low)) THEN concat(chr(1784), chr(1784))
            ELSE ''::text
        END AS sar,
    a.last_anc
   FROM ((temp t
     LEFT JOIN vlt.v_announcements a ON (((t.code)::text = (a.code)::text)))
     LEFT JOIN cal.v_sar_current s ON (((t.code)::text = (s.code)::text)))
  WHERE ((t.ha_conversion = 1) OR (t.macd_conversion = 1))
  ORDER BY t.total_ranking;


--
-- Name: ema_1500; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.ema_1500 (
    code character varying,
    load_date date,
    price numeric,
    ema15 numeric(8,4),
    ema40 numeric(8,4),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: ha_1500; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.ha_1500 (
    code character varying,
    load_date date,
    h_open numeric(10,4),
    h_high numeric(10,4),
    h_low numeric(10,4),
    h_close numeric(10,4),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: v_ema_1500_current; Type: VIEW; Schema: rtc; Owner: -
--

CREATE VIEW rtc.v_ema_1500_current AS
 SELECT ema_1500.code,
    ema_1500.load_date,
    ema_1500.price,
    ema_1500.ema15,
    ema_1500.ema40
   FROM rtc.ema_1500
  WHERE (ema_1500.load_date = ( SELECT max(ema_1500_1.load_date) AS max
           FROM rtc.ema_1500 ema_1500_1));


--
-- Name: v_ha_1500_sequence_current; Type: VIEW; Schema: rtc; Owner: -
--

CREATE VIEW rtc.v_ha_1500_sequence_current AS
 WITH idx AS (
         SELECT ha_1500.load_date,
            row_number() OVER (ORDER BY ha_1500.load_date DESC) AS rnum
           FROM rtc.ha_1500
          GROUP BY ha_1500.load_date
        ), ext AS (
         SELECT ha_1500.code,
            ha_1500.load_date,
            ha_1500.h_open,
            ha_1500.h_high,
            ha_1500.h_low,
            ha_1500.h_close,
            ha_1500.sys_load_time,
            lag(ha_1500.h_open, 1) OVER (PARTITION BY ha_1500.code ORDER BY ha_1500.load_date) AS last_open,
            lag(ha_1500.h_close, 1) OVER (PARTITION BY ha_1500.code ORDER BY ha_1500.load_date) AS last_close
           FROM rtc.ha_1500
        ), list AS (
         SELECT ext.code,
            ext.load_date,
            ext.h_open,
            ext.h_high,
            ext.h_low,
            ext.h_close,
            ext.sys_load_time,
            ext.last_open,
            ext.last_close,
            row_number() OVER (PARTITION BY ext.code ORDER BY ext.load_date DESC) AS rnum
           FROM ext
          WHERE (((ext.h_open <= ext.h_close) AND (ext.last_open > ext.last_close)) OR ((ext.h_open > ext.h_close) AND (ext.last_open <= ext.last_close)))
        ), cur AS (
         SELECT ha_1500.code,
            ha_1500.load_date,
            ha_1500.h_open,
            ha_1500.h_high,
            ha_1500.h_low,
            ha_1500.h_close,
            ha_1500.sys_load_time,
                CASE
                    WHEN ((ha_1500.h_close >= ha_1500.h_open) AND (ha_1500.h_open = ha_1500.h_low)) THEN 'Positive'::text
                    WHEN ((ha_1500.h_close < ha_1500.h_open) AND (ha_1500.h_open = ha_1500.h_high)) THEN 'Negative'::text
                    WHEN ((ha_1500.h_close >= ha_1500.h_open) AND (ha_1500.h_open > ha_1500.h_low)) THEN 'Long'::text
                    WHEN ((ha_1500.h_close < ha_1500.h_open) AND (ha_1500.h_open < ha_1500.h_high)) THEN 'Short'::text
                    ELSE NULL::text
                END AS status
           FROM rtc.ha_1500
          WHERE (ha_1500.load_date = ( SELECT max(ha_1500_1.load_date) AS max
                   FROM rtc.ha_1500 ha_1500_1))
        ), comb AS (
         SELECT l.code,
            l.load_date,
            i.rnum AS sequence
           FROM (list l
             JOIN idx i ON ((l.load_date = i.load_date)))
          WHERE (l.rnum = 1)
        ), output AS (
         SELECT b.code,
            c.load_date,
            b.sequence,
            c.status
           FROM (cur c
             JOIN comb b ON (((c.code)::text = (b.code)::text)))
        )
 SELECT output.code,
    output.load_date,
    output.sequence,
    output.status
   FROM output
  ORDER BY output.code;


--
-- Name: rush_1500; Type: TABLE; Schema: vlt; Owner: -
--

CREATE TABLE vlt.rush_1500 (
    code character varying,
    load_date date,
    high numeric,
    low numeric,
    open numeric(9,4),
    close numeric(9,4),
    typ3 numeric(9,4),
    typ4 numeric(9,4),
    sys_load_time timestamp without time zone DEFAULT now()
);


--
-- Name: v_rush_1500_current; Type: VIEW; Schema: vlt; Owner: -
--

CREATE VIEW vlt.v_rush_1500_current AS
 SELECT rush_1500.code,
    rush_1500.load_date,
    rush_1500.high,
    rush_1500.low,
    rush_1500.open,
    rush_1500.close,
    rush_1500.typ3,
    rush_1500.typ4
   FROM vlt.rush_1500
  WHERE (rush_1500.load_date = ( SELECT max(rush_1500_1.load_date) AS max
           FROM vlt.rush_1500 rush_1500_1));


--
-- Name: v_daily_long_report_1500; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_long_report_1500 AS
 SELECT concat(l.category, '(', i.daily_perf, ',', i.ema, ',', i.ha, ')') AS "category (daily/ema/ha)",
    concat(l.code, '(', "substring"(((l.last_update_date)::character varying)::text, 6, 5), ')') AS "code(update_ts)",
    concat(l.total_ranking, '(', l.category_ranking, ')') AS "ranking(in category)",
    e.price AS current_price,
        CASE
            WHEN (e.ema15 >= e.ema40) THEN 'BUY'::text
            ELSE 'SELL'::text
        END AS "option(ema)",
    concat(h.status, '(', h.sequence, ')') AS "status(ha)",
        CASE
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar <= r.high)) THEN '-+'::text
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar > r.high)) THEN '--'::text
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar > r.low)) THEN '+-'::text
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar <= r.low)) THEN '++'::text
            ELSE ''::text
        END AS sar,
    concat((t.nearest_break)::character varying, '(', t.nearest_distance, ')/', (t.previous_break)::character varying, '(', t.previous_distance, ')') AS short_indicator,
    a.last_anc,
    r.load_date
   FROM (((((((cal.v_full_long_current l
     JOIN vlt.v_rush_1500_current r ON (((l.code)::text = (r.code)::text)))
     LEFT JOIN rpt.v_daily_index_report_1500 i ON (((l.category)::text = (i.category)::text)))
     LEFT JOIN rtc.v_ema_1500_current e ON (((l.code)::text = (e.code)::text)))
     LEFT JOIN rtc.v_ha_1500_sequence_current h ON (((l.code)::text = (h.code)::text)))
     LEFT JOIN cal.v_sar_current s ON (((l.code)::text = (s.code)::text)))
     LEFT JOIN vlt.v_short_current t ON (((l.code)::text = (t.code)::text)))
     LEFT JOIN vlt.v_announcements a ON (((l.code)::text = (a.code)::text)))
  WHERE ((l.total_ranking <= 40) AND (l.category_ranking <= 4))
  ORDER BY l.total_ranking;


--
-- Name: macd_1500; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.macd_1500 (
    code character varying,
    load_date date,
    diff numeric,
    dea numeric(8,4),
    chart_type text,
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: v_ha_comp_current_1500; Type: VIEW; Schema: rtc; Owner: -
--

CREATE VIEW rtc.v_ha_comp_current_1500 AS
 WITH quotes AS (
         SELECT ha_1500.code,
            ha_1500.load_date,
            ha_1500.h_open AS open,
            ha_1500.h_close AS close
           FROM rtc.ha_1500
          WHERE (ha_1500.load_date = ( SELECT max(ha_1230.load_date) AS max
                   FROM rtc.ha_1230))
        UNION
         SELECT heikin_ashi.code,
            heikin_ashi.load_date,
            heikin_ashi.open,
            heikin_ashi.close
           FROM cal.heikin_ashi
          WHERE ((heikin_ashi.load_date < ( SELECT max(ha_1500.load_date) AS max
                   FROM rtc.ha_1500)) AND (heikin_ashi.load_date > ( SELECT (max(ha_1500.load_date) - 28)
                   FROM rtc.ha_1500)))
        ), comb AS (
         SELECT quotes.code,
            quotes.load_date,
            quotes.open AS current_open,
            quotes.close AS current_close,
            row_number() OVER (PARTITION BY quotes.code ORDER BY quotes.load_date DESC) AS rnum,
            lag(quotes.open, 1) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS last_open,
            lag(quotes.close, 1) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS last_close,
            lag(quotes.open, 2) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS previous_open,
            lag(quotes.close, 2) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS previous_close
           FROM quotes
        ), subset AS (
         SELECT comb.code,
            comb.load_date,
            comb.current_open,
            comb.current_close,
            comb.last_open,
            comb.last_close,
            comb.previous_open,
            comb.previous_close
           FROM comb
          WHERE (comb.load_date = ( SELECT max(comb_1.load_date) AS max
                   FROM comb comb_1))
        )
 SELECT subset.code,
    subset.load_date,
    subset.current_open,
    subset.current_close,
    subset.last_open,
    subset.last_close,
    subset.previous_open,
    subset.previous_close
   FROM subset;


--
-- Name: v_macd_comp_current_1500; Type: VIEW; Schema: rtc; Owner: -
--

CREATE VIEW rtc.v_macd_comp_current_1500 AS
 WITH quotes AS (
         SELECT macd_1500.code,
            macd_1500.load_date,
            macd_1500.diff,
            macd_1500.dea
           FROM rtc.macd_1500
          WHERE ((macd_1500.load_date = CURRENT_DATE) AND (macd_1500.chart_type = 'ha'::text))
        UNION
         SELECT macd.code,
            macd.load_date,
            macd.diff,
            macd.dea
           FROM cal.macd
          WHERE ((macd.load_date < CURRENT_DATE) AND (macd.load_date > (CURRENT_DATE - 28)))
        ), comb AS (
         SELECT quotes.code,
            quotes.load_date,
            quotes.diff AS current_diff,
            quotes.dea AS current_dea,
            row_number() OVER (PARTITION BY quotes.code ORDER BY quotes.load_date DESC) AS rnum,
            lag(quotes.diff, 1) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS last_diff,
            lag(quotes.dea, 1) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS last_dea,
            lag(quotes.diff, 2) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS previous_diff,
            lag(quotes.dea, 2) OVER (PARTITION BY quotes.code ORDER BY quotes.load_date) AS previous_dea
           FROM quotes
        ), subset AS (
         SELECT comb.code,
            comb.load_date,
            comb.current_diff,
            comb.current_dea,
            comb.last_diff,
            comb.last_dea,
            comb.previous_diff,
            comb.previous_dea
           FROM comb
          WHERE (comb.load_date = CURRENT_DATE)
        )
 SELECT subset.code,
    subset.load_date,
    subset.current_diff,
    subset.current_dea,
    subset.last_diff,
    subset.last_dea,
    subset.previous_diff,
    subset.previous_dea
   FROM subset;


--
-- Name: v_daily_long_report_1500_backup; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_long_report_1500_backup AS
 WITH temp AS (
         SELECT l.category,
            r.close,
            r.high,
            r.low,
            (
                CASE
                    WHEN (i.h_close >= i.h_open) THEN '+'::text
                    ELSE '-'::text
                END)::character varying AS index_ha,
            (
                CASE
                    WHEN (i.ema10 >= i.ema25) THEN '+'::text
                    ELSE '-'::text
                END)::character varying AS index_ema,
            l.code,
            l.last_update_date AS ranking_date,
            l.total_ranking,
            l.category_ranking,
                CASE
                    WHEN ((m.current_diff >= m.current_dea) AND (m.last_diff < m.last_dea)) THEN 1
                    ELSE 0
                END AS macd_conversion,
                CASE
                    WHEN (((m.current_diff - m.current_dea) >= (m.last_diff - m.last_dea)) AND ((m.last_diff - m.last_dea) >= (m.previous_diff - m.previous_dea))) THEN 1
                    ELSE 0
                END AS macd_trend,
                CASE
                    WHEN (((m.current_diff - m.current_dea) >= (m.last_diff - m.last_dea)) AND ((m.last_diff - m.last_dea) < (m.previous_diff - m.previous_dea))) THEN 1
                    ELSE 0
                END AS macd_bottom,
                CASE
                    WHEN ((h.current_close >= h.current_open) AND (h.last_close < h.last_open)) THEN 1
                    ELSE 0
                END AS ha_conversion,
                CASE
                    WHEN ((h.previous_close < h.last_close) AND (h.last_close < h.current_close) AND ((h.previous_close < h.previous_open) OR (h.last_close < h.last_open)) AND (h.current_close >= h.current_open)) THEN 1
                    ELSE 0
                END AS ha_trend,
                CASE
                    WHEN ((h.current_close >= h.last_close) AND (h.last_close < h.previous_close)) THEN 1
                    ELSE 0
                END AS ha_bottom,
            s_1.nearest_break AS nearest_short_amount,
            s_1.previous_break AS previous_short_amount,
            s_1.nearest_distance AS nearest_cal_dist,
            s_1.previous_distance AS previous_cal_dist
           FROM (((((cal.v_full_long_current l
             JOIN vlt.rush_1500 r ON ((((l.code)::text = (r.code)::text) AND (r.load_date = CURRENT_DATE))))
             JOIN rtc.index_1500 i ON ((((l.category)::text = (i.category)::text) AND (i.load_date = CURRENT_DATE))))
             JOIN rtc.v_macd_comp_current_1500 m ON (((l.code)::text = (m.code)::text)))
             JOIN rtc.v_ha_comp_current_1500 h ON (((l.code)::text = (h.code)::text)))
             JOIN vlt.v_short_current s_1 ON (((l.code)::text = (s_1.code)::text)))
          WHERE ((i.load_date = CURRENT_DATE) AND (l.total_ranking <= 40) AND (l.category_ranking <= 4))
        )
 SELECT concat(t.category, '(', t.index_ha, ',', t.index_ema, ')') AS "category(ha,ema)",
    concat(t.code, '(', "substring"(((t.ranking_date)::character varying)::text, 6, 5), ')') AS "code(date)",
    concat(row_number() OVER (PARTITION BY t.category ORDER BY t.category_ranking), '(', t.category_ranking, ', ', t.total_ranking, ')') AS ranking,
        CASE
            WHEN ((t.ha_conversion = 1) AND (t.macd_conversion = 1)) THEN 'BOTH'::text
            WHEN ((t.ha_conversion = 1) AND (t.macd_conversion <> 1)) THEN 'HA'::text
            WHEN ((t.ha_conversion <> 1) AND (t.macd_conversion = 1)) THEN 'MACD'::text
            ELSE ''::text
        END AS conversion_type,
        CASE
            WHEN ((t.ha_trend = 1) AND (t.macd_trend = 1)) THEN 'BOTH'::text
            WHEN ((t.ha_trend = 1) AND (t.macd_trend <> 1)) THEN 'HA'::text
            WHEN ((t.ha_trend <> 1) AND (t.macd_trend = 1)) THEN 'MACD'::text
            ELSE ''::text
        END AS trend_type,
        CASE
            WHEN ((t.ha_bottom = 1) AND (t.macd_bottom = 1)) THEN 'BOTH'::text
            WHEN ((t.ha_bottom = 1) AND (t.macd_bottom <> 1)) THEN 'HA'::text
            WHEN ((t.ha_bottom <> 1) AND (t.macd_bottom = 1)) THEN 'MACD'::text
            ELSE ''::text
        END AS bottom_type,
    concat((t.nearest_short_amount)::character varying, '(', t.nearest_cal_dist, ')/', (t.previous_short_amount)::character varying, '(', t.previous_cal_dist, ')') AS short_indicator,
        CASE
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar <= t.high)) THEN concat(chr(1783), chr(1784))
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar > t.high)) THEN concat(chr(1783), chr(1783))
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar > t.low)) THEN concat(chr(1784), chr(1783))
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar <= t.low)) THEN concat(chr(1784), chr(1784))
            ELSE ''::text
        END AS sar,
    a.last_anc
   FROM ((temp t
     LEFT JOIN vlt.v_announcements a ON (((t.code)::text = (a.code)::text)))
     LEFT JOIN cal.v_sar_current s ON (((t.code)::text = (s.code)::text)))
  WHERE ((t.ha_conversion = 1) OR (t.macd_conversion = 1))
  ORDER BY t.total_ranking;


--
-- Name: v_daily_long_summary; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_long_summary AS
 SELECT long_summary_report."category (EMA,HA,DIRC)" AS "category (EMA/HA/DIRC)",
    long_summary_report.code,
    long_summary_report.price,
    long_summary_report.ranking,
    long_summary_report.option,
    long_summary_report.status,
    long_summary_report.trend,
    long_summary_report.volume,
    long_summary_report.daily_range,
    long_summary_report.short_indicator,
    long_summary_report.sar,
    long_summary_report.last_anc,
    long_summary_report.load_date
   FROM rpt.long_summary_report
  WHERE ((long_summary_report.load_date = ( SELECT max(long_summary_report_1.load_date) AS max
           FROM rpt.long_summary_report long_summary_report_1)) AND (long_summary_report.rnum <= 70) AND (long_summary_report.cnum <= 6));


--
-- Name: v_daily_long_summary_backup; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_long_summary_backup AS
 SELECT long_summary_report_backup.category,
    long_summary_report_backup.code,
    long_summary_report_backup.ranking,
    long_summary_report_backup.option,
    long_summary_report_backup.status,
    long_summary_report_backup.trend,
    long_summary_report_backup.volume,
    long_summary_report_backup.daily_range,
    long_summary_report_backup.load_date
   FROM rpt.long_summary_report_backup
  WHERE (long_summary_report_backup.load_date = ( SELECT max(long_summary_report_1.load_date) AS max
           FROM rpt.long_summary_report_backup long_summary_report_1))
  ORDER BY long_summary_report_backup.rnum;


--
-- Name: v_daily_short_report_1230; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_short_report_1230 AS
 SELECT concat(l.category, '(', i.daily_perf, ',', i.ema, ',', i.ha, ')') AS "category (daily/ema/ha)",
    concat(l.code, '(', "substring"(((l.last_update_date)::character varying)::text, 6, 5), ')') AS "code(update_ts)",
    concat(l.total_ranking, '(', l.category_ranking, ')') AS "ranking(in category)",
    e.price AS current_price,
        CASE
            WHEN (e.ema15 >= e.ema40) THEN 'BUY'::text
            ELSE 'SELL'::text
        END AS "option(ema)",
    concat(h.status, '(', h.sequence, ')') AS "status(ha)",
        CASE
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar <= r.high)) THEN '-+'::text
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar > r.high)) THEN '--'::text
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar > r.low)) THEN '+-'::text
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar <= r.low)) THEN '++'::text
            ELSE ''::text
        END AS sar,
    concat((t.nearest_break)::character varying, '(', t.nearest_distance, ')/', (t.previous_break)::character varying, '(', t.previous_distance, ')') AS short_indicator,
    a.last_anc,
    r.load_date
   FROM (((((((cal.v_full_short_current l
     JOIN vlt.v_rush_1230_current r ON (((l.code)::text = (r.code)::text)))
     LEFT JOIN rpt.v_daily_index_report_1230 i ON (((l.category)::text = (i.category)::text)))
     LEFT JOIN rtc.v_ema_1230_current e ON (((l.code)::text = (e.code)::text)))
     LEFT JOIN rtc.v_ha_1230_sequence_current h ON (((l.code)::text = (h.code)::text)))
     LEFT JOIN cal.v_sar_current s ON (((l.code)::text = (s.code)::text)))
     LEFT JOIN vlt.v_short_current t ON (((l.code)::text = (t.code)::text)))
     LEFT JOIN vlt.v_announcements a ON (((l.code)::text = (a.code)::text)))
  WHERE ((l.total_ranking <= 40) AND (l.category_ranking <= 4))
  ORDER BY l.total_ranking;


--
-- Name: v_daily_short_report_1230_backup; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_short_report_1230_backup AS
 WITH temp AS (
         SELECT l.category,
            r.close,
            r.high,
            r.low,
            (
                CASE
                    WHEN (i.h_close >= i.h_open) THEN '+'::text
                    ELSE '-'::text
                END)::character varying AS index_ha,
            (
                CASE
                    WHEN (i.ema10 >= i.ema25) THEN '+'::text
                    ELSE '-'::text
                END)::character varying AS index_ema,
            l.code,
            l.last_update_date AS ranking_date,
            l.total_ranking,
            l.category_ranking,
                CASE
                    WHEN ((m.current_diff < m.current_dea) AND (m.last_diff >= m.last_dea)) THEN 1
                    ELSE 0
                END AS macd_conversion,
                CASE
                    WHEN (((m.current_diff - m.current_dea) < (m.last_diff - m.last_dea)) AND ((m.last_diff - m.last_dea) < (m.previous_diff - m.previous_dea))) THEN 1
                    ELSE 0
                END AS macd_trend,
                CASE
                    WHEN (((m.current_diff - m.current_dea) < (m.last_diff - m.last_dea)) AND ((m.last_diff - m.last_dea) >= (m.previous_diff - m.previous_dea))) THEN 1
                    ELSE 0
                END AS macd_top,
                CASE
                    WHEN ((h.current_close < h.current_open) AND (h.last_close >= h.last_open)) THEN 1
                    ELSE 0
                END AS ha_conversion,
                CASE
                    WHEN ((h.previous_close >= h.last_close) AND (h.last_close >= h.current_close) AND ((h.previous_close >= h.previous_open) OR (h.last_close >= h.last_open)) AND (h.current_close < h.current_open)) THEN 1
                    ELSE 0
                END AS ha_trend,
                CASE
                    WHEN ((h.current_close < h.last_close) AND (h.last_close >= h.previous_close)) THEN 1
                    ELSE 0
                END AS ha_top,
            s_1.nearest_break AS nearest_short_amount,
            s_1.previous_break AS previous_short_amount,
            s_1.nearest_distance AS nearest_cal_dist,
            s_1.previous_distance AS previous_cal_dist
           FROM (((((cal.v_full_short_current l
             JOIN vlt.rush_1230 r ON ((((l.code)::text = (r.code)::text) AND (r.load_date = CURRENT_DATE))))
             JOIN rtc.index_1230 i ON ((((l.category)::text = (i.category)::text) AND (i.load_date = CURRENT_DATE))))
             JOIN rtc.v_macd_comp_current_1230 m ON (((l.code)::text = (m.code)::text)))
             JOIN rtc.v_ha_comp_current_1230 h ON (((l.code)::text = (h.code)::text)))
             JOIN vlt.v_short_current s_1 ON (((l.code)::text = (s_1.code)::text)))
          WHERE ((l.total_ranking <= 40) AND (l.category_ranking <= 4))
        )
 SELECT concat(t.category, '(', t.index_ha, ',', t.index_ema, ')') AS "category(ha,ema)",
    concat(t.code, '(', "substring"(((t.ranking_date)::character varying)::text, 6, 5), ')') AS "code(date)",
    concat(row_number() OVER (PARTITION BY t.category ORDER BY t.category_ranking), '(', t.category_ranking, ', ', t.total_ranking, ')') AS ranking,
        CASE
            WHEN ((t.ha_conversion = 1) AND (t.macd_conversion = 1)) THEN 'BOTH'::text
            WHEN ((t.ha_conversion = 1) AND (t.macd_conversion <> 1)) THEN 'HA'::text
            WHEN ((t.ha_conversion <> 1) AND (t.macd_conversion = 1)) THEN 'MACD'::text
            ELSE ''::text
        END AS conversion_type,
        CASE
            WHEN ((t.ha_trend = 1) AND (t.macd_trend = 1)) THEN 'BOTH'::text
            WHEN ((t.ha_trend = 1) AND (t.macd_trend <> 1)) THEN 'HA'::text
            WHEN ((t.ha_trend <> 1) AND (t.macd_trend = 1)) THEN 'MACD'::text
            ELSE ''::text
        END AS trend_type,
        CASE
            WHEN ((t.ha_top = 1) AND (t.macd_top = 1)) THEN 'BOTH'::text
            WHEN ((t.ha_top = 1) AND (t.macd_top <> 1)) THEN 'HA'::text
            WHEN ((t.ha_top <> 1) AND (t.macd_top = 1)) THEN 'MACD'::text
            ELSE ''::text
        END AS bottom_type,
    concat((t.nearest_short_amount)::character varying, '(', t.nearest_cal_dist, ')/', (t.previous_short_amount)::character varying, '(', t.previous_cal_dist, ')') AS short_indicator,
        CASE
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar <= t.high)) THEN concat(chr(1783), chr(1784))
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar > t.high)) THEN concat(chr(1783), chr(1783))
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar > t.low)) THEN concat(chr(1784), chr(1783))
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar <= t.low)) THEN concat(chr(1784), chr(1784))
            ELSE ''::text
        END AS sar,
    a.last_anc
   FROM ((temp t
     LEFT JOIN vlt.v_announcements a ON (((t.code)::text = (a.code)::text)))
     LEFT JOIN cal.v_sar_current s ON (((t.code)::text = (s.code)::text)))
  WHERE ((t.ha_conversion = 1) OR (t.macd_conversion = 1))
  ORDER BY t.total_ranking;


--
-- Name: v_daily_short_report_1345; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_short_report_1345 AS
 SELECT concat(l.category, '(', i.daily_perf, ',', i.ema, ',', i.ha, ')') AS "category (daily/ema/ha)",
    concat(l.code, '(', "substring"(((l.last_update_date)::character varying)::text, 6, 5), ')') AS "code(update_ts)",
    concat(l.total_ranking, '(', l.category_ranking, ')') AS "ranking(in category)",
    e.price AS current_price,
        CASE
            WHEN (e.ema15 >= e.ema40) THEN 'BUY'::text
            ELSE 'SELL'::text
        END AS "option(ema)",
    concat(h.status, '(', h.sequence, ')') AS "status(ha)",
        CASE
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar <= r.high)) THEN '-+'::text
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar > r.high)) THEN '--'::text
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar > r.low)) THEN '+-'::text
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar <= r.low)) THEN '++'::text
            ELSE ''::text
        END AS sar,
    concat((t.nearest_break)::character varying, '(', t.nearest_distance, ')/', (t.previous_break)::character varying, '(', t.previous_distance, ')') AS short_indicator,
    a.last_anc,
    r.load_date
   FROM (((((((cal.v_full_short_current l
     JOIN vlt.v_rush_1345_current r ON (((l.code)::text = (r.code)::text)))
     LEFT JOIN rpt.v_daily_index_report_1345 i ON (((l.category)::text = (i.category)::text)))
     LEFT JOIN rtc.v_ema_1345_current e ON (((l.code)::text = (e.code)::text)))
     LEFT JOIN rtc.v_ha_1345_sequence_current h ON (((l.code)::text = (h.code)::text)))
     LEFT JOIN cal.v_sar_current s ON (((l.code)::text = (s.code)::text)))
     LEFT JOIN vlt.v_short_current t ON (((l.code)::text = (t.code)::text)))
     LEFT JOIN vlt.v_announcements a ON (((l.code)::text = (a.code)::text)))
  WHERE ((l.total_ranking <= 40) AND (l.category_ranking <= 4))
  ORDER BY l.total_ranking;


--
-- Name: v_daily_short_report_1345_backup; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_short_report_1345_backup AS
 WITH temp AS (
         SELECT l.category,
            r.close,
            r.high,
            r.low,
            (
                CASE
                    WHEN (i.h_close >= i.h_open) THEN '+'::text
                    ELSE '-'::text
                END)::character varying AS index_ha,
            (
                CASE
                    WHEN (i.ema10 >= i.ema25) THEN '+'::text
                    ELSE '-'::text
                END)::character varying AS index_ema,
            l.code,
            l.last_update_date AS ranking_date,
            l.total_ranking,
            l.category_ranking,
                CASE
                    WHEN ((m.current_diff < m.current_dea) AND (m.last_diff >= m.last_dea)) THEN 1
                    ELSE 0
                END AS macd_conversion,
                CASE
                    WHEN (((m.current_diff - m.current_dea) < (m.last_diff - m.last_dea)) AND ((m.last_diff - m.last_dea) < (m.previous_diff - m.previous_dea))) THEN 1
                    ELSE 0
                END AS macd_trend,
                CASE
                    WHEN (((m.current_diff - m.current_dea) < (m.last_diff - m.last_dea)) AND ((m.last_diff - m.last_dea) >= (m.previous_diff - m.previous_dea))) THEN 1
                    ELSE 0
                END AS macd_top,
                CASE
                    WHEN ((h.current_close < h.current_open) AND (h.last_close >= h.last_open)) THEN 1
                    ELSE 0
                END AS ha_conversion,
                CASE
                    WHEN ((h.previous_close >= h.last_close) AND (h.last_close >= h.current_close) AND ((h.previous_close >= h.previous_open) OR (h.last_close >= h.last_open)) AND (h.current_close < h.current_open)) THEN 1
                    ELSE 0
                END AS ha_trend,
                CASE
                    WHEN ((h.current_close < h.last_close) AND (h.last_close >= h.previous_close)) THEN 1
                    ELSE 0
                END AS ha_top,
            s_1.nearest_break AS nearest_short_amount,
            s_1.previous_break AS previous_short_amount,
            s_1.nearest_distance AS nearest_cal_dist,
            s_1.previous_distance AS previous_cal_dist
           FROM (((((cal.v_full_short_current l
             JOIN vlt.rush_1345 r ON ((((l.code)::text = (r.code)::text) AND (r.load_date = CURRENT_DATE))))
             JOIN rtc.index_1345 i ON ((((l.category)::text = (i.category)::text) AND (i.load_date = CURRENT_DATE))))
             JOIN rtc.v_macd_comp_current_1345 m ON (((l.code)::text = (m.code)::text)))
             JOIN rtc.v_ha_comp_current_1345 h ON (((l.code)::text = (h.code)::text)))
             JOIN vlt.v_short_current s_1 ON (((l.code)::text = (s_1.code)::text)))
          WHERE ((l.total_ranking <= 40) AND (l.category_ranking <= 4))
        )
 SELECT concat(t.category, '(', t.index_ha, ',', t.index_ema, ')') AS "category(ha,ema)",
    concat(t.code, '(', "substring"(((t.ranking_date)::character varying)::text, 6, 5), ')') AS "code(date)",
    concat(row_number() OVER (PARTITION BY t.category ORDER BY t.category_ranking), '(', t.category_ranking, ', ', t.total_ranking, ')') AS ranking,
        CASE
            WHEN ((t.ha_conversion = 1) AND (t.macd_conversion = 1)) THEN 'BOTH'::text
            WHEN ((t.ha_conversion = 1) AND (t.macd_conversion <> 1)) THEN 'HA'::text
            WHEN ((t.ha_conversion <> 1) AND (t.macd_conversion = 1)) THEN 'MACD'::text
            ELSE ''::text
        END AS conversion_type,
        CASE
            WHEN ((t.ha_trend = 1) AND (t.macd_trend = 1)) THEN 'BOTH'::text
            WHEN ((t.ha_trend = 1) AND (t.macd_trend <> 1)) THEN 'HA'::text
            WHEN ((t.ha_trend <> 1) AND (t.macd_trend = 1)) THEN 'MACD'::text
            ELSE ''::text
        END AS trend_type,
        CASE
            WHEN ((t.ha_top = 1) AND (t.macd_top = 1)) THEN 'BOTH'::text
            WHEN ((t.ha_top = 1) AND (t.macd_top <> 1)) THEN 'HA'::text
            WHEN ((t.ha_top <> 1) AND (t.macd_top = 1)) THEN 'MACD'::text
            ELSE ''::text
        END AS bottom_type,
    concat((t.nearest_short_amount)::character varying, '(', t.nearest_cal_dist, ')/', (t.previous_short_amount)::character varying, '(', t.previous_cal_dist, ')') AS short_indicator,
        CASE
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar <= t.high)) THEN concat(chr(1783), chr(1784))
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar > t.high)) THEN concat(chr(1783), chr(1783))
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar > t.low)) THEN concat(chr(1784), chr(1783))
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar <= t.low)) THEN concat(chr(1784), chr(1784))
            ELSE ''::text
        END AS sar,
    a.last_anc
   FROM ((temp t
     LEFT JOIN vlt.v_announcements a ON (((t.code)::text = (a.code)::text)))
     LEFT JOIN cal.v_sar_current s ON (((t.code)::text = (s.code)::text)))
  WHERE ((t.ha_conversion = 1) OR (t.macd_conversion = 1))
  ORDER BY t.total_ranking;


--
-- Name: v_daily_short_report_1500; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_short_report_1500 AS
 SELECT concat(l.category, '(', i.daily_perf, ',', i.ema, ',', i.ha, ')') AS "category (daily/ema/ha)",
    concat(l.code, '(', "substring"(((l.last_update_date)::character varying)::text, 6, 5), ')') AS "code(update_ts)",
    concat(l.total_ranking, '(', l.category_ranking, ')') AS "ranking(in category)",
    e.price AS current_price,
        CASE
            WHEN (e.ema15 >= e.ema40) THEN 'BUY'::text
            ELSE 'SELL'::text
        END AS "option(ema)",
    concat(h.status, '(', h.sequence, ')') AS "status(ha)",
        CASE
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar <= r.high)) THEN '-+'::text
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar > r.high)) THEN '--'::text
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar > r.low)) THEN '+-'::text
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar <= r.low)) THEN '++'::text
            ELSE ''::text
        END AS sar,
    concat((t.nearest_break)::character varying, '(', t.nearest_distance, ')/', (t.previous_break)::character varying, '(', t.previous_distance, ')') AS short_indicator,
    a.last_anc,
    r.load_date
   FROM (((((((cal.v_full_short_current l
     JOIN vlt.v_rush_1500_current r ON (((l.code)::text = (r.code)::text)))
     LEFT JOIN rpt.v_daily_index_report_1500 i ON (((l.category)::text = (i.category)::text)))
     LEFT JOIN rtc.v_ema_1500_current e ON (((l.code)::text = (e.code)::text)))
     LEFT JOIN rtc.v_ha_1500_sequence_current h ON (((l.code)::text = (h.code)::text)))
     LEFT JOIN cal.v_sar_current s ON (((l.code)::text = (s.code)::text)))
     LEFT JOIN vlt.v_short_current t ON (((l.code)::text = (t.code)::text)))
     LEFT JOIN vlt.v_announcements a ON (((l.code)::text = (a.code)::text)))
  WHERE ((l.total_ranking <= 40) AND (l.category_ranking <= 4))
  ORDER BY l.total_ranking;


--
-- Name: v_daily_short_report_1500_backup; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_short_report_1500_backup AS
 WITH temp AS (
         SELECT l.category,
            r.close,
            r.high,
            r.low,
            (
                CASE
                    WHEN (i.h_close >= i.h_open) THEN '+'::text
                    ELSE '-'::text
                END)::character varying AS index_ha,
            (
                CASE
                    WHEN (i.ema10 >= i.ema25) THEN '+'::text
                    ELSE '-'::text
                END)::character varying AS index_ema,
            l.code,
            l.last_update_date AS ranking_date,
            l.total_ranking,
            l.category_ranking,
                CASE
                    WHEN ((m.current_diff < m.current_dea) AND (m.last_diff >= m.last_dea)) THEN 1
                    ELSE 0
                END AS macd_conversion,
                CASE
                    WHEN (((m.current_diff - m.current_dea) < (m.last_diff - m.last_dea)) AND ((m.last_diff - m.last_dea) < (m.previous_diff - m.previous_dea))) THEN 1
                    ELSE 0
                END AS macd_trend,
                CASE
                    WHEN (((m.current_diff - m.current_dea) < (m.last_diff - m.last_dea)) AND ((m.last_diff - m.last_dea) >= (m.previous_diff - m.previous_dea))) THEN 1
                    ELSE 0
                END AS macd_top,
                CASE
                    WHEN ((h.current_close < h.current_open) AND (h.last_close >= h.last_open)) THEN 1
                    ELSE 0
                END AS ha_conversion,
                CASE
                    WHEN ((h.previous_close >= h.last_close) AND (h.last_close >= h.current_close) AND ((h.previous_close >= h.previous_open) OR (h.last_close >= h.last_open)) AND (h.current_close < h.current_open)) THEN 1
                    ELSE 0
                END AS ha_trend,
                CASE
                    WHEN ((h.current_close < h.last_close) AND (h.last_close >= h.previous_close)) THEN 1
                    ELSE 0
                END AS ha_top,
            s_1.nearest_break AS nearest_short_amount,
            s_1.previous_break AS previous_short_amount,
            s_1.nearest_distance AS nearest_cal_dist,
            s_1.previous_distance AS previous_cal_dist
           FROM (((((cal.v_full_short_current l
             JOIN vlt.rush_1500 r ON ((((l.code)::text = (r.code)::text) AND (r.load_date = CURRENT_DATE))))
             JOIN rtc.index_1500 i ON ((((l.category)::text = (i.category)::text) AND (i.load_date = CURRENT_DATE))))
             JOIN rtc.v_macd_comp_current_1500 m ON (((l.code)::text = (m.code)::text)))
             JOIN rtc.v_ha_comp_current_1500 h ON (((l.code)::text = (h.code)::text)))
             JOIN vlt.v_short_current s_1 ON (((l.code)::text = (s_1.code)::text)))
          WHERE ((l.total_ranking <= 40) AND (l.category_ranking <= 4))
        )
 SELECT concat(t.category, '(', t.index_ha, ',', t.index_ema, ')') AS "category(ha,ema)",
    concat(t.code, '(', "substring"(((t.ranking_date)::character varying)::text, 6, 5), ')') AS "code(date)",
    concat(row_number() OVER (PARTITION BY t.category ORDER BY t.category_ranking), '(', t.category_ranking, ', ', t.total_ranking, ')') AS ranking,
        CASE
            WHEN ((t.ha_conversion = 1) AND (t.macd_conversion = 1)) THEN 'BOTH'::text
            WHEN ((t.ha_conversion = 1) AND (t.macd_conversion <> 1)) THEN 'HA'::text
            WHEN ((t.ha_conversion <> 1) AND (t.macd_conversion = 1)) THEN 'MACD'::text
            ELSE ''::text
        END AS conversion_type,
        CASE
            WHEN ((t.ha_trend = 1) AND (t.macd_trend = 1)) THEN 'BOTH'::text
            WHEN ((t.ha_trend = 1) AND (t.macd_trend <> 1)) THEN 'HA'::text
            WHEN ((t.ha_trend <> 1) AND (t.macd_trend = 1)) THEN 'MACD'::text
            ELSE ''::text
        END AS trend_type,
        CASE
            WHEN ((t.ha_top = 1) AND (t.macd_top = 1)) THEN 'BOTH'::text
            WHEN ((t.ha_top = 1) AND (t.macd_top <> 1)) THEN 'HA'::text
            WHEN ((t.ha_top <> 1) AND (t.macd_top = 1)) THEN 'MACD'::text
            ELSE ''::text
        END AS bottom_type,
    concat((t.nearest_short_amount)::character varying, '(', t.nearest_cal_dist, ')/', (t.previous_short_amount)::character varying, '(', t.previous_cal_dist, ')') AS short_indicator,
        CASE
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar <= t.high)) THEN concat(chr(1783), chr(1784))
            WHEN (((s.ud_trend)::text = 'down'::text) AND (s.n_sar > t.high)) THEN concat(chr(1783), chr(1783))
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar > t.low)) THEN concat(chr(1784), chr(1783))
            WHEN (((s.ud_trend)::text = 'up'::text) AND (s.n_sar <= t.low)) THEN concat(chr(1784), chr(1784))
            ELSE ''::text
        END AS sar,
    a.last_anc
   FROM ((temp t
     LEFT JOIN vlt.v_announcements a ON (((t.code)::text = (a.code)::text)))
     LEFT JOIN cal.v_sar_current s ON (((t.code)::text = (s.code)::text)))
  WHERE ((t.ha_conversion = 1) OR (t.macd_conversion = 1))
  ORDER BY t.total_ranking;


--
-- Name: v_daily_short_summary; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_short_summary AS
 SELECT short_summary_report."category (EMA,HA,DIRC)" AS "category (EMA/HA/DIRC)",
    short_summary_report.code,
    short_summary_report.price,
    short_summary_report.ranking,
    short_summary_report.option,
    short_summary_report.status,
    short_summary_report.trend,
    short_summary_report.volume,
    short_summary_report.daily_range,
    short_summary_report.short_indicator,
    short_summary_report.sar,
    short_summary_report.last_anc,
    short_summary_report.load_date
   FROM rpt.short_summary_report
  WHERE ((short_summary_report.load_date = ( SELECT max(short_summary_report_1.load_date) AS max
           FROM rpt.short_summary_report short_summary_report_1)) AND (short_summary_report.rnum <= 70) AND (short_summary_report.cnum <= 6));


--
-- Name: v_daily_short_summary_backup; Type: VIEW; Schema: rpt; Owner: -
--

CREATE VIEW rpt.v_daily_short_summary_backup AS
 SELECT short_summary_report_backup.category,
    short_summary_report_backup.code,
    short_summary_report_backup.ranking,
    short_summary_report_backup.option,
    short_summary_report_backup.status,
    short_summary_report_backup.trend,
    short_summary_report_backup.volume,
    short_summary_report_backup.daily_range,
    short_summary_report_backup.load_date
   FROM rpt.short_summary_report_backup
  WHERE (short_summary_report_backup.load_date = ( SELECT max(short_summary_report_1.load_date) AS max
           FROM rpt.short_summary_report_backup short_summary_report_1))
  ORDER BY short_summary_report_backup.rnum;


--
-- Name: ema_on_ha_1230; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.ema_on_ha_1230 (
    code character varying,
    load_date date,
    price numeric,
    ema15 numeric(8,4),
    ema40 numeric(8,4),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: ema_on_ha_1345; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.ema_on_ha_1345 (
    code character varying,
    load_date date,
    price numeric,
    ema15 numeric(8,4),
    ema40 numeric(8,4),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: ema_on_ha_1500; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.ema_on_ha_1500 (
    code character varying,
    load_date date,
    price numeric,
    ema15 numeric(8,4),
    ema40 numeric(8,4),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: list_1230; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.list_1230 (
    category character varying,
    code character varying,
    load_date date,
    popularity numeric(2,1),
    sar text,
    trend character varying,
    reporting_date bigint,
    expect_ratio text,
    rec character varying,
    financial_healthy numeric(3,2),
    pe_ranking numeric(4,3),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: list_1345; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.list_1345 (
    category character varying,
    code character varying,
    load_date date,
    popularity numeric(2,1),
    sar text,
    trend character varying,
    reporting_date bigint,
    expect_ratio text,
    rec character varying,
    financial_healthy numeric(3,2),
    pe_ranking numeric(4,3),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: list_1500; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.list_1500 (
    category character varying,
    code character varying,
    load_date date,
    popularity numeric(2,1),
    sar text,
    trend character varying,
    reporting_date bigint,
    expect_ratio text,
    rec character varying,
    financial_healthy numeric(3,2),
    pe_ranking numeric(4,3),
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: trend_1230; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.trend_1230 (
    code character varying,
    load_date date,
    direction character varying,
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: trend_1345; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.trend_1345 (
    code character varying,
    load_date date,
    direction character varying,
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: trend_1500; Type: TABLE; Schema: rtc; Owner: -
--

CREATE TABLE rtc.trend_1500 (
    code character varying,
    load_date date,
    direction character varying,
    sys_load_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: v_current_list_1230; Type: VIEW; Schema: rtc; Owner: -
--

CREATE VIEW rtc.v_current_list_1230 AS
 SELECT list_1230.category,
    list_1230.code,
    list_1230.popularity,
    list_1230.sar,
    list_1230.trend,
    list_1230.reporting_date,
    list_1230.expect_ratio,
        CASE
            WHEN (list_1230.rec IS NULL) THEN 'NULL'::character varying
            ELSE list_1230.rec
        END AS rec,
        CASE
            WHEN (list_1230.financial_healthy IS NULL) THEN 'NULL'::character varying
            ELSE (list_1230.financial_healthy)::character varying
        END AS financial_healthy,
        CASE
            WHEN (list_1230.pe_ranking IS NULL) THEN 'NULL'::character varying
            ELSE (list_1230.pe_ranking)::character varying
        END AS pe_ranking
   FROM rtc.list_1230
  WHERE ((list_1230.load_date = CURRENT_DATE) AND ((list_1230.sys_load_time)::date = CURRENT_DATE));


--
-- Name: v_current_list_1345; Type: VIEW; Schema: rtc; Owner: -
--

CREATE VIEW rtc.v_current_list_1345 AS
 SELECT list_1345.category,
    list_1345.code,
    list_1345.popularity,
    list_1345.sar,
    list_1345.trend,
    list_1345.reporting_date,
    list_1345.expect_ratio,
        CASE
            WHEN (list_1345.rec IS NULL) THEN 'NULL'::character varying
            ELSE list_1345.rec
        END AS rec,
        CASE
            WHEN (list_1345.financial_healthy IS NULL) THEN 'NULL'::character varying
            ELSE (list_1345.financial_healthy)::character varying
        END AS financial_healthy,
        CASE
            WHEN (list_1345.pe_ranking IS NULL) THEN 'NULL'::character varying
            ELSE (list_1345.pe_ranking)::character varying
        END AS pe_ranking
   FROM rtc.list_1345
  WHERE ((list_1345.load_date = CURRENT_DATE) AND ((list_1345.sys_load_time)::date = CURRENT_DATE));


--
-- Name: v_current_list_1500; Type: VIEW; Schema: rtc; Owner: -
--

CREATE VIEW rtc.v_current_list_1500 AS
 SELECT list_1500.category,
    list_1500.code,
    list_1500.popularity,
    list_1500.sar,
    list_1500.trend,
    list_1500.reporting_date,
    list_1500.expect_ratio,
        CASE
            WHEN (list_1500.rec IS NULL) THEN 'NULL'::character varying
            ELSE list_1500.rec
        END AS rec,
        CASE
            WHEN (list_1500.financial_healthy IS NULL) THEN 'NULL'::character varying
            ELSE (list_1500.financial_healthy)::character varying
        END AS financial_healthy,
        CASE
            WHEN (list_1500.pe_ranking IS NULL) THEN 'NULL'::character varying
            ELSE (list_1500.pe_ranking)::character varying
        END AS pe_ranking
   FROM rtc.list_1500
  WHERE ((list_1500.load_date = CURRENT_DATE) AND ((list_1500.sys_load_time)::date = CURRENT_DATE));


--
-- Name: analysis; Type: TABLE; Schema: vlt; Owner: -
--

CREATE TABLE vlt.analysis (
    code text,
    revenue numeric,
    net_income numeric,
    net_profit_margin numeric,
    ebitda numeric,
    fpe numeric,
    reco_price numeric,
    average_recommendation character varying,
    load_date date
);


--
-- Name: consensus; Type: TABLE; Schema: vlt; Owner: -
--

CREATE TABLE vlt.consensus (
    code character varying,
    load_date date,
    analysis integer,
    weight numeric(5,3),
    target_ratio numeric(3,2)
);


--
-- Name: finance; Type: TABLE; Schema: vlt; Owner: -
--

CREATE TABLE vlt.finance (
    code character varying,
    load_date date,
    open numeric(6,3),
    previous_close numeric(6,3),
    close numeric(6,3),
    volume bigint,
    forward_pe numeric,
    target_ratio numeric(5,3)
);


--
-- Name: forex_aud; Type: TABLE; Schema: vlt; Owner: -
--

CREATE TABLE vlt.forex_aud (
    instrument text,
    snapshot_on_gtc timestamp without time zone,
    bid numeric,
    ask numeric,
    sys_dt timestamp without time zone
);


--
-- Name: forex_eur; Type: TABLE; Schema: vlt; Owner: -
--

CREATE TABLE vlt.forex_eur (
    instrument text,
    snapshot_on_gtc timestamp without time zone,
    bid numeric,
    ask numeric,
    sys_dt timestamp without time zone
);


--
-- Name: forex_gbp; Type: TABLE; Schema: vlt; Owner: -
--

CREATE TABLE vlt.forex_gbp (
    instrument text,
    snapshot_on_gtc timestamp without time zone,
    bid numeric,
    ask numeric,
    sys_dt timestamp without time zone
);


--
-- Name: forex_jpy; Type: TABLE; Schema: vlt; Owner: -
--

CREATE TABLE vlt.forex_jpy (
    instrument text,
    snapshot_on_gtc timestamp without time zone,
    bid numeric,
    ask numeric,
    sys_dt timestamp without time zone
);


--
-- Name: v_analysis; Type: VIEW; Schema: vlt; Owner: -
--

CREATE VIEW vlt.v_analysis AS
 WITH temp AS (
         SELECT c.category,
            a_1.code,
            a_1.load_date,
            a_1.average_recommendation AS rec,
                CASE
                    WHEN (a_1.fpe IS NULL) THEN ('-999'::integer)::numeric
                    ELSE a_1.fpe
                END AS fpe,
            row_number() OVER (PARTITION BY a_1.code ORDER BY a_1.load_date DESC) AS rnum,
                CASE
                    WHEN (a_1.revenue IS NULL) THEN 0
                    WHEN (a_1.revenue > (0)::numeric) THEN 1
                    ELSE '-1'::integer
                END AS revenue,
                CASE
                    WHEN (a_1.net_income IS NULL) THEN 0
                    WHEN (a_1.net_income > (0)::numeric) THEN 1
                    ELSE '-1'::integer
                END AS net_income,
                CASE
                    WHEN (a_1.net_profit_margin IS NULL) THEN 0
                    WHEN (a_1.net_profit_margin > (0)::numeric) THEN 1
                    ELSE '-1'::integer
                END AS net_profit_margin,
                CASE
                    WHEN (a_1.ebitda IS NULL) THEN 0
                    WHEN (a_1.ebitda > (0)::numeric) THEN 1
                    ELSE '-1'::integer
                END AS ebitda
           FROM (vlt.analysis a_1
             JOIN mtd.code_category c ON ((a_1.code = (c.code)::text)))
        ), output AS (
         SELECT temp.category,
            temp.code,
            temp.load_date,
            temp.rec,
            temp.fpe,
            (((((((temp.revenue + temp.net_income) + temp.net_profit_margin) + temp.ebitda) + 4))::numeric / 8.0))::numeric(3,2) AS financial_healthy,
            row_number() OVER (PARTITION BY temp.category ORDER BY temp.fpe DESC) AS forward_pe
           FROM temp
          WHERE ((temp.rnum = 1) AND (temp.load_date > (CURRENT_DATE - '14 days'::interval)))
        ), agg AS (
         SELECT output.category,
            count(*) AS cnt
           FROM output
          GROUP BY output.category
        )
 SELECT o.category,
    o.code,
    o.load_date,
    o.rec,
    o.financial_healthy,
    (((1)::numeric - ((((o.forward_pe - 1))::numeric * 1.0) / ((a.cnt)::numeric - 1.0))))::numeric(4,3) AS pe_ranking
   FROM (output o
     JOIN agg a ON (((o.category)::text = (a.category)::text)));


--
-- Name: v_analysis0; Type: VIEW; Schema: vlt; Owner: -
--

CREATE VIEW vlt.v_analysis0 AS
 WITH temp AS (
         SELECT c.category,
            a_1.code,
            a_1.load_date,
            a_1.average_recommendation AS rec,
                CASE
                    WHEN (a_1.fpe IS NULL) THEN ('-999'::integer)::numeric
                    ELSE a_1.fpe
                END AS fpe,
            row_number() OVER (PARTITION BY a_1.code ORDER BY a_1.load_date DESC) AS rnum,
                CASE
                    WHEN (a_1.revenue IS NULL) THEN '/'::text
                    WHEN (a_1.revenue > (0)::numeric) THEN 'P'::text
                    ELSE 'N'::text
                END AS revenue,
                CASE
                    WHEN (a_1.net_income IS NULL) THEN '/'::text
                    WHEN (a_1.net_income > (0)::numeric) THEN 'P'::text
                    ELSE 'N'::text
                END AS net_income,
                CASE
                    WHEN (a_1.net_profit_margin IS NULL) THEN '/'::text
                    WHEN (a_1.net_profit_margin > (0)::numeric) THEN 'P'::text
                    ELSE 'N'::text
                END AS net_profit_margin,
                CASE
                    WHEN (a_1.ebitda IS NULL) THEN '/'::text
                    WHEN (a_1.ebitda > (0)::numeric) THEN 'P'::text
                    ELSE 'N'::text
                END AS ebitda
           FROM (vlt.analysis a_1
             JOIN mtd.code_category c ON ((a_1.code = (c.code)::text)))
        ), output AS (
         SELECT temp.category,
            temp.code,
            temp.load_date,
            temp.rec,
            temp.fpe,
            concat(temp.revenue, ' ~ ', temp.net_income, ' ~ ', temp.net_profit_margin, ' ~ ', temp.ebitda) AS financial_healthy,
            row_number() OVER (PARTITION BY temp.category ORDER BY temp.fpe DESC) AS forward_pe
           FROM temp
          WHERE ((temp.rnum = 1) AND (temp.load_date > (CURRENT_DATE - '14 days'::interval)))
        ), agg AS (
         SELECT output.category,
            count(*) AS cnt
           FROM output
          GROUP BY output.category
        )
 SELECT o.category,
    o.code,
    o.load_date,
    o.rec,
    o.financial_healthy,
    (((1)::numeric - ((((o.forward_pe - 1))::numeric * 1.0) / ((a.cnt)::numeric - 1.0))))::numeric(4,3) AS pe_ranking
   FROM (output o
     JOIN agg a ON (((o.category)::text = (a.category)::text)));


--
-- Name: daily_long_list; Type: TABLE; Schema: xpt; Owner: -
--

CREATE TABLE xpt.daily_long_list (
    category character varying,
    code character varying,
    load_date date,
    quarterly_direction numeric,
    semester_direction numeric,
    quarterly_stability numeric,
    semester_stability numeric
);


--
-- Name: daily_summary; Type: TABLE; Schema: xpt; Owner: -
--

CREATE TABLE xpt.daily_summary (
    category character varying,
    code character varying,
    report_date date,
    price numeric(8,3),
    ema25 character varying,
    sar_buff text,
    trend text,
    rec character varying,
    financial_healthy numeric(3,2),
    pe_ranking numeric(4,3),
    load_date date DEFAULT CURRENT_DATE
);


--
-- Name: daily_mail; Type: VIEW; Schema: xpt; Owner: -
--

CREATE VIEW xpt.daily_mail AS
 WITH temp AS (
         SELECT daily_summary.load_date,
            row_number() OVER (ORDER BY daily_summary.load_date DESC) AS rnum
           FROM xpt.daily_summary
          GROUP BY daily_summary.load_date
        ), c_set AS (
         SELECT d.category,
            d.code,
            d.report_date,
            d.price,
            d.ema25,
            d.sar_buff,
            d.trend,
            d.rec,
            d.financial_healthy,
            d.pe_ranking,
            d.load_date
           FROM (xpt.daily_summary d
             JOIN temp t ON (((d.load_date = t.load_date) AND (t.rnum = 1))))
        ), p_set AS (
         SELECT d.category,
            d.code,
            d.report_date,
            d.price,
            d.ema25,
            d.sar_buff,
            d.trend,
            d.rec,
            d.financial_healthy,
            d.pe_ranking,
            d.load_date
           FROM (xpt.daily_summary d
             JOIN temp t ON (((d.load_date = t.load_date) AND (t.rnum = 2))))
        ), combination AS (
         SELECT c.category,
            c.code,
            c.report_date,
            c.price,
            c.ema25,
            c.sar_buff,
            c.trend,
            c.rec,
            c.financial_healthy,
            c.pe_ranking,
            c.load_date,
                CASE
                    WHEN (p.code IS NULL) THEN true
                    ELSE false
                END AS is_new
           FROM (c_set c
             LEFT JOIN p_set p ON (((c.code)::text = (p.code)::text)))
        ), output AS (
         SELECT c.category,
            c.code,
            c.price,
            c.ema25,
            c.sar_buff AS org_sar,
                CASE
                    WHEN (c.sar_buff IS NULL) THEN NULL::text
                    ELSE concat(c.sar_buff, '~', ((r.avg_diff + r.std_diff))::numeric(6,2), '%')
                END AS sar_buff,
            c.trend,
            c.rec,
            c.financial_healthy,
            c.pe_ranking,
                CASE
                    WHEN ((c.is_new IS TRUE) OR (("substring"(c.sar_buff, 1, (length(c.sar_buff) - 1)))::numeric < (r.avg_diff + r.std_diff))) THEN true
                    ELSE false
                END AS watch_point
           FROM (combination c
             JOIN mnp.v_current_simple_moving_range r ON (((c.code)::text = (r.code)::text)))
        )
 SELECT
        CASE
            WHEN (output.category IS NULL) THEN 'NULL'::character varying
            ELSE output.category
        END AS category,
        CASE
            WHEN (output.code IS NULL) THEN 'NULL'::character varying
            ELSE output.code
        END AS code,
        CASE
            WHEN (output.price IS NULL) THEN 'NULL'::character varying
            ELSE (output.price)::character varying
        END AS price,
        CASE
            WHEN (output.ema25 IS NULL) THEN 'NULL'::character varying
            ELSE output.ema25
        END AS ema25,
        CASE
            WHEN (output.sar_buff IS NULL) THEN 'NULL'::character varying
            ELSE (output.sar_buff)::character varying
        END AS sar_buff,
        CASE
            WHEN (output.trend IS NULL) THEN 'NULL'::character varying
            ELSE (output.trend)::character varying
        END AS trend,
        CASE
            WHEN (output.rec IS NULL) THEN 'NULL'::character varying
            ELSE output.rec
        END AS rec,
        CASE
            WHEN (output.financial_healthy IS NULL) THEN 'NULL'::character varying
            ELSE (output.financial_healthy)::character varying
        END AS financial_healthy,
        CASE
            WHEN (output.pe_ranking IS NULL) THEN 'NULL'::character varying
            ELSE (output.pe_ranking)::character varying
        END AS pe_ranking,
        CASE
            WHEN (output.watch_point IS NULL) THEN 'NULL'::character varying
            ELSE (output.watch_point)::character varying
        END AS watch_point
   FROM output
  ORDER BY
        CASE
            WHEN (output.watch_point IS NULL) THEN 'NULL'::character varying
            ELSE (output.watch_point)::character varying
        END DESC,
        CASE
            WHEN (output.category IS NULL) THEN 'NULL'::character varying
            ELSE output.category
        END, ("substring"(output.org_sar, 1, (length(output.org_sar) - 1)))::numeric;


--
-- Name: idx_cal; Type: INDEX; Schema: cal; Owner: -
--

CREATE UNIQUE INDEX idx_cal ON cal.actionable_list USING btree (code, load_date);


--
-- Name: idx_ce; Type: INDEX; Schema: cal; Owner: -
--

CREATE UNIQUE INDEX idx_ce ON cal.ema USING btree (code, load_date);


--
-- Name: idx_cet; Type: INDEX; Schema: cal; Owner: -
--

CREATE UNIQUE INDEX idx_cet ON cal.ema_trend USING btree (code, load_date);


--
-- Name: idx_cha; Type: INDEX; Schema: cal; Owner: -
--

CREATE UNIQUE INDEX idx_cha ON cal.heikin_ashi USING btree (code, load_date);


--
-- Name: idx_che; Type: INDEX; Schema: cal; Owner: -
--

CREATE UNIQUE INDEX idx_che ON cal.ha_ema USING btree (code, load_date);


--
-- Name: idx_chr; Type: INDEX; Schema: cal; Owner: -
--

CREATE UNIQUE INDEX idx_chr ON cal.ha_ranking USING btree (code, load_date);


--
-- Name: idx_cic; Type: INDEX; Schema: cal; Owner: -
--

CREATE UNIQUE INDEX idx_cic ON cal.index_component USING btree (code, load_date);


--
-- Name: idx_cid; Type: INDEX; Schema: cal; Owner: -
--

CREATE UNIQUE INDEX idx_cid ON cal.index_direction USING btree (category, load_date);


--
-- Name: idx_cm; Type: INDEX; Schema: cal; Owner: -
--

CREATE UNIQUE INDEX idx_cm ON cal.macd USING btree (code, load_date);


--
-- Name: idx_csmr; Type: INDEX; Schema: cal; Owner: -
--

CREATE UNIQUE INDEX idx_csmr ON cal.simple_moving_range USING btree (code, load_date);


--
-- Name: idx_csoh; Type: INDEX; Schema: cal; Owner: -
--

CREATE UNIQUE INDEX idx_csoh ON cal.stb_on_ha_ranking USING btree (code, load_date);


--
-- Name: idx_csos; Type: INDEX; Schema: cal; Owner: -
--

CREATE UNIQUE INDEX idx_csos ON cal.stb_on_sar_ranking USING btree (code, load_date);


--
-- Name: idx_ctd; Type: INDEX; Schema: cal; Owner: -
--

CREATE UNIQUE INDEX idx_ctd ON cal.trading_days USING btree (load_date);


--
-- Name: idx_cvb; Type: INDEX; Schema: cal; Owner: -
--

CREATE UNIQUE INDEX idx_cvb ON cal.volume_bands USING btree (code, load_date);


--
-- Name: idx_eoh; Type: INDEX; Schema: cal; Owner: -
--

CREATE UNIQUE INDEX idx_eoh ON cal.ema_on_ha_ranking USING btree (code, load_date);


--
-- Name: idx_eos; Type: INDEX; Schema: cal; Owner: -
--

CREATE UNIQUE INDEX idx_eos ON cal.ema_on_sar_ranking USING btree (code, load_date);


--
-- Name: idx_s; Type: INDEX; Schema: cal; Owner: -
--

CREATE UNIQUE INDEX idx_s ON cal.sar USING btree (code, load_date);


--
-- Name: idx_mal; Type: INDEX; Schema: mnp; Owner: -
--

CREATE UNIQUE INDEX idx_mal ON mnp.actionable_list USING btree (code, load_date);


--
-- Name: idx_me; Type: INDEX; Schema: mnp; Owner: -
--

CREATE UNIQUE INDEX idx_me ON mnp.ema USING btree (code, load_date);


--
-- Name: idx_met; Type: INDEX; Schema: mnp; Owner: -
--

CREATE UNIQUE INDEX idx_met ON mnp.ema_trend USING btree (code, load_date);


--
-- Name: idx_mqtds; Type: INDEX; Schema: mnp; Owner: -
--

CREATE UNIQUE INDEX idx_mqtds ON mnp.quarterly_trend_direction_source USING btree (code, load_date);


--
-- Name: idx_mqtsl; Type: INDEX; Schema: mnp; Owner: -
--

CREATE UNIQUE INDEX idx_mqtsl ON mnp.quarterly_trend_stability_list USING btree (code, load_date);


--
-- Name: idx_msmr; Type: INDEX; Schema: mnp; Owner: -
--

CREATE UNIQUE INDEX idx_msmr ON mnp.simple_moving_range USING btree (code, latest_date);


--
-- Name: idx_mstds; Type: INDEX; Schema: mnp; Owner: -
--

CREATE UNIQUE INDEX idx_mstds ON mnp.semester_trend_direction_source USING btree (code, load_date);


--
-- Name: idx_mstsl; Type: INDEX; Schema: mnp; Owner: -
--

CREATE UNIQUE INDEX idx_mstsl ON mnp.semester_trend_stability_list USING btree (code, load_date);


--
-- Name: idx_c_cd; Type: INDEX; Schema: ods; Owner: -
--

CREATE INDEX idx_c_cd ON ods.web_consensus USING btree (code);


--
-- Name: idx_f_cd; Type: INDEX; Schema: ods; Owner: -
--

CREATE INDEX idx_f_cd ON ods.web_finance USING btree (code);


--
-- Name: idx_q_cd; Type: INDEX; Schema: ods; Owner: -
--

CREATE INDEX idx_q_cd ON ods.web_quote USING btree (code);


--
-- Name: idx_s_cd; Type: INDEX; Schema: ods; Owner: -
--

CREATE INDEX idx_s_cd ON ods.web_short USING btree (product_code);


--
-- Name: idx_risr; Type: INDEX; Schema: rpt; Owner: -
--

CREATE UNIQUE INDEX idx_risr ON rpt.index_summary_report USING btree (category, load_date);


--
-- Name: idx_rlls; Type: INDEX; Schema: rpt; Owner: -
--

CREATE UNIQUE INDEX idx_rlls ON rpt.long_list_snapshot USING btree (code, load_date);


--
-- Name: idx_rsls; Type: INDEX; Schema: rpt; Owner: -
--

CREATE UNIQUE INDEX idx_rsls ON rpt.short_list_snapshot USING btree (code, load_date);


--
-- Name: idx_m1230; Type: INDEX; Schema: rtc; Owner: -
--

CREATE UNIQUE INDEX idx_m1230 ON rtc.macd_1230 USING btree (code, load_date);


--
-- Name: idx_m1345; Type: INDEX; Schema: rtc; Owner: -
--

CREATE UNIQUE INDEX idx_m1345 ON rtc.macd_1345 USING btree (code, load_date);


--
-- Name: idx_m1500; Type: INDEX; Schema: rtc; Owner: -
--

CREATE UNIQUE INDEX idx_m1500 ON rtc.macd_1500 USING btree (code, load_date);


--
-- Name: idx_re1230; Type: INDEX; Schema: rtc; Owner: -
--

CREATE UNIQUE INDEX idx_re1230 ON rtc.ema_1230 USING btree (code, load_date);


--
-- Name: idx_re1345; Type: INDEX; Schema: rtc; Owner: -
--

CREATE UNIQUE INDEX idx_re1345 ON rtc.ema_1345 USING btree (code, load_date);


--
-- Name: idx_re1500; Type: INDEX; Schema: rtc; Owner: -
--

CREATE UNIQUE INDEX idx_re1500 ON rtc.ema_1500 USING btree (code, load_date);


--
-- Name: idx_reoh1230; Type: INDEX; Schema: rtc; Owner: -
--

CREATE UNIQUE INDEX idx_reoh1230 ON rtc.ema_on_ha_1230 USING btree (code, load_date);


--
-- Name: idx_reoh1345; Type: INDEX; Schema: rtc; Owner: -
--

CREATE UNIQUE INDEX idx_reoh1345 ON rtc.ema_on_ha_1345 USING btree (code, load_date);


--
-- Name: idx_reoh1500; Type: INDEX; Schema: rtc; Owner: -
--

CREATE UNIQUE INDEX idx_reoh1500 ON rtc.ema_on_ha_1500 USING btree (code, load_date);


--
-- Name: idx_rh1230; Type: INDEX; Schema: rtc; Owner: -
--

CREATE UNIQUE INDEX idx_rh1230 ON rtc.ha_1230 USING btree (code, load_date);


--
-- Name: idx_rh1345; Type: INDEX; Schema: rtc; Owner: -
--

CREATE UNIQUE INDEX idx_rh1345 ON rtc.ha_1345 USING btree (code, load_date);


--
-- Name: idx_rh1500; Type: INDEX; Schema: rtc; Owner: -
--

CREATE UNIQUE INDEX idx_rh1500 ON rtc.ha_1500 USING btree (code, load_date);


--
-- Name: idx_ri1230; Type: INDEX; Schema: rtc; Owner: -
--

CREATE UNIQUE INDEX idx_ri1230 ON rtc.index_1230 USING btree (category, load_date);


--
-- Name: idx_ri1345; Type: INDEX; Schema: rtc; Owner: -
--

CREATE UNIQUE INDEX idx_ri1345 ON rtc.index_1345 USING btree (category, load_date);


--
-- Name: idx_ri1500; Type: INDEX; Schema: rtc; Owner: -
--

CREATE UNIQUE INDEX idx_ri1500 ON rtc.index_1500 USING btree (category, load_date);


--
-- Name: idx_rl1230; Type: INDEX; Schema: rtc; Owner: -
--

CREATE UNIQUE INDEX idx_rl1230 ON rtc.list_1230 USING btree (code, load_date);


--
-- Name: idx_rl1345; Type: INDEX; Schema: rtc; Owner: -
--

CREATE UNIQUE INDEX idx_rl1345 ON rtc.list_1345 USING btree (code, load_date);


--
-- Name: idx_rl1500; Type: INDEX; Schema: rtc; Owner: -
--

CREATE UNIQUE INDEX idx_rl1500 ON rtc.list_1500 USING btree (code, load_date);


--
-- Name: idx_va; Type: INDEX; Schema: vlt; Owner: -
--

CREATE UNIQUE INDEX idx_va ON vlt.analysis USING btree (code, load_date);


--
-- Name: idx_vc; Type: INDEX; Schema: vlt; Owner: -
--

CREATE UNIQUE INDEX idx_vc ON vlt.consensus USING btree (code, load_date);


--
-- Name: idx_vf; Type: INDEX; Schema: vlt; Owner: -
--

CREATE UNIQUE INDEX idx_vf ON vlt.finance USING btree (code, load_date);


--
-- Name: idx_vn; Type: INDEX; Schema: vlt; Owner: -
--

CREATE UNIQUE INDEX idx_vn ON vlt.announcements USING btree (code, pub_datetime);


--
-- Name: idx_vq; Type: INDEX; Schema: vlt; Owner: -
--

CREATE UNIQUE INDEX idx_vq ON vlt.quotes USING btree (code, load_date);


--
-- Name: idx_vr_1230; Type: INDEX; Schema: vlt; Owner: -
--

CREATE UNIQUE INDEX idx_vr_1230 ON vlt.rush_1230 USING btree (code, load_date);


--
-- Name: idx_vr_1345; Type: INDEX; Schema: vlt; Owner: -
--

CREATE UNIQUE INDEX idx_vr_1345 ON vlt.rush_1345 USING btree (code, load_date);


--
-- Name: idx_vr_1500; Type: INDEX; Schema: vlt; Owner: -
--

CREATE UNIQUE INDEX idx_vr_1500 ON vlt.rush_1500 USING btree (code, load_date);


--
-- Name: idx_vs; Type: INDEX; Schema: vlt; Owner: -
--

CREATE UNIQUE INDEX idx_vs ON vlt.shorts USING btree (code, load_date);


--
-- Name: idx_xdll; Type: INDEX; Schema: xpt; Owner: -
--

CREATE UNIQUE INDEX idx_xdll ON xpt.daily_long_list USING btree (code, load_date);


--
-- Name: idx_xds; Type: INDEX; Schema: xpt; Owner: -
--

CREATE UNIQUE INDEX idx_xds ON xpt.daily_summary USING btree (code, load_date);


--
-- PostgreSQL database dump complete
--

